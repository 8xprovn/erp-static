/*! jQuery UI - v1.13.2 - 2022-07-14
 * http://jqueryui.com
 * Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
 * Copyright jQuery Foundation and other contributors; Licensed MIT */

(function (factory) {
    "use strict";

    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(["jquery"], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
})(function ($) {
    "use strict";

    $.ui = $.ui || {};

    var version = ($.ui.version = "1.13.2");

    /*!
     * jQuery UI Widget 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Widget
    //>>group: Core
    //>>description: Provides a factory for creating stateful widgets with a common API.
    //>>docs: http://api.jqueryui.com/jQuery.widget/
    //>>demos: http://jqueryui.com/widget/

    var widgetUuid = 0;
    var widgetHasOwnProperty = Array.prototype.hasOwnProperty;
    var widgetSlice = Array.prototype.slice;

    $.cleanData = (function (orig) {
        return function (elems) {
            var events, elem, i;
            for (i = 0; (elem = elems[i]) != null; i++) {
                // Only trigger remove when necessary to save time
                events = $._data(elem, "events");
                if (events && events.remove) {
                    $(elem).triggerHandler("remove");
                }
            }
            orig(elems);
        };
    })($.cleanData);

    $.widget = function (name, base, prototype) {
        var existingConstructor, constructor, basePrototype;

        // ProxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        var proxiedPrototype = {};

        var namespace = name.split(".")[0];
        name = name.split(".")[1];
        var fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        if (Array.isArray(prototype)) {
            prototype = $.extend.apply(null, [{}].concat(prototype));
        }

        // Create selector for plugin
        $.expr.pseudos[fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function (options, element) {
            // Allow instantiation without "new" keyword
            if (!this || !this._createWidget) {
                return new constructor(options, element);
            }

            // Allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };

        // Extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,

            // Copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),

            // Track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: [],
        });

        basePrototype = new base();

        // We need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function (prop, value) {
            if (typeof value !== "function") {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function () {
                function _super() {
                    return base.prototype[prop].apply(this, arguments);
                }

                function _superApply(args) {
                    return base.prototype[prop].apply(this, args);
                }

                return function () {
                    var __super = this._super;
                    var __superApply = this._superApply;
                    var returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(
            basePrototype,
            {
                // TODO: remove support for widgetEventPrefix
                // always use the name + a colon as the prefix, e.g., draggable:start
                // don't prefix for widgets that aren't DOM-based
                widgetEventPrefix: existingConstructor
                    ? basePrototype.widgetEventPrefix || name
                    : name,
            },
            proxiedPrototype,
            {
                constructor: constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName,
            }
        );

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;

                // Redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(
                    childPrototype.namespace + "." + childPrototype.widgetName,
                    constructor,
                    child._proto
                );
            });

            // Remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);

        return constructor;
    };

    $.widget.extend = function (target) {
        var input = widgetSlice.call(arguments, 1);
        var inputIndex = 0;
        var inputLength = input.length;
        var key;
        var value;

        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (
                    widgetHasOwnProperty.call(input[inputIndex], key) &&
                    value !== undefined
                ) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key])
                            ? $.widget.extend({}, target[key], value)
                            : // Don't extend strings, arrays, etc. with objects
                              $.widget.extend({}, value);

                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = typeof options === "string";
            var args = widgetSlice.call(arguments, 1);
            var returnValue = this;

            if (isMethodCall) {
                // If this is an empty collection, we need to have the instance method
                // return undefined instead of the jQuery instance
                if (!this.length && options === "instance") {
                    returnValue = undefined;
                } else {
                    this.each(function () {
                        var methodValue;
                        var instance = $.data(this, fullName);

                        if (options === "instance") {
                            returnValue = instance;
                            return false;
                        }

                        if (!instance) {
                            return $.error(
                                "cannot call methods on " +
                                    name +
                                    " prior to initialization; " +
                                    "attempted to call method '" +
                                    options +
                                    "'"
                            );
                        }

                        if (
                            typeof instance[options] !== "function" ||
                            options.charAt(0) === "_"
                        ) {
                            return $.error(
                                "no such method '" +
                                    options +
                                    "' for " +
                                    name +
                                    " widget instance"
                            );
                        }

                        methodValue = instance[options].apply(instance, args);

                        if (
                            methodValue !== instance &&
                            methodValue !== undefined
                        ) {
                            returnValue =
                                methodValue && methodValue.jquery
                                    ? returnValue.pushStack(methodValue.get())
                                    : methodValue;
                            return false;
                        }
                    });
                }
            } else {
                // Allow multiple hashes to be passed on init
                if (args.length) {
                    options = $.widget.extend.apply(
                        null,
                        [options].concat(args)
                    );
                }

                this.each(function () {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function (/* options, element */) {};
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",

        options: {
            classes: {},
            disabled: false,

            // Callbacks
            create: null,
        },

        _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widgetUuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            this.classesElementLookup = {};

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function (event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    },
                });
                this.document = $(
                    element.style
                        ? // Element within the document
                          element.ownerDocument
                        : // Element is window or document
                          element.document || element
                );
                this.window = $(
                    this.document[0].defaultView ||
                        this.document[0].parentWindow
                );
            }

            this.options = $.widget.extend(
                {},
                this.options,
                this._getCreateOptions(),
                options
            );

            this._create();

            if (this.options.disabled) {
                this._setOptionDisabled(this.options.disabled);
            }

            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },

        _getCreateOptions: function () {
            return {};
        },

        _getCreateEventData: $.noop,

        _create: $.noop,

        _init: $.noop,

        destroy: function () {
            var that = this;

            this._destroy();
            $.each(this.classesElementLookup, function (key, value) {
                that._removeClass(value, key);
            });

            // We can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .off(this.eventNamespace)
                .removeData(this.widgetFullName);
            this.widget().off(this.eventNamespace).removeAttr("aria-disabled");

            // Clean up events and states
            this.bindings.off(this.eventNamespace);
        },

        _destroy: $.noop,

        widget: function () {
            return this.element;
        },

        option: function (key, value) {
            var options = key;
            var parts;
            var curOption;
            var i;

            if (arguments.length === 0) {
                // Don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend(
                        {},
                        this.options[key]
                    );
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined
                            ? null
                            : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined
                            ? null
                            : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },

        _setOptions: function (options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },

        _setOption: function (key, value) {
            if (key === "classes") {
                this._setOptionClasses(value);
            }

            this.options[key] = value;

            if (key === "disabled") {
                this._setOptionDisabled(value);
            }

            return this;
        },

        _setOptionClasses: function (value) {
            var classKey, elements, currentElements;

            for (classKey in value) {
                currentElements = this.classesElementLookup[classKey];
                if (
                    value[classKey] === this.options.classes[classKey] ||
                    !currentElements ||
                    !currentElements.length
                ) {
                    continue;
                }

                // We are doing this to create a new jQuery object because the _removeClass() call
                // on the next line is going to destroy the reference to the current elements being
                // tracked. We need to save a copy of this collection so that we can add the new classes
                // below.
                elements = $(currentElements.get());
                this._removeClass(currentElements, classKey);

                // We don't use _addClass() here, because that uses this.options.classes
                // for generating the string of classes. We want to use the value passed in from
                // _setOption(), this is the new value of the classes option which was passed to
                // _setOption(). We pass this value directly to _classes().
                elements.addClass(
                    this._classes({
                        element: elements,
                        keys: classKey,
                        classes: value,
                        add: true,
                    })
                );
            }
        },

        _setOptionDisabled: function (value) {
            this._toggleClass(
                this.widget(),
                this.widgetFullName + "-disabled",
                null,
                !!value
            );

            // If the widget is becoming disabled, then nothing is interactive
            if (value) {
                this._removeClass(this.hoverable, null, "ui-state-hover");
                this._removeClass(this.focusable, null, "ui-state-focus");
            }
        },

        enable: function () {
            return this._setOptions({ disabled: false });
        },

        disable: function () {
            return this._setOptions({ disabled: true });
        },

        _classes: function (options) {
            var full = [];
            var that = this;

            options = $.extend(
                {
                    element: this.element,
                    classes: this.options.classes || {},
                },
                options
            );

            function bindRemoveEvent() {
                var nodesToBind = [];

                options.element.each(function (_, element) {
                    var isTracked = $.map(
                        that.classesElementLookup,
                        function (elements) {
                            return elements;
                        }
                    ).some(function (elements) {
                        return elements.is(element);
                    });

                    if (!isTracked) {
                        nodesToBind.push(element);
                    }
                });

                that._on($(nodesToBind), {
                    remove: "_untrackClassesElement",
                });
            }

            function processClassString(classes, checkOption) {
                var current, i;
                for (i = 0; i < classes.length; i++) {
                    current = that.classesElementLookup[classes[i]] || $();
                    if (options.add) {
                        bindRemoveEvent();
                        current = $(
                            $.uniqueSort(
                                current.get().concat(options.element.get())
                            )
                        );
                    } else {
                        current = $(current.not(options.element).get());
                    }
                    that.classesElementLookup[classes[i]] = current;
                    full.push(classes[i]);
                    if (checkOption && options.classes[classes[i]]) {
                        full.push(options.classes[classes[i]]);
                    }
                }
            }

            if (options.keys) {
                processClassString(options.keys.match(/\S+/g) || [], true);
            }
            if (options.extra) {
                processClassString(options.extra.match(/\S+/g) || []);
            }

            return full.join(" ");
        },

        _untrackClassesElement: function (event) {
            var that = this;
            $.each(that.classesElementLookup, function (key, value) {
                if ($.inArray(event.target, value) !== -1) {
                    that.classesElementLookup[key] = $(
                        value.not(event.target).get()
                    );
                }
            });

            this._off($(event.target));
        },

        _removeClass: function (element, keys, extra) {
            return this._toggleClass(element, keys, extra, false);
        },

        _addClass: function (element, keys, extra) {
            return this._toggleClass(element, keys, extra, true);
        },

        _toggleClass: function (element, keys, extra, add) {
            add = typeof add === "boolean" ? add : extra;
            var shift = typeof element === "string" || element === null,
                options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add,
                };
            options.element.toggleClass(this._classes(options), add);
            return this;
        },

        _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement;
            var instance = this;

            // No suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // No element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    // Allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (
                        !suppressDisabledCheck &&
                        (instance.options.disabled === true ||
                            $(this).hasClass("ui-state-disabled"))
                    ) {
                        return;
                    }
                    return (
                        typeof handler === "string"
                            ? instance[handler]
                            : handler
                    ).apply(instance, arguments);
                }

                // Copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^([\w:-]*)\s*(.*)$/);
                var eventName = match[1] + instance.eventNamespace;
                var selector = match[2];

                if (selector) {
                    delegateElement.on(eventName, selector, handlerProxy);
                } else {
                    element.on(eventName, handlerProxy);
                }
            });
        },

        _off: function (element, eventName) {
            eventName =
                (eventName || "").split(" ").join(this.eventNamespace + " ") +
                this.eventNamespace;
            element.off(eventName);

            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get());
        },

        _delay: function (handler, delay) {
            function handlerProxy() {
                return (
                    typeof handler === "string" ? instance[handler] : handler
                ).apply(instance, arguments);
            }

            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function (event) {
                    this._addClass(
                        $(event.currentTarget),
                        null,
                        "ui-state-hover"
                    );
                },
                mouseleave: function (event) {
                    this._removeClass(
                        $(event.currentTarget),
                        null,
                        "ui-state-hover"
                    );
                },
            });
        },

        _focusable: function (element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function (event) {
                    this._addClass(
                        $(event.currentTarget),
                        null,
                        "ui-state-focus"
                    );
                },
                focusout: function (event) {
                    this._removeClass(
                        $(event.currentTarget),
                        null,
                        "ui-state-focus"
                    );
                },
            });
        },

        _trigger: function (type, event, data) {
            var prop, orig;
            var callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (
                type === this.widgetEventPrefix
                    ? type
                    : this.widgetEventPrefix + type
            ).toLowerCase();

            // The original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // Copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !(
                (typeof callback === "function" &&
                    callback.apply(this.element[0], [event].concat(data)) ===
                        false) ||
                event.isDefaultPrevented()
            );
        },
    };

    $.each(
        { show: "fadeIn", hide: "fadeOut" },
        function (method, defaultEffect) {
            $.Widget.prototype["_" + method] = function (
                element,
                options,
                callback
            ) {
                if (typeof options === "string") {
                    options = { effect: options };
                }

                var hasOptions;
                var effectName = !options
                    ? method
                    : options === true || typeof options === "number"
                    ? defaultEffect
                    : options.effect || defaultEffect;

                options = options || {};
                if (typeof options === "number") {
                    options = { duration: options };
                } else if (options === true) {
                    options = {};
                }

                hasOptions = !$.isEmptyObject(options);
                options.complete = callback;

                if (options.delay) {
                    element.delay(options.delay);
                }

                if (hasOptions && $.effects && $.effects.effect[effectName]) {
                    element[method](options);
                } else if (effectName !== method && element[effectName]) {
                    element[effectName](
                        options.duration,
                        options.easing,
                        callback
                    );
                } else {
                    element.queue(function (next) {
                        $(this)[method]();
                        if (callback) {
                            callback.call(element[0]);
                        }
                        next();
                    });
                }
            };
        }
    );

    var widget = $.widget;

    /*!
     * jQuery UI Position 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/position/
     */

    //>>label: Position
    //>>group: Core
    //>>description: Positions elements relative to other elements.
    //>>docs: http://api.jqueryui.com/position/
    //>>demos: http://jqueryui.com/position/

    (function () {
        var cachedScrollbarWidth,
            max = Math.max,
            abs = Math.abs,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;

        function getOffsets(offsets, width, height) {
            return [
                parseFloat(offsets[0]) *
                    (rpercent.test(offsets[0]) ? width / 100 : 1),
                parseFloat(offsets[1]) *
                    (rpercent.test(offsets[1]) ? height / 100 : 1),
            ];
        }

        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }

        function isWindow(obj) {
            return obj != null && obj === obj.window;
        }

        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: 0, left: 0 },
                };
            }
            if (isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: elem.scrollTop(), left: elem.scrollLeft() },
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: { top: raw.pageY, left: raw.pageX },
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset(),
            };
        }

        $.position = {
            scrollbarWidth: function () {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1,
                    w2,
                    div = $(
                        "<div style=" +
                            "'display:block;position:absolute;width:200px;height:200px;overflow:hidden;'>" +
                            "<div style='height:300px;width:auto;'></div></div>"
                    ),
                    innerDiv = div.children()[0];

                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");

                w2 = innerDiv.offsetWidth;

                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }

                div.remove();

                return (cachedScrollbarWidth = w1 - w2);
            },
            getScrollInfo: function (within) {
                var overflowX =
                        within.isWindow || within.isDocument
                            ? ""
                            : within.element.css("overflow-x"),
                    overflowY =
                        within.isWindow || within.isDocument
                            ? ""
                            : within.element.css("overflow-y"),
                    hasOverflowX =
                        overflowX === "scroll" ||
                        (overflowX === "auto" &&
                            within.width < within.element[0].scrollWidth),
                    hasOverflowY =
                        overflowY === "scroll" ||
                        (overflowY === "auto" &&
                            within.height < within.element[0].scrollHeight);
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0,
                };
            },
            getWithinInfo: function (element) {
                var withinElement = $(element || window),
                    isElemWindow = isWindow(withinElement[0]),
                    isDocument =
                        !!withinElement[0] && withinElement[0].nodeType === 9,
                    hasOffset = !isElemWindow && !isDocument;
                return {
                    element: withinElement,
                    isWindow: isElemWindow,
                    isDocument: isDocument,
                    offset: hasOffset
                        ? $(element).offset()
                        : { left: 0, top: 0 },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: withinElement.outerWidth(),
                    height: withinElement.outerHeight(),
                };
            },
        };

        $.fn.position = function (options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }

            // Make a copy, we don't want to modify arguments
            options = $.extend({}, options);

            var atOffset,
                targetWidth,
                targetHeight,
                targetOffset,
                basePosition,
                dimensions,
                // Make sure string options are treated as CSS selectors
                target =
                    typeof options.of === "string"
                        ? $(document).find(options.of)
                        : $(options.of),
                within = $.position.getWithinInfo(options.within),
                scrollInfo = $.position.getScrollInfo(within),
                collision = (options.collision || "flip").split(" "),
                offsets = {};

            dimensions = getDimensions(target);
            if (target[0].preventDefault) {
                // Force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;

            // Clone to reuse original targetOffset later
            basePosition = $.extend({}, targetOffset);

            // Force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each(["my", "at"], function () {
                var pos = (options[this] || "").split(" "),
                    horizontalOffset,
                    verticalOffset;

                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0])
                        ? pos.concat(["center"])
                        : rvertical.test(pos[0])
                        ? ["center"].concat(pos)
                        : ["center", "center"];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

                // Calculate offsets
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [
                    horizontalOffset ? horizontalOffset[0] : 0,
                    verticalOffset ? verticalOffset[0] : 0,
                ];

                // Reduce to just the positions without the offsets
                options[this] = [
                    rposition.exec(pos[0])[0],
                    rposition.exec(pos[1])[0],
                ];
            });

            // Normalize collision option
            if (collision.length === 1) {
                collision[1] = collision[0];
            }

            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }

            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];

            return this.each(function () {
                var collisionPosition,
                    using,
                    elem = $(this),
                    elemWidth = elem.outerWidth(),
                    elemHeight = elem.outerHeight(),
                    marginLeft = parseCss(this, "marginLeft"),
                    marginTop = parseCss(this, "marginTop"),
                    collisionWidth =
                        elemWidth +
                        marginLeft +
                        parseCss(this, "marginRight") +
                        scrollInfo.width,
                    collisionHeight =
                        elemHeight +
                        marginTop +
                        parseCss(this, "marginBottom") +
                        scrollInfo.height,
                    position = $.extend({}, basePosition),
                    myOffset = getOffsets(
                        offsets.my,
                        elem.outerWidth(),
                        elem.outerHeight()
                    );

                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }

                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[0];
                position.top += myOffset[1];

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop,
                };

                $.each(["left", "top"], function (i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [
                                atOffset[0] + myOffset[0],
                                atOffset[1] + myOffset[1],
                            ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem,
                        });
                    }
                });

                if (options.using) {
                    // Adds feedback as second argument to using callback, if present
                    using = function (props) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight,
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight,
                                },
                                horizontal:
                                    right < 0
                                        ? "left"
                                        : left > 0
                                        ? "right"
                                        : "center",
                                vertical:
                                    bottom < 0
                                        ? "top"
                                        : top > 0
                                        ? "bottom"
                                        : "middle",
                            };
                        if (
                            targetWidth < elemWidth &&
                            abs(left + right) < targetWidth
                        ) {
                            feedback.horizontal = "center";
                        }
                        if (
                            targetHeight < elemHeight &&
                            abs(top + bottom) < targetHeight
                        ) {
                            feedback.vertical = "middle";
                        }
                        if (
                            max(abs(left), abs(right)) >
                            max(abs(top), abs(bottom))
                        ) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }

                elem.offset($.extend(position, { using: using }));
            });
        };

        $.ui.position = {
            fit: {
                left: function (position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow
                            ? within.scrollLeft
                            : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft =
                            position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight =
                            collisionPosLeft +
                            data.collisionWidth -
                            outerWidth -
                            withinOffset,
                        newOverRight;

                    // Element is wider than within
                    if (data.collisionWidth > outerWidth) {
                        // Element is initially over the left side of within
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight =
                                position.left +
                                overLeft +
                                data.collisionWidth -
                                outerWidth -
                                withinOffset;
                            position.left += overLeft - newOverRight;

                            // Element is initially over right side of within
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;

                            // Element is initially over both left and right sides of within
                        } else {
                            if (overLeft > overRight) {
                                position.left =
                                    withinOffset +
                                    outerWidth -
                                    data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }

                        // Too far left -> align with left edge
                    } else if (overLeft > 0) {
                        position.left += overLeft;

                        // Too far right -> align with right edge
                    } else if (overRight > 0) {
                        position.left -= overRight;

                        // Adjust based on position and margin
                    } else {
                        position.left = max(
                            position.left - collisionPosLeft,
                            position.left
                        );
                    }
                },
                top: function (position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow
                            ? within.scrollTop
                            : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop =
                            position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom =
                            collisionPosTop +
                            data.collisionHeight -
                            outerHeight -
                            withinOffset,
                        newOverBottom;

                    // Element is taller than within
                    if (data.collisionHeight > outerHeight) {
                        // Element is initially over the top of within
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom =
                                position.top +
                                overTop +
                                data.collisionHeight -
                                outerHeight -
                                withinOffset;
                            position.top += overTop - newOverBottom;

                            // Element is initially over bottom of within
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;

                            // Element is initially over both top and bottom of within
                        } else {
                            if (overTop > overBottom) {
                                position.top =
                                    withinOffset +
                                    outerHeight -
                                    data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }

                        // Too far up -> align with top
                    } else if (overTop > 0) {
                        position.top += overTop;

                        // Too far down -> align with bottom edge
                    } else if (overBottom > 0) {
                        position.top -= overBottom;

                        // Adjust based on position and margin
                    } else {
                        position.top = max(
                            position.top - collisionPosTop,
                            position.top
                        );
                    }
                },
            },
            flip: {
                left: function (position, data) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow
                            ? within.scrollLeft
                            : within.offset.left,
                        collisionPosLeft =
                            position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight =
                            collisionPosLeft +
                            data.collisionWidth -
                            outerWidth -
                            offsetLeft,
                        myOffset =
                            data.my[0] === "left"
                                ? -data.elemWidth
                                : data.my[0] === "right"
                                ? data.elemWidth
                                : 0,
                        atOffset =
                            data.at[0] === "left"
                                ? data.targetWidth
                                : data.at[0] === "right"
                                ? -data.targetWidth
                                : 0,
                        offset = -2 * data.offset[0],
                        newOverRight,
                        newOverLeft;

                    if (overLeft < 0) {
                        newOverRight =
                            position.left +
                            myOffset +
                            atOffset +
                            offset +
                            data.collisionWidth -
                            outerWidth -
                            withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft =
                            position.left -
                            data.collisionPosition.marginLeft +
                            myOffset +
                            atOffset +
                            offset -
                            offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function (position, data) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow
                            ? within.scrollTop
                            : within.offset.top,
                        collisionPosTop =
                            position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom =
                            collisionPosTop +
                            data.collisionHeight -
                            outerHeight -
                            offsetTop,
                        top = data.my[1] === "top",
                        myOffset = top
                            ? -data.elemHeight
                            : data.my[1] === "bottom"
                            ? data.elemHeight
                            : 0,
                        atOffset =
                            data.at[1] === "top"
                                ? data.targetHeight
                                : data.at[1] === "bottom"
                                ? -data.targetHeight
                                : 0,
                        offset = -2 * data.offset[1],
                        newOverTop,
                        newOverBottom;
                    if (overTop < 0) {
                        newOverBottom =
                            position.top +
                            myOffset +
                            atOffset +
                            offset +
                            data.collisionHeight -
                            outerHeight -
                            withinOffset;
                        if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop =
                            position.top -
                            data.collisionPosition.marginTop +
                            myOffset +
                            atOffset +
                            offset -
                            offsetTop;
                        if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                },
            },
            flipfit: {
                left: function () {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function () {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                },
            },
        };
    })();

    var position = $.ui.position;

    /*!
     * jQuery UI :data 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: :data Selector
    //>>group: Core
    //>>description: Selects elements which have data stored under the specified key.
    //>>docs: http://api.jqueryui.com/data-selector/

    var data = $.extend($.expr.pseudos, {
        data: $.expr.createPseudo
            ? $.expr.createPseudo(function (dataName) {
                  return function (elem) {
                      return !!$.data(elem, dataName);
                  };
              })
            : // Support: jQuery <1.8
              function (elem, i, match) {
                  return !!$.data(elem, match[3]);
              },
    });

    /*!
     * jQuery UI Disable Selection 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: disableSelection
    //>>group: Core
    //>>description: Disable selection of text content within the set of matched elements.
    //>>docs: http://api.jqueryui.com/disableSelection/

    // This file is deprecated

    var disableSelection = $.fn.extend({
        disableSelection: (function () {
            var eventType =
                "onselectstart" in document.createElement("div")
                    ? "selectstart"
                    : "mousedown";

            return function () {
                return this.on(
                    eventType + ".ui-disableSelection",
                    function (event) {
                        event.preventDefault();
                    }
                );
            };
        })(),

        enableSelection: function () {
            return this.off(".ui-disableSelection");
        },
    });

    // Create a local jQuery because jQuery Color relies on it and the
    // global may not exist with AMD and a custom build (#10199).
    // This module is a noop if used as a regular AMD module.
    // eslint-disable-next-line no-unused-vars
    var jQuery = $;

    /*!
     * jQuery Color Animations v2.2.0
     * https://github.com/jquery/jquery-color
     *
     * Copyright OpenJS Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * Date: Sun May 10 09:02:36 2020 +0200
     */

    var stepHooks =
            "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
            "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
        class2type = {},
        toString = class2type.toString,
        // plusequals test for += 100 -= 100
        rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
        // a set of RE's that can match strings and generate color tuples.
        stringParsers = [
            {
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2],
                        execResult[3],
                        execResult[4],
                    ];
                },
            },
            {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1] * 2.55,
                        execResult[2] * 2.55,
                        execResult[3] * 2.55,
                        execResult[4],
                    ];
                },
            },
            {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1], 16),
                        parseInt(execResult[2], 16),
                        parseInt(execResult[3], 16),
                        execResult[4]
                            ? (parseInt(execResult[4], 16) / 255).toFixed(2)
                            : 1,
                    ];
                },
            },
            {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1] + execResult[1], 16),
                        parseInt(execResult[2] + execResult[2], 16),
                        parseInt(execResult[3] + execResult[3], 16),
                        execResult[4]
                            ? (
                                  parseInt(execResult[4] + execResult[4], 16) /
                                  255
                              ).toFixed(2)
                            : 1,
                    ];
                },
            },
            {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2] / 100,
                        execResult[3] / 100,
                        execResult[4],
                    ];
                },
            },
        ],
        // jQuery.Color( )
        color = (jQuery.Color = function (color, green, blue, alpha) {
            return new jQuery.Color.fn.parse(color, green, blue, alpha);
        }),
        spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte",
                    },
                    green: {
                        idx: 1,
                        type: "byte",
                    },
                    blue: {
                        idx: 2,
                        type: "byte",
                    },
                },
            },

            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees",
                    },
                    saturation: {
                        idx: 1,
                        type: "percent",
                    },
                    lightness: {
                        idx: 2,
                        type: "percent",
                    },
                },
            },
        },
        propTypes = {
            byte: {
                floor: true,
                max: 255,
            },
            percent: {
                max: 1,
            },
            degrees: {
                mod: 360,
                floor: true,
            },
        },
        support = (color.support = {}),
        // element for support tests
        supportElem = jQuery("<p>")[0],
        // colors = jQuery.Color.names
        colors,
        // local aliases of functions called often
        each = jQuery.each;

    // determine rgba support immediately
    supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
    support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;

    // define cache name and alpha properties
    // for rgba and hsla spaces
    each(spaces, function (spaceName, space) {
        space.cache = "_" + spaceName;
        space.props.alpha = {
            idx: 3,
            type: "percent",
            def: 1,
        };
    });

    // Populate the class2type map
    jQuery.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(
            " "
        ),
        function (_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        }
    );

    function getType(obj) {
        if (obj == null) {
            return obj + "";
        }

        return typeof obj === "object"
            ? class2type[toString.call(obj)] || "object"
            : typeof obj;
    }

    function clamp(value, prop, allowEmpty) {
        var type = propTypes[prop.type] || {};

        if (value == null) {
            return allowEmpty || !prop.def ? null : prop.def;
        }

        // ~~ is an short way of doing floor for positive numbers
        value = type.floor ? ~~value : parseFloat(value);

        // IE will pass in empty strings as value for alpha,
        // which will hit this case
        if (isNaN(value)) {
            return prop.def;
        }

        if (type.mod) {
            // we add mod before modding to make sure that negatives values
            // get converted properly: -10 -> 350
            return (value + type.mod) % type.mod;
        }

        // for now all property types without mod have min and max
        return Math.min(type.max, Math.max(0, value));
    }

    function stringParse(string) {
        var inst = color(),
            rgba = (inst._rgba = []);

        string = string.toLowerCase();

        each(stringParsers, function (_i, parser) {
            var parsed,
                match = parser.re.exec(string),
                values = match && parser.parse(match),
                spaceName = parser.space || "rgba";

            if (values) {
                parsed = inst[spaceName](values);

                // if this was an rgba parse the assignment might happen twice
                // oh well....
                inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                rgba = inst._rgba = parsed._rgba;

                // exit each( stringParsers ) here because we matched
                return false;
            }
        });

        // Found a stringParser that handled it
        if (rgba.length) {
            // if this came from a parsed string, force "transparent" when alpha is 0
            // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
            if (rgba.join() === "0,0,0,0") {
                jQuery.extend(rgba, colors.transparent);
            }
            return inst;
        }

        // named colors
        return colors[string];
    }

    color.fn = jQuery.extend(color.prototype, {
        parse: function (red, green, blue, alpha) {
            if (red === undefined) {
                this._rgba = [null, null, null, null];
                return this;
            }
            if (red.jquery || red.nodeType) {
                red = jQuery(red).css(green);
                green = undefined;
            }

            var inst = this,
                type = getType(red),
                rgba = (this._rgba = []);

            // more than 1 argument specified - assume ( red, green, blue, alpha )
            if (green !== undefined) {
                red = [red, green, blue, alpha];
                type = "array";
            }

            if (type === "string") {
                return this.parse(stringParse(red) || colors._default);
            }

            if (type === "array") {
                each(spaces.rgba.props, function (_key, prop) {
                    rgba[prop.idx] = clamp(red[prop.idx], prop);
                });
                return this;
            }

            if (type === "object") {
                if (red instanceof color) {
                    each(spaces, function (_spaceName, space) {
                        if (red[space.cache]) {
                            inst[space.cache] = red[space.cache].slice();
                        }
                    });
                } else {
                    each(spaces, function (_spaceName, space) {
                        var cache = space.cache;
                        each(space.props, function (key, prop) {
                            // if the cache doesn't exist, and we know how to convert
                            if (!inst[cache] && space.to) {
                                // if the value was null, we don't need to copy it
                                // if the key was alpha, we don't need to copy it either
                                if (key === "alpha" || red[key] == null) {
                                    return;
                                }
                                inst[cache] = space.to(inst._rgba);
                            }

                            // this is the only case where we allow nulls for ALL properties.
                            // call clamp with alwaysAllowEmpty
                            inst[cache][prop.idx] = clamp(red[key], prop, true);
                        });

                        // everything defined but alpha?
                        if (
                            inst[cache] &&
                            jQuery.inArray(null, inst[cache].slice(0, 3)) < 0
                        ) {
                            // use the default of 1
                            if (inst[cache][3] == null) {
                                inst[cache][3] = 1;
                            }

                            if (space.from) {
                                inst._rgba = space.from(inst[cache]);
                            }
                        }
                    });
                }
                return this;
            }
        },
        is: function (compare) {
            var is = color(compare),
                same = true,
                inst = this;

            each(spaces, function (_, space) {
                var localCache,
                    isCache = is[space.cache];
                if (isCache) {
                    localCache =
                        inst[space.cache] ||
                        (space.to && space.to(inst._rgba)) ||
                        [];
                    each(space.props, function (_, prop) {
                        if (isCache[prop.idx] != null) {
                            same = isCache[prop.idx] === localCache[prop.idx];
                            return same;
                        }
                    });
                }
                return same;
            });
            return same;
        },
        _space: function () {
            var used = [],
                inst = this;
            each(spaces, function (spaceName, space) {
                if (inst[space.cache]) {
                    used.push(spaceName);
                }
            });
            return used.pop();
        },
        transition: function (other, distance) {
            var end = color(other),
                spaceName = end._space(),
                space = spaces[spaceName],
                startColor = this.alpha() === 0 ? color("transparent") : this,
                start = startColor[space.cache] || space.to(startColor._rgba),
                result = start.slice();

            end = end[space.cache];
            each(space.props, function (_key, prop) {
                var index = prop.idx,
                    startValue = start[index],
                    endValue = end[index],
                    type = propTypes[prop.type] || {};

                // if null, don't override start value
                if (endValue === null) {
                    return;
                }

                // if null - use end
                if (startValue === null) {
                    result[index] = endValue;
                } else {
                    if (type.mod) {
                        if (endValue - startValue > type.mod / 2) {
                            startValue += type.mod;
                        } else if (startValue - endValue > type.mod / 2) {
                            startValue -= type.mod;
                        }
                    }
                    result[index] = clamp(
                        (endValue - startValue) * distance + startValue,
                        prop
                    );
                }
            });
            return this[spaceName](result);
        },
        blend: function (opaque) {
            // if we are already opaque - return ourself
            if (this._rgba[3] === 1) {
                return this;
            }

            var rgb = this._rgba.slice(),
                a = rgb.pop(),
                blend = color(opaque)._rgba;

            return color(
                jQuery.map(rgb, function (v, i) {
                    return (1 - a) * blend[i] + a * v;
                })
            );
        },
        toRgbaString: function () {
            var prefix = "rgba(",
                rgba = jQuery.map(this._rgba, function (v, i) {
                    if (v != null) {
                        return v;
                    }
                    return i > 2 ? 1 : 0;
                });

            if (rgba[3] === 1) {
                rgba.pop();
                prefix = "rgb(";
            }

            return prefix + rgba.join() + ")";
        },
        toHslaString: function () {
            var prefix = "hsla(",
                hsla = jQuery.map(this.hsla(), function (v, i) {
                    if (v == null) {
                        v = i > 2 ? 1 : 0;
                    }

                    // catch 1 and 2
                    if (i && i < 3) {
                        v = Math.round(v * 100) + "%";
                    }
                    return v;
                });

            if (hsla[3] === 1) {
                hsla.pop();
                prefix = "hsl(";
            }
            return prefix + hsla.join() + ")";
        },
        toHexString: function (includeAlpha) {
            var rgba = this._rgba.slice(),
                alpha = rgba.pop();

            if (includeAlpha) {
                rgba.push(~~(alpha * 255));
            }

            return (
                "#" +
                jQuery
                    .map(rgba, function (v) {
                        // default to 0 when nulls exist
                        v = (v || 0).toString(16);
                        return v.length === 1 ? "0" + v : v;
                    })
                    .join("")
            );
        },
        toString: function () {
            return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
        },
    });
    color.fn.parse.prototype = color.fn;

    // hsla conversions adapted from:
    // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

    function hue2rgb(p, q, h) {
        h = (h + 1) % 1;
        if (h * 6 < 1) {
            return p + (q - p) * h * 6;
        }
        if (h * 2 < 1) {
            return q;
        }
        if (h * 3 < 2) {
            return p + (q - p) * (2 / 3 - h) * 6;
        }
        return p;
    }

    spaces.hsla.to = function (rgba) {
        if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
            return [null, null, null, rgba[3]];
        }
        var r = rgba[0] / 255,
            g = rgba[1] / 255,
            b = rgba[2] / 255,
            a = rgba[3],
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            diff = max - min,
            add = max + min,
            l = add * 0.5,
            h,
            s;

        if (min === max) {
            h = 0;
        } else if (r === max) {
            h = (60 * (g - b)) / diff + 360;
        } else if (g === max) {
            h = (60 * (b - r)) / diff + 120;
        } else {
            h = (60 * (r - g)) / diff + 240;
        }

        // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
        // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
        if (diff === 0) {
            s = 0;
        } else if (l <= 0.5) {
            s = diff / add;
        } else {
            s = diff / (2 - add);
        }
        return [Math.round(h) % 360, s, l, a == null ? 1 : a];
    };

    spaces.hsla.from = function (hsla) {
        if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
            return [null, null, null, hsla[3]];
        }
        var h = hsla[0] / 360,
            s = hsla[1],
            l = hsla[2],
            a = hsla[3],
            q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
            p = 2 * l - q;

        return [
            Math.round(hue2rgb(p, q, h + 1 / 3) * 255),
            Math.round(hue2rgb(p, q, h) * 255),
            Math.round(hue2rgb(p, q, h - 1 / 3) * 255),
            a,
        ];
    };

    each(spaces, function (spaceName, space) {
        var props = space.props,
            cache = space.cache,
            to = space.to,
            from = space.from;

        // makes rgba() and hsla()
        color.fn[spaceName] = function (value) {
            // generate a cache for this space if it doesn't exist
            if (to && !this[cache]) {
                this[cache] = to(this._rgba);
            }
            if (value === undefined) {
                return this[cache].slice();
            }

            var ret,
                type = getType(value),
                arr = type === "array" || type === "object" ? value : arguments,
                local = this[cache].slice();

            each(props, function (key, prop) {
                var val = arr[type === "object" ? key : prop.idx];
                if (val == null) {
                    val = local[prop.idx];
                }
                local[prop.idx] = clamp(val, prop);
            });

            if (from) {
                ret = color(from(local));
                ret[cache] = local;
                return ret;
            } else {
                return color(local);
            }
        };

        // makes red() green() blue() alpha() hue() saturation() lightness()
        each(props, function (key, prop) {
            // alpha is included in more than one space
            if (color.fn[key]) {
                return;
            }
            color.fn[key] = function (value) {
                var local,
                    cur,
                    match,
                    fn,
                    vtype = getType(value);

                if (key === "alpha") {
                    fn = this._hsla ? "hsla" : "rgba";
                } else {
                    fn = spaceName;
                }
                local = this[fn]();
                cur = local[prop.idx];

                if (vtype === "undefined") {
                    return cur;
                }

                if (vtype === "function") {
                    value = value.call(this, cur);
                    vtype = getType(value);
                }
                if (value == null && prop.empty) {
                    return this;
                }
                if (vtype === "string") {
                    match = rplusequals.exec(value);
                    if (match) {
                        value =
                            cur +
                            parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                    }
                }
                local[prop.idx] = value;
                return this[fn](local);
            };
        });
    });

    // add cssHook and .fx.step function for each named hook.
    // accept a space separated string of properties
    color.hook = function (hook) {
        var hooks = hook.split(" ");
        each(hooks, function (_i, hook) {
            jQuery.cssHooks[hook] = {
                set: function (elem, value) {
                    var parsed,
                        curElem,
                        backgroundColor = "";

                    if (
                        value !== "transparent" &&
                        (getType(value) !== "string" ||
                            (parsed = stringParse(value)))
                    ) {
                        value = color(parsed || value);
                        if (!support.rgba && value._rgba[3] !== 1) {
                            curElem =
                                hook === "backgroundColor"
                                    ? elem.parentNode
                                    : elem;
                            while (
                                (backgroundColor === "" ||
                                    backgroundColor === "transparent") &&
                                curElem &&
                                curElem.style
                            ) {
                                try {
                                    backgroundColor = jQuery.css(
                                        curElem,
                                        "backgroundColor"
                                    );
                                    curElem = curElem.parentNode;
                                } catch (e) {}
                            }

                            value = value.blend(
                                backgroundColor &&
                                    backgroundColor !== "transparent"
                                    ? backgroundColor
                                    : "_default"
                            );
                        }

                        value = value.toRgbaString();
                    }
                    try {
                        elem.style[hook] = value;
                    } catch (e) {
                        // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                    }
                },
            };
            jQuery.fx.step[hook] = function (fx) {
                if (!fx.colorInit) {
                    fx.start = color(fx.elem, hook);
                    fx.end = color(fx.end);
                    fx.colorInit = true;
                }
                jQuery.cssHooks[hook].set(
                    fx.elem,
                    fx.start.transition(fx.end, fx.pos)
                );
            };
        });
    };

    color.hook(stepHooks);

    jQuery.cssHooks.borderColor = {
        expand: function (value) {
            var expanded = {};

            each(["Top", "Right", "Bottom", "Left"], function (_i, part) {
                expanded["border" + part + "Color"] = value;
            });
            return expanded;
        },
    };

    // Basic color names only.
    // Usage of any of the other color names requires adding yourself or including
    // jquery.color.svg-names.js.
    colors = jQuery.Color.names = {
        // 4.1. Basic color keywords
        aqua: "#00ffff",
        black: "#000000",
        blue: "#0000ff",
        fuchsia: "#ff00ff",
        gray: "#808080",
        green: "#008000",
        lime: "#00ff00",
        maroon: "#800000",
        navy: "#000080",
        olive: "#808000",
        purple: "#800080",
        red: "#ff0000",
        silver: "#c0c0c0",
        teal: "#008080",
        white: "#ffffff",
        yellow: "#ffff00",

        // 4.2.3. "transparent" color keyword
        transparent: [null, null, null, 0],

        _default: "#ffffff",
    };

    /*!
     * jQuery UI Effects 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Effects Core
    //>>group: Effects
    /* eslint-disable max-len */
    //>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
    /* eslint-enable max-len */
    //>>docs: http://api.jqueryui.com/category/effects-core/
    //>>demos: http://jqueryui.com/effect/

    var dataSpace = "ui-effects-",
        dataSpaceStyle = "ui-effects-style",
        dataSpaceAnimated = "ui-effects-animated";

    $.effects = {
        effect: {},
    };

    /******************************************************************************/
    /****************************** CLASS ANIMATIONS ******************************/
    /******************************************************************************/
    (function () {
        var classAnimationActions = ["add", "remove", "toggle"],
            shorthandStyles = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1,
            };

        $.each(
            [
                "borderLeftStyle",
                "borderRightStyle",
                "borderBottomStyle",
                "borderTopStyle",
            ],
            function (_, prop) {
                $.fx.step[prop] = function (fx) {
                    if (
                        (fx.end !== "none" && !fx.setAttr) ||
                        (fx.pos === 1 && !fx.setAttr)
                    ) {
                        jQuery.style(fx.elem, prop, fx.end);
                        fx.setAttr = true;
                    }
                };
            }
        );

        function camelCase(string) {
            return string.replace(/-([\da-z])/gi, function (all, letter) {
                return letter.toUpperCase();
            });
        }

        function getElementStyles(elem) {
            var key,
                len,
                style = elem.ownerDocument.defaultView
                    ? elem.ownerDocument.defaultView.getComputedStyle(
                          elem,
                          null
                      )
                    : elem.currentStyle,
                styles = {};

            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[camelCase(key)] = style[key];
                    }
                }

                // Support: Opera, IE <9
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }

            return styles;
        }

        function styleDifference(oldStyle, newStyle) {
            var diff = {},
                name,
                value;

            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }

            return diff;
        }

        // Support: jQuery <1.8
        if (!$.fn.addBack) {
            $.fn.addBack = function (selector) {
                return this.add(
                    selector == null
                        ? this.prevObject
                        : this.prevObject.filter(selector)
                );
            };
        }

        $.effects.animateClass = function (value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);

            return this.queue(function () {
                var animated = $(this),
                    baseClass = animated.attr("class") || "",
                    applyClassChange,
                    allAnimations = o.children
                        ? animated.find("*").addBack()
                        : animated;

                // Map the animated objects to store the original styles.
                allAnimations = allAnimations.map(function () {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this),
                    };
                });

                // Apply class change
                applyClassChange = function () {
                    $.each(classAnimationActions, function (i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();

                // Map all animated objects again - calculate new styles and diff
                allAnimations = allAnimations.map(function () {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });

                // Apply original class
                animated.attr("class", baseClass);

                // Map all animated objects again - this time collecting a promise
                allAnimations = allAnimations.map(function () {
                    var styleInfo = this,
                        dfd = $.Deferred(),
                        opts = $.extend({}, o, {
                            queue: false,
                            complete: function () {
                                dfd.resolve(styleInfo);
                            },
                        });

                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });

                // Once all animations have completed:
                $.when.apply($, allAnimations.get()).done(function () {
                    // Set the final class
                    applyClassChange();

                    // For each animated element,
                    // clear all css properties that were animated
                    $.each(arguments, function () {
                        var el = this.el;
                        $.each(this.diff, function (key) {
                            el.css(key, "");
                        });
                    });

                    // This is guarnteed to be there if you use jQuery.speed()
                    // it also handles dequeuing the next anim...
                    o.complete.call(animated[0]);
                });
            });
        };

        $.fn.extend({
            addClass: (function (orig) {
                return function (classNames, speed, easing, callback) {
                    return speed
                        ? $.effects.animateClass.call(
                              this,
                              { add: classNames },
                              speed,
                              easing,
                              callback
                          )
                        : orig.apply(this, arguments);
                };
            })($.fn.addClass),

            removeClass: (function (orig) {
                return function (classNames, speed, easing, callback) {
                    return arguments.length > 1
                        ? $.effects.animateClass.call(
                              this,
                              { remove: classNames },
                              speed,
                              easing,
                              callback
                          )
                        : orig.apply(this, arguments);
                };
            })($.fn.removeClass),

            toggleClass: (function (orig) {
                return function (classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {
                            // Without speed parameter
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(
                                this,
                                force
                                    ? { add: classNames }
                                    : { remove: classNames },
                                speed,
                                easing,
                                callback
                            );
                        }
                    } else {
                        // Without force parameter
                        return $.effects.animateClass.call(
                            this,
                            { toggle: classNames },
                            force,
                            speed,
                            easing
                        );
                    }
                };
            })($.fn.toggleClass),

            switchClass: function (remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(
                    this,
                    {
                        add: add,
                        remove: remove,
                    },
                    speed,
                    easing,
                    callback
                );
            },
        });
    })();

    /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/

    (function () {
        if ($.expr && $.expr.pseudos && $.expr.pseudos.animated) {
            $.expr.pseudos.animated = (function (orig) {
                return function (elem) {
                    return !!$(elem).data(dataSpaceAnimated) || orig(elem);
                };
            })($.expr.pseudos.animated);
        }

        if ($.uiBackCompat !== false) {
            $.extend($.effects, {
                // Saves a set of properties in a data storage
                save: function (element, set) {
                    var i = 0,
                        length = set.length;
                    for (; i < length; i++) {
                        if (set[i] !== null) {
                            element.data(
                                dataSpace + set[i],
                                element[0].style[set[i]]
                            );
                        }
                    }
                },

                // Restores a set of previously saved properties from a data storage
                restore: function (element, set) {
                    var val,
                        i = 0,
                        length = set.length;
                    for (; i < length; i++) {
                        if (set[i] !== null) {
                            val = element.data(dataSpace + set[i]);
                            element.css(set[i], val);
                        }
                    }
                },

                setMode: function (el, mode) {
                    if (mode === "toggle") {
                        mode = el.is(":hidden") ? "show" : "hide";
                    }
                    return mode;
                },

                // Wraps the element around a wrapper that copies position properties
                createWrapper: function (element) {
                    // If the element is already wrapped, return it
                    if (element.parent().is(".ui-effects-wrapper")) {
                        return element.parent();
                    }

                    // Wrap the element
                    var props = {
                            width: element.outerWidth(true),
                            height: element.outerHeight(true),
                            float: element.css("float"),
                        },
                        wrapper = $("<div></div>")
                            .addClass("ui-effects-wrapper")
                            .css({
                                fontSize: "100%",
                                background: "transparent",
                                border: "none",
                                margin: 0,
                                padding: 0,
                            }),
                        // Store the size in case width/height are defined in % - Fixes #5245
                        size = {
                            width: element.width(),
                            height: element.height(),
                        },
                        active = document.activeElement;

                    // Support: Firefox
                    // Firefox incorrectly exposes anonymous content
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                    try {
                        // eslint-disable-next-line no-unused-expressions
                        active.id;
                    } catch (e) {
                        active = document.body;
                    }

                    element.wrap(wrapper);

                    // Fixes #7595 - Elements lose focus when wrapped.
                    if (
                        element[0] === active ||
                        $.contains(element[0], active)
                    ) {
                        $(active).trigger("focus");
                    }

                    // Hotfix for jQuery 1.4 since some change in wrap() seems to actually
                    // lose the reference to the wrapped element
                    wrapper = element.parent();

                    // Transfer positioning properties to the wrapper
                    if (element.css("position") === "static") {
                        wrapper.css({ position: "relative" });
                        element.css({ position: "relative" });
                    } else {
                        $.extend(props, {
                            position: element.css("position"),
                            zIndex: element.css("z-index"),
                        });
                        $.each(
                            ["top", "left", "bottom", "right"],
                            function (i, pos) {
                                props[pos] = element.css(pos);
                                if (isNaN(parseInt(props[pos], 10))) {
                                    props[pos] = "auto";
                                }
                            }
                        );
                        element.css({
                            position: "relative",
                            top: 0,
                            left: 0,
                            right: "auto",
                            bottom: "auto",
                        });
                    }
                    element.css(size);

                    return wrapper.css(props).show();
                },

                removeWrapper: function (element) {
                    var active = document.activeElement;

                    if (element.parent().is(".ui-effects-wrapper")) {
                        element.parent().replaceWith(element);

                        // Fixes #7595 - Elements lose focus when wrapped.
                        if (
                            element[0] === active ||
                            $.contains(element[0], active)
                        ) {
                            $(active).trigger("focus");
                        }
                    }

                    return element;
                },
            });
        }

        $.extend($.effects, {
            version: "1.13.2",

            define: function (name, mode, effect) {
                if (!effect) {
                    effect = mode;
                    mode = "effect";
                }

                $.effects.effect[name] = effect;
                $.effects.effect[name].mode = mode;

                return effect;
            },

            scaledDimensions: function (element, percent, direction) {
                if (percent === 0) {
                    return {
                        height: 0,
                        width: 0,
                        outerHeight: 0,
                        outerWidth: 0,
                    };
                }

                var x = direction !== "horizontal" ? (percent || 100) / 100 : 1,
                    y = direction !== "vertical" ? (percent || 100) / 100 : 1;

                return {
                    height: element.height() * y,
                    width: element.width() * x,
                    outerHeight: element.outerHeight() * y,
                    outerWidth: element.outerWidth() * x,
                };
            },

            clipToBox: function (animation) {
                return {
                    width: animation.clip.right - animation.clip.left,
                    height: animation.clip.bottom - animation.clip.top,
                    left: animation.clip.left,
                    top: animation.clip.top,
                };
            },

            // Injects recently queued functions to be first in line (after "inprogress")
            unshift: function (element, queueLength, count) {
                var queue = element.queue();

                if (queueLength > 1) {
                    queue.splice.apply(
                        queue,
                        [1, 0].concat(queue.splice(queueLength, count))
                    );
                }
                element.dequeue();
            },

            saveStyle: function (element) {
                element.data(dataSpaceStyle, element[0].style.cssText);
            },

            restoreStyle: function (element) {
                element[0].style.cssText = element.data(dataSpaceStyle) || "";
                element.removeData(dataSpaceStyle);
            },

            mode: function (element, mode) {
                var hidden = element.is(":hidden");

                if (mode === "toggle") {
                    mode = hidden ? "show" : "hide";
                }
                if (hidden ? mode === "hide" : mode === "show") {
                    mode = "none";
                }
                return mode;
            },

            // Translates a [top,left] array into a baseline value
            getBaseline: function (origin, original) {
                var y, x;

                switch (origin[0]) {
                    case "top":
                        y = 0;
                        break;
                    case "middle":
                        y = 0.5;
                        break;
                    case "bottom":
                        y = 1;
                        break;
                    default:
                        y = origin[0] / original.height;
                }

                switch (origin[1]) {
                    case "left":
                        x = 0;
                        break;
                    case "center":
                        x = 0.5;
                        break;
                    case "right":
                        x = 1;
                        break;
                    default:
                        x = origin[1] / original.width;
                }

                return {
                    x: x,
                    y: y,
                };
            },

            // Creates a placeholder element so that the original element can be made absolute
            createPlaceholder: function (element) {
                var placeholder,
                    cssPosition = element.css("position"),
                    position = element.position();

                // Lock in margins first to account for form elements, which
                // will change margin if you explicitly set height
                // see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
                // Support: Safari
                element
                    .css({
                        marginTop: element.css("marginTop"),
                        marginBottom: element.css("marginBottom"),
                        marginLeft: element.css("marginLeft"),
                        marginRight: element.css("marginRight"),
                    })
                    .outerWidth(element.outerWidth())
                    .outerHeight(element.outerHeight());

                if (/^(static|relative)/.test(cssPosition)) {
                    cssPosition = "absolute";

                    placeholder = $("<" + element[0].nodeName + ">")
                        .insertAfter(element)
                        .css({
                            // Convert inline to inline block to account for inline elements
                            // that turn to inline block based on content (like img)
                            display: /^(inline|ruby)/.test(
                                element.css("display")
                            )
                                ? "inline-block"
                                : "block",
                            visibility: "hidden",

                            // Margins need to be set to account for margin collapse
                            marginTop: element.css("marginTop"),
                            marginBottom: element.css("marginBottom"),
                            marginLeft: element.css("marginLeft"),
                            marginRight: element.css("marginRight"),
                            float: element.css("float"),
                        })
                        .outerWidth(element.outerWidth())
                        .outerHeight(element.outerHeight())
                        .addClass("ui-effects-placeholder");

                    element.data(dataSpace + "placeholder", placeholder);
                }

                element.css({
                    position: cssPosition,
                    left: position.left,
                    top: position.top,
                });

                return placeholder;
            },

            removePlaceholder: function (element) {
                var dataKey = dataSpace + "placeholder",
                    placeholder = element.data(dataKey);

                if (placeholder) {
                    placeholder.remove();
                    element.removeData(dataKey);
                }
            },

            // Removes a placeholder if it exists and restores
            // properties that were modified during placeholder creation
            cleanUp: function (element) {
                $.effects.restoreStyle(element);
                $.effects.removePlaceholder(element);
            },

            setTransition: function (element, list, factor, value) {
                value = value || {};
                $.each(list, function (i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            },
        });

        // Return an effect options object for the given parameters:
        function _normalizeArguments(effect, options, speed, callback) {
            // Allow passing all options as the first parameter
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }

            // Convert to an object
            effect = { effect: effect };

            // Catch (effect, null, ...)
            if (options == null) {
                options = {};
            }

            // Catch (effect, callback)
            if (typeof options === "function") {
                callback = options;
                speed = null;
                options = {};
            }

            // Catch (effect, speed, ?)
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }

            // Catch (effect, options, callback)
            if (typeof speed === "function") {
                callback = speed;
                speed = null;
            }

            // Add options to effect
            if (options) {
                $.extend(effect, options);
            }

            speed = speed || options.duration;
            effect.duration = $.fx.off
                ? 0
                : typeof speed === "number"
                ? speed
                : speed in $.fx.speeds
                ? $.fx.speeds[speed]
                : $.fx.speeds._default;

            effect.complete = callback || options.complete;

            return effect;
        }

        function standardAnimationOption(option) {
            // Valid standard speeds (nothing, number, named speed)
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }

            // Invalid strings - treat as "normal" speed
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }

            // Complete callback
            if (typeof option === "function") {
                return true;
            }

            // Options hash (but not naming an effect)
            if (typeof option === "object" && !option.effect) {
                return true;
            }

            // Didn't match any standard API
            return false;
        }

        $.fn.extend({
            effect: function (/* effect, options, speed, callback */) {
                var args = _normalizeArguments.apply(this, arguments),
                    effectMethod = $.effects.effect[args.effect],
                    defaultMode = effectMethod.mode,
                    queue = args.queue,
                    queueName = queue || "fx",
                    complete = args.complete,
                    mode = args.mode,
                    modes = [],
                    prefilter = function (next) {
                        var el = $(this),
                            normalizedMode =
                                $.effects.mode(el, mode) || defaultMode;

                        // Sentinel for duck-punching the :animated pseudo-selector
                        el.data(dataSpaceAnimated, true);

                        // Save effect mode for later use,
                        // we can't just call $.effects.mode again later,
                        // as the .show() below destroys the initial state
                        modes.push(normalizedMode);

                        // See $.uiBackCompat inside of run() for removal of defaultMode in 1.14
                        if (
                            defaultMode &&
                            (normalizedMode === "show" ||
                                (normalizedMode === defaultMode &&
                                    normalizedMode === "hide"))
                        ) {
                            el.show();
                        }

                        if (!defaultMode || normalizedMode !== "none") {
                            $.effects.saveStyle(el);
                        }

                        if (typeof next === "function") {
                            next();
                        }
                    };

                if ($.fx.off || !effectMethod) {
                    // Delegate to the original method (e.g., .show()) if possible
                    if (mode) {
                        return this[mode](args.duration, complete);
                    } else {
                        return this.each(function () {
                            if (complete) {
                                complete.call(this);
                            }
                        });
                    }
                }

                function run(next) {
                    var elem = $(this);

                    function cleanup() {
                        elem.removeData(dataSpaceAnimated);

                        $.effects.cleanUp(elem);

                        if (args.mode === "hide") {
                            elem.hide();
                        }

                        done();
                    }

                    function done() {
                        if (typeof complete === "function") {
                            complete.call(elem[0]);
                        }

                        if (typeof next === "function") {
                            next();
                        }
                    }

                    // Override mode option on a per element basis,
                    // as toggle can be either show or hide depending on element state
                    args.mode = modes.shift();

                    if ($.uiBackCompat !== false && !defaultMode) {
                        if (
                            elem.is(":hidden")
                                ? mode === "hide"
                                : mode === "show"
                        ) {
                            // Call the core method to track "olddisplay" properly
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, done);
                        }
                    } else {
                        if (args.mode === "none") {
                            // Call the core method to track "olddisplay" properly
                            elem[mode]();
                            done();
                        } else {
                            effectMethod.call(elem[0], args, cleanup);
                        }
                    }
                }

                // Run prefilter on all elements first to ensure that
                // any showing or hiding happens before placeholder creation,
                // which ensures that any layout changes are correctly captured.
                return queue === false
                    ? this.each(prefilter).each(run)
                    : this.queue(queueName, prefilter).queue(queueName, run);
            },

            show: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.show),

            hide: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.hide),

            toggle: (function (orig) {
                return function (option) {
                    if (
                        standardAnimationOption(option) ||
                        typeof option === "boolean"
                    ) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.toggle),

            cssUnit: function (key) {
                var style = this.css(key),
                    val = [];

                $.each(["em", "px", "%", "pt"], function (i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [parseFloat(style), unit];
                    }
                });
                return val;
            },

            cssClip: function (clipObj) {
                if (clipObj) {
                    return this.css(
                        "clip",
                        "rect(" +
                            clipObj.top +
                            "px " +
                            clipObj.right +
                            "px " +
                            clipObj.bottom +
                            "px " +
                            clipObj.left +
                            "px)"
                    );
                }
                return parseClip(this.css("clip"), this);
            },

            transfer: function (options, done) {
                var element = $(this),
                    target = $(options.to),
                    targetFixed = target.css("position") === "fixed",
                    body = $("body"),
                    fixTop = targetFixed ? body.scrollTop() : 0,
                    fixLeft = targetFixed ? body.scrollLeft() : 0,
                    endPosition = target.offset(),
                    animation = {
                        top: endPosition.top - fixTop,
                        left: endPosition.left - fixLeft,
                        height: target.innerHeight(),
                        width: target.innerWidth(),
                    },
                    startPosition = element.offset(),
                    transfer = $("<div class='ui-effects-transfer'></div>");

                transfer
                    .appendTo("body")
                    .addClass(options.className)
                    .css({
                        top: startPosition.top - fixTop,
                        left: startPosition.left - fixLeft,
                        height: element.innerHeight(),
                        width: element.innerWidth(),
                        position: targetFixed ? "fixed" : "absolute",
                    })
                    .animate(
                        animation,
                        options.duration,
                        options.easing,
                        function () {
                            transfer.remove();
                            if (typeof done === "function") {
                                done();
                            }
                        }
                    );
            },
        });

        function parseClip(str, element) {
            var outerWidth = element.outerWidth(),
                outerHeight = element.outerHeight(),
                clipRegex =
                    /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
                values = clipRegex.exec(str) || [
                    "",
                    0,
                    outerWidth,
                    outerHeight,
                    0,
                ];

            return {
                top: parseFloat(values[1]) || 0,
                right:
                    values[2] === "auto" ? outerWidth : parseFloat(values[2]),
                bottom:
                    values[3] === "auto" ? outerHeight : parseFloat(values[3]),
                left: parseFloat(values[4]) || 0,
            };
        }

        $.fx.step.clip = function (fx) {
            if (!fx.clipInit) {
                fx.start = $(fx.elem).cssClip();
                if (typeof fx.end === "string") {
                    fx.end = parseClip(fx.end, fx.elem);
                }
                fx.clipInit = true;
            }

            $(fx.elem).cssClip({
                top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,
                right:
                    fx.pos * (fx.end.right - fx.start.right) + fx.start.right,
                bottom:
                    fx.pos * (fx.end.bottom - fx.start.bottom) +
                    fx.start.bottom,
                left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left,
            });
        };
    })();

    /******************************************************************************/
    /*********************************** EASING ***********************************/
    /******************************************************************************/

    (function () {
        // Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

        var baseEasings = {};

        $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (i, name) {
            baseEasings[name] = function (p) {
                return Math.pow(p, i + 2);
            };
        });

        $.extend(baseEasings, {
            Sine: function (p) {
                return 1 - Math.cos((p * Math.PI) / 2);
            },
            Circ: function (p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function (p) {
                return p === 0 || p === 1
                    ? p
                    : -Math.pow(2, 8 * (p - 1)) *
                          Math.sin((((p - 1) * 80 - 7.5) * Math.PI) / 15);
            },
            Back: function (p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function (p) {
                var pow2,
                    bounce = 4;

                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                return (
                    1 / Math.pow(4, 3 - bounce) -
                    7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2)
                );
            },
        });

        $.each(baseEasings, function (name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function (p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function (p) {
                return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
            };
        });
    })();

    var effect = $.effects;

    /*!
     * jQuery UI Effects Blind 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Blind Effect
    //>>group: Effects
    //>>description: Blinds the element.
    //>>docs: http://api.jqueryui.com/blind-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectBlind = $.effects.define(
        "blind",
        "hide",
        function (options, done) {
            var map = {
                    up: ["bottom", "top"],
                    vertical: ["bottom", "top"],
                    down: ["top", "bottom"],
                    left: ["right", "left"],
                    horizontal: ["right", "left"],
                    right: ["left", "right"],
                },
                element = $(this),
                direction = options.direction || "up",
                start = element.cssClip(),
                animate = { clip: $.extend({}, start) },
                placeholder = $.effects.createPlaceholder(element);

            animate.clip[map[direction][0]] = animate.clip[map[direction][1]];

            if (options.mode === "show") {
                element.cssClip(animate.clip);
                if (placeholder) {
                    placeholder.css($.effects.clipToBox(animate));
                }

                animate.clip = start;
            }

            if (placeholder) {
                placeholder.animate(
                    $.effects.clipToBox(animate),
                    options.duration,
                    options.easing
                );
            }

            element.animate(animate, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done,
            });
        }
    );

    /*!
     * jQuery UI Effects Bounce 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Bounce Effect
    //>>group: Effects
    //>>description: Bounces an element horizontally or vertically n times.
    //>>docs: http://api.jqueryui.com/bounce-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectBounce = $.effects.define(
        "bounce",
        function (options, done) {
            var upAnim,
                downAnim,
                refValue,
                element = $(this),
                // Defaults:
                mode = options.mode,
                hide = mode === "hide",
                show = mode === "show",
                direction = options.direction || "up",
                distance = options.distance,
                times = options.times || 5,
                // Number of internal animations
                anims = times * 2 + (show || hide ? 1 : 0),
                speed = options.duration / anims,
                easing = options.easing,
                // Utility:
                ref =
                    direction === "up" || direction === "down" ? "top" : "left",
                motion = direction === "up" || direction === "left",
                i = 0,
                queuelen = element.queue().length;

            $.effects.createPlaceholder(element);

            refValue = element.css(ref);

            // Default distance for the BIGGEST bounce is the outer Distance / 3
            if (!distance) {
                distance =
                    element[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
            }

            if (show) {
                downAnim = { opacity: 1 };
                downAnim[ref] = refValue;

                // If we are showing, force opacity 0 and set the initial position
                // then do the "first" animation
                element
                    .css("opacity", 0)
                    .css(ref, motion ? -distance * 2 : distance * 2)
                    .animate(downAnim, speed, easing);
            }

            // Start at the smallest distance if we are hiding
            if (hide) {
                distance = distance / Math.pow(2, times - 1);
            }

            downAnim = {};
            downAnim[ref] = refValue;

            // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
            for (; i < times; i++) {
                upAnim = {};
                upAnim[ref] = (motion ? "-=" : "+=") + distance;

                element
                    .animate(upAnim, speed, easing)
                    .animate(downAnim, speed, easing);

                distance = hide ? distance * 2 : distance / 2;
            }

            // Last Bounce when Hiding
            if (hide) {
                upAnim = { opacity: 0 };
                upAnim[ref] = (motion ? "-=" : "+=") + distance;

                element.animate(upAnim, speed, easing);
            }

            element.queue(done);

            $.effects.unshift(element, queuelen, anims + 1);
        }
    );

    /*!
     * jQuery UI Effects Clip 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Clip Effect
    //>>group: Effects
    //>>description: Clips the element on and off like an old TV.
    //>>docs: http://api.jqueryui.com/clip-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectClip = $.effects.define(
        "clip",
        "hide",
        function (options, done) {
            var start,
                animate = {},
                element = $(this),
                direction = options.direction || "vertical",
                both = direction === "both",
                horizontal = both || direction === "horizontal",
                vertical = both || direction === "vertical";

            start = element.cssClip();
            animate.clip = {
                top: vertical ? (start.bottom - start.top) / 2 : start.top,
                right: horizontal
                    ? (start.right - start.left) / 2
                    : start.right,
                bottom: vertical
                    ? (start.bottom - start.top) / 2
                    : start.bottom,
                left: horizontal ? (start.right - start.left) / 2 : start.left,
            };

            $.effects.createPlaceholder(element);

            if (options.mode === "show") {
                element.cssClip(animate.clip);
                animate.clip = start;
            }

            element.animate(animate, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done,
            });
        }
    );

    /*!
     * jQuery UI Effects Drop 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Drop Effect
    //>>group: Effects
    //>>description: Moves an element in one direction and hides it at the same time.
    //>>docs: http://api.jqueryui.com/drop-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectDrop = $.effects.define(
        "drop",
        "hide",
        function (options, done) {
            var distance,
                element = $(this),
                mode = options.mode,
                show = mode === "show",
                direction = options.direction || "left",
                ref =
                    direction === "up" || direction === "down" ? "top" : "left",
                motion =
                    direction === "up" || direction === "left" ? "-=" : "+=",
                oppositeMotion = motion === "+=" ? "-=" : "+=",
                animation = {
                    opacity: 0,
                };

            $.effects.createPlaceholder(element);

            distance =
                options.distance ||
                element[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;

            animation[ref] = motion + distance;

            if (show) {
                element.css(animation);

                animation[ref] = oppositeMotion + distance;
                animation.opacity = 1;
            }

            // Animate
            element.animate(animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done,
            });
        }
    );

    /*!
     * jQuery UI Effects Explode 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Explode Effect
    //>>group: Effects
    /* eslint-disable max-len */
    //>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
    /* eslint-enable max-len */
    //>>docs: http://api.jqueryui.com/explode-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectExplode = $.effects.define(
        "explode",
        "hide",
        function (options, done) {
            var i,
                j,
                left,
                top,
                mx,
                my,
                rows = options.pieces
                    ? Math.round(Math.sqrt(options.pieces))
                    : 3,
                cells = rows,
                element = $(this),
                mode = options.mode,
                show = mode === "show",
                // Show and then visibility:hidden the element before calculating offset
                offset = element.show().css("visibility", "hidden").offset(),
                // Width and height of a piece
                width = Math.ceil(element.outerWidth() / cells),
                height = Math.ceil(element.outerHeight() / rows),
                pieces = [];

            // Children animate complete:
            function childComplete() {
                pieces.push(this);
                if (pieces.length === rows * cells) {
                    animComplete();
                }
            }

            // Clone the element for each row and cell.
            for (i = 0; i < rows; i++) {
                // ===>
                top = offset.top + i * height;
                my = i - (rows - 1) / 2;

                for (j = 0; j < cells; j++) {
                    // |||
                    left = offset.left + j * width;
                    mx = j - (cells - 1) / 2;

                    // Create a clone of the now hidden main element that will be absolute positioned
                    // within a wrapper div off the -left and -top equal to size of our pieces
                    element
                        .clone()
                        .appendTo("body")
                        .wrap("<div></div>")
                        .css({
                            position: "absolute",
                            visibility: "visible",
                            left: -j * width,
                            top: -i * height,
                        })

                        // Select the wrapper - make it overflow: hidden and absolute positioned based on
                        // where the original was located +left and +top equal to the size of pieces
                        .parent()
                        .addClass("ui-effects-explode")
                        .css({
                            position: "absolute",
                            overflow: "hidden",
                            width: width,
                            height: height,
                            left: left + (show ? mx * width : 0),
                            top: top + (show ? my * height : 0),
                            opacity: show ? 0 : 1,
                        })
                        .animate(
                            {
                                left: left + (show ? 0 : mx * width),
                                top: top + (show ? 0 : my * height),
                                opacity: show ? 1 : 0,
                            },
                            options.duration || 500,
                            options.easing,
                            childComplete
                        );
                }
            }

            function animComplete() {
                element.css({
                    visibility: "visible",
                });
                $(pieces).remove();
                done();
            }
        }
    );

    /*!
     * jQuery UI Effects Fade 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Fade Effect
    //>>group: Effects
    //>>description: Fades the element.
    //>>docs: http://api.jqueryui.com/fade-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectFade = $.effects.define(
        "fade",
        "toggle",
        function (options, done) {
            var show = options.mode === "show";

            $(this)
                .css("opacity", show ? 0 : 1)
                .animate(
                    {
                        opacity: show ? 1 : 0,
                    },
                    {
                        queue: false,
                        duration: options.duration,
                        easing: options.easing,
                        complete: done,
                    }
                );
        }
    );

    /*!
     * jQuery UI Effects Fold 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Fold Effect
    //>>group: Effects
    //>>description: Folds an element first horizontally and then vertically.
    //>>docs: http://api.jqueryui.com/fold-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectFold = $.effects.define(
        "fold",
        "hide",
        function (options, done) {
            // Create element
            var element = $(this),
                mode = options.mode,
                show = mode === "show",
                hide = mode === "hide",
                size = options.size || 15,
                percent = /([0-9]+)%/.exec(size),
                horizFirst = !!options.horizFirst,
                ref = horizFirst ? ["right", "bottom"] : ["bottom", "right"],
                duration = options.duration / 2,
                placeholder = $.effects.createPlaceholder(element),
                start = element.cssClip(),
                animation1 = { clip: $.extend({}, start) },
                animation2 = { clip: $.extend({}, start) },
                distance = [start[ref[0]], start[ref[1]]],
                queuelen = element.queue().length;

            if (percent) {
                size =
                    (parseInt(percent[1], 10) / 100) * distance[hide ? 0 : 1];
            }
            animation1.clip[ref[0]] = size;
            animation2.clip[ref[0]] = size;
            animation2.clip[ref[1]] = 0;

            if (show) {
                element.cssClip(animation2.clip);
                if (placeholder) {
                    placeholder.css($.effects.clipToBox(animation2));
                }

                animation2.clip = start;
            }

            // Animate
            element
                .queue(function (next) {
                    if (placeholder) {
                        placeholder
                            .animate(
                                $.effects.clipToBox(animation1),
                                duration,
                                options.easing
                            )
                            .animate(
                                $.effects.clipToBox(animation2),
                                duration,
                                options.easing
                            );
                    }

                    next();
                })
                .animate(animation1, duration, options.easing)
                .animate(animation2, duration, options.easing)
                .queue(done);

            $.effects.unshift(element, queuelen, 4);
        }
    );

    /*!
     * jQuery UI Effects Highlight 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Highlight Effect
    //>>group: Effects
    //>>description: Highlights the background of an element in a defined color for a custom duration.
    //>>docs: http://api.jqueryui.com/highlight-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectHighlight = $.effects.define(
        "highlight",
        "show",
        function (options, done) {
            var element = $(this),
                animation = {
                    backgroundColor: element.css("backgroundColor"),
                };

            if (options.mode === "hide") {
                animation.opacity = 0;
            }

            $.effects.saveStyle(element);

            element
                .css({
                    backgroundImage: "none",
                    backgroundColor: options.color || "#ffff99",
                })
                .animate(animation, {
                    queue: false,
                    duration: options.duration,
                    easing: options.easing,
                    complete: done,
                });
        }
    );

    /*!
     * jQuery UI Effects Size 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Size Effect
    //>>group: Effects
    //>>description: Resize an element to a specified width and height.
    //>>docs: http://api.jqueryui.com/size-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectSize = $.effects.define("size", function (options, done) {
        // Create element
        var baseline,
            factor,
            temp,
            element = $(this),
            // Copy for children
            cProps = ["fontSize"],
            vProps = [
                "borderTopWidth",
                "borderBottomWidth",
                "paddingTop",
                "paddingBottom",
            ],
            hProps = [
                "borderLeftWidth",
                "borderRightWidth",
                "paddingLeft",
                "paddingRight",
            ],
            // Set options
            mode = options.mode,
            restore = mode !== "effect",
            scale = options.scale || "both",
            origin = options.origin || ["middle", "center"],
            position = element.css("position"),
            pos = element.position(),
            original = $.effects.scaledDimensions(element),
            from = options.from || original,
            to = options.to || $.effects.scaledDimensions(element, 0);

        $.effects.createPlaceholder(element);

        if (mode === "show") {
            temp = from;
            from = to;
            to = temp;
        }

        // Set scaling factor
        factor = {
            from: {
                y: from.height / original.height,
                x: from.width / original.width,
            },
            to: {
                y: to.height / original.height,
                x: to.width / original.width,
            },
        };

        // Scale the css box
        if (scale === "box" || scale === "both") {
            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                from = $.effects.setTransition(
                    element,
                    vProps,
                    factor.from.y,
                    from
                );
                to = $.effects.setTransition(element, vProps, factor.to.y, to);
            }

            // Horizontal props scaling
            if (factor.from.x !== factor.to.x) {
                from = $.effects.setTransition(
                    element,
                    hProps,
                    factor.from.x,
                    from
                );
                to = $.effects.setTransition(element, hProps, factor.to.x, to);
            }
        }

        // Scale the content
        if (scale === "content" || scale === "both") {
            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                from = $.effects.setTransition(
                    element,
                    cProps,
                    factor.from.y,
                    from
                );
                to = $.effects.setTransition(element, cProps, factor.to.y, to);
            }
        }

        // Adjust the position properties based on the provided origin points
        if (origin) {
            baseline = $.effects.getBaseline(origin, original);
            from.top =
                (original.outerHeight - from.outerHeight) * baseline.y +
                pos.top;
            from.left =
                (original.outerWidth - from.outerWidth) * baseline.x + pos.left;
            to.top =
                (original.outerHeight - to.outerHeight) * baseline.y + pos.top;
            to.left =
                (original.outerWidth - to.outerWidth) * baseline.x + pos.left;
        }
        delete from.outerHeight;
        delete from.outerWidth;
        element.css(from);

        // Animate the children if desired
        if (scale === "content" || scale === "both") {
            vProps = vProps
                .concat(["marginTop", "marginBottom"])
                .concat(cProps);
            hProps = hProps.concat(["marginLeft", "marginRight"]);

            // Only animate children with width attributes specified
            // TODO: is this right? should we include anything with css width specified as well
            element.find("*[width]").each(function () {
                var child = $(this),
                    childOriginal = $.effects.scaledDimensions(child),
                    childFrom = {
                        height: childOriginal.height * factor.from.y,
                        width: childOriginal.width * factor.from.x,
                        outerHeight: childOriginal.outerHeight * factor.from.y,
                        outerWidth: childOriginal.outerWidth * factor.from.x,
                    },
                    childTo = {
                        height: childOriginal.height * factor.to.y,
                        width: childOriginal.width * factor.to.x,
                        outerHeight: childOriginal.height * factor.to.y,
                        outerWidth: childOriginal.width * factor.to.x,
                    };

                // Vertical props scaling
                if (factor.from.y !== factor.to.y) {
                    childFrom = $.effects.setTransition(
                        child,
                        vProps,
                        factor.from.y,
                        childFrom
                    );
                    childTo = $.effects.setTransition(
                        child,
                        vProps,
                        factor.to.y,
                        childTo
                    );
                }

                // Horizontal props scaling
                if (factor.from.x !== factor.to.x) {
                    childFrom = $.effects.setTransition(
                        child,
                        hProps,
                        factor.from.x,
                        childFrom
                    );
                    childTo = $.effects.setTransition(
                        child,
                        hProps,
                        factor.to.x,
                        childTo
                    );
                }

                if (restore) {
                    $.effects.saveStyle(child);
                }

                // Animate children
                child.css(childFrom);
                child.animate(
                    childTo,
                    options.duration,
                    options.easing,
                    function () {
                        // Restore children
                        if (restore) {
                            $.effects.restoreStyle(child);
                        }
                    }
                );
            });
        }

        // Animate
        element.animate(to, {
            queue: false,
            duration: options.duration,
            easing: options.easing,
            complete: function () {
                var offset = element.offset();

                if (to.opacity === 0) {
                    element.css("opacity", from.opacity);
                }

                if (!restore) {
                    element
                        .css(
                            "position",
                            position === "static" ? "relative" : position
                        )
                        .offset(offset);

                    // Need to save style here so that automatic style restoration
                    // doesn't restore to the original styles from before the animation.
                    $.effects.saveStyle(element);
                }

                done();
            },
        });
    });

    /*!
     * jQuery UI Effects Scale 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Scale Effect
    //>>group: Effects
    //>>description: Grows or shrinks an element and its content.
    //>>docs: http://api.jqueryui.com/scale-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectScale = $.effects.define(
        "scale",
        function (options, done) {
            // Create element
            var el = $(this),
                mode = options.mode,
                percent =
                    parseInt(options.percent, 10) ||
                    (parseInt(options.percent, 10) === 0
                        ? 0
                        : mode !== "effect"
                        ? 0
                        : 100),
                newOptions = $.extend(
                    true,
                    {
                        from: $.effects.scaledDimensions(el),
                        to: $.effects.scaledDimensions(
                            el,
                            percent,
                            options.direction || "both"
                        ),
                        origin: options.origin || ["middle", "center"],
                    },
                    options
                );

            // Fade option to support puff
            if (options.fade) {
                newOptions.from.opacity = 1;
                newOptions.to.opacity = 0;
            }

            $.effects.effect.size.call(this, newOptions, done);
        }
    );

    /*!
     * jQuery UI Effects Puff 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Puff Effect
    //>>group: Effects
    //>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
    //>>docs: http://api.jqueryui.com/puff-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectPuff = $.effects.define(
        "puff",
        "hide",
        function (options, done) {
            var newOptions = $.extend(true, {}, options, {
                fade: true,
                percent: parseInt(options.percent, 10) || 150,
            });

            $.effects.effect.scale.call(this, newOptions, done);
        }
    );

    /*!
     * jQuery UI Effects Pulsate 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Pulsate Effect
    //>>group: Effects
    //>>description: Pulsates an element n times by changing the opacity to zero and back.
    //>>docs: http://api.jqueryui.com/pulsate-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectPulsate = $.effects.define(
        "pulsate",
        "show",
        function (options, done) {
            var element = $(this),
                mode = options.mode,
                show = mode === "show",
                hide = mode === "hide",
                showhide = show || hide,
                // Showing or hiding leaves off the "last" animation
                anims = (options.times || 5) * 2 + (showhide ? 1 : 0),
                duration = options.duration / anims,
                animateTo = 0,
                i = 1,
                queuelen = element.queue().length;

            if (show || !element.is(":visible")) {
                element.css("opacity", 0).show();
                animateTo = 1;
            }

            // Anims - 1 opacity "toggles"
            for (; i < anims; i++) {
                element.animate(
                    { opacity: animateTo },
                    duration,
                    options.easing
                );
                animateTo = 1 - animateTo;
            }

            element.animate({ opacity: animateTo }, duration, options.easing);

            element.queue(done);

            $.effects.unshift(element, queuelen, anims + 1);
        }
    );

    /*!
     * jQuery UI Effects Shake 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Shake Effect
    //>>group: Effects
    //>>description: Shakes an element horizontally or vertically n times.
    //>>docs: http://api.jqueryui.com/shake-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectShake = $.effects.define(
        "shake",
        function (options, done) {
            var i = 1,
                element = $(this),
                direction = options.direction || "left",
                distance = options.distance || 20,
                times = options.times || 3,
                anims = times * 2 + 1,
                speed = Math.round(options.duration / anims),
                ref =
                    direction === "up" || direction === "down" ? "top" : "left",
                positiveMotion = direction === "up" || direction === "left",
                animation = {},
                animation1 = {},
                animation2 = {},
                queuelen = element.queue().length;

            $.effects.createPlaceholder(element);

            // Animation
            animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
            animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
            animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;

            // Animate
            element.animate(animation, speed, options.easing);

            // Shakes
            for (; i < times; i++) {
                element
                    .animate(animation1, speed, options.easing)
                    .animate(animation2, speed, options.easing);
            }

            element
                .animate(animation1, speed, options.easing)
                .animate(animation, speed / 2, options.easing)
                .queue(done);

            $.effects.unshift(element, queuelen, anims + 1);
        }
    );

    /*!
     * jQuery UI Effects Slide 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Slide Effect
    //>>group: Effects
    //>>description: Slides an element in and out of the viewport.
    //>>docs: http://api.jqueryui.com/slide-effect/
    //>>demos: http://jqueryui.com/effect/

    var effectsEffectSlide = $.effects.define(
        "slide",
        "show",
        function (options, done) {
            var startClip,
                startRef,
                element = $(this),
                map = {
                    up: ["bottom", "top"],
                    down: ["top", "bottom"],
                    left: ["right", "left"],
                    right: ["left", "right"],
                },
                mode = options.mode,
                direction = options.direction || "left",
                ref =
                    direction === "up" || direction === "down" ? "top" : "left",
                positiveMotion = direction === "up" || direction === "left",
                distance =
                    options.distance ||
                    element[ref === "top" ? "outerHeight" : "outerWidth"](true),
                animation = {};

            $.effects.createPlaceholder(element);

            startClip = element.cssClip();
            startRef = element.position()[ref];

            // Define hide animation
            animation[ref] = (positiveMotion ? -1 : 1) * distance + startRef;
            animation.clip = element.cssClip();
            animation.clip[map[direction][1]] =
                animation.clip[map[direction][0]];

            // Reverse the animation if we're showing
            if (mode === "show") {
                element.cssClip(animation.clip);
                element.css(ref, animation[ref]);
                animation.clip = startClip;
                animation[ref] = startRef;
            }

            // Actually animate
            element.animate(animation, {
                queue: false,
                duration: options.duration,
                easing: options.easing,
                complete: done,
            });
        }
    );

    /*!
     * jQuery UI Effects Transfer 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Transfer Effect
    //>>group: Effects
    //>>description: Displays a transfer effect from one element to another.
    //>>docs: http://api.jqueryui.com/transfer-effect/
    //>>demos: http://jqueryui.com/effect/

    var effect;
    if ($.uiBackCompat !== false) {
        effect = $.effects.define("transfer", function (options, done) {
            $(this).transfer(options, done);
        });
    }
    var effectsEffectTransfer = effect;

    /*!
     * jQuery UI Focusable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: :focusable Selector
    //>>group: Core
    //>>description: Selects elements which can be focused.
    //>>docs: http://api.jqueryui.com/focusable-selector/

    // Selectors
    $.ui.focusable = function (element, hasTabindex) {
        var map,
            mapName,
            img,
            focusableIfVisible,
            fieldset,
            nodeName = element.nodeName.toLowerCase();

        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (
                !element.href ||
                !mapName ||
                map.nodeName.toLowerCase() !== "map"
            ) {
                return false;
            }
            img = $("img[usemap='#" + mapName + "']");
            return img.length > 0 && img.is(":visible");
        }

        if (/^(input|select|textarea|button|object)$/.test(nodeName)) {
            focusableIfVisible = !element.disabled;

            if (focusableIfVisible) {
                // Form controls within a disabled fieldset are disabled.
                // However, controls within the fieldset's legend do not get disabled.
                // Since controls generally aren't placed inside legends, we skip
                // this portion of the check.
                fieldset = $(element).closest("fieldset")[0];
                if (fieldset) {
                    focusableIfVisible = !fieldset.disabled;
                }
            }
        } else if ("a" === nodeName) {
            focusableIfVisible = element.href || hasTabindex;
        } else {
            focusableIfVisible = hasTabindex;
        }

        return (
            focusableIfVisible &&
            $(element).is(":visible") &&
            visible($(element))
        );
    };

    // Support: IE 8 only
    // IE 8 doesn't resolve inherit to visible/hidden for computed values
    function visible(element) {
        var visibility = element.css("visibility");
        while (visibility === "inherit") {
            element = element.parent();
            visibility = element.css("visibility");
        }
        return visibility === "visible";
    }

    $.extend($.expr.pseudos, {
        focusable: function (element) {
            return $.ui.focusable(element, $.attr(element, "tabindex") != null);
        },
    });

    var focusable = $.ui.focusable;

    // Support: IE8 Only
    // IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
    // with a string, so we need to find the proper form.
    var form = ($.fn._form = function () {
        return typeof this[0].form === "string"
            ? this.closest("form")
            : $(this[0].form);
    });

    /*!
     * jQuery UI Form Reset Mixin 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Form Reset Mixin
    //>>group: Core
    //>>description: Refresh input widgets when their form is reset
    //>>docs: http://api.jqueryui.com/form-reset-mixin/

    var formResetMixin = ($.ui.formResetMixin = {
        _formResetHandler: function () {
            var form = $(this);

            // Wait for the form reset to actually happen before refreshing
            setTimeout(function () {
                var instances = form.data("ui-form-reset-instances");
                $.each(instances, function () {
                    this.refresh();
                });
            });
        },

        _bindFormResetHandler: function () {
            this.form = this.element._form();
            if (!this.form.length) {
                return;
            }

            var instances = this.form.data("ui-form-reset-instances") || [];
            if (!instances.length) {
                // We don't use _on() here because we use a single event handler per form
                this.form.on("reset.ui-form-reset", this._formResetHandler);
            }
            instances.push(this);
            this.form.data("ui-form-reset-instances", instances);
        },

        _unbindFormResetHandler: function () {
            if (!this.form.length) {
                return;
            }

            var instances = this.form.data("ui-form-reset-instances");
            instances.splice($.inArray(this, instances), 1);
            if (instances.length) {
                this.form.data("ui-form-reset-instances", instances);
            } else {
                this.form
                    .removeData("ui-form-reset-instances")
                    .off("reset.ui-form-reset");
            }
        },
    });

    /*!
     * jQuery UI Support for jQuery core 1.8.x and newer 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     */

    //>>label: jQuery 1.8+ Support
    //>>group: Core
    //>>description: Support version 1.8.x and newer of jQuery core

    // Support: jQuery 1.9.x or older
    // $.expr[ ":" ] is deprecated.
    if (!$.expr.pseudos) {
        $.expr.pseudos = $.expr[":"];
    }

    // Support: jQuery 1.11.x or older
    // $.unique has been renamed to $.uniqueSort
    if (!$.uniqueSort) {
        $.uniqueSort = $.unique;
    }

    // Support: jQuery 2.2.x or older.
    // This method has been defined in jQuery 3.0.0.
    // Code from https://github.com/jquery/jquery/blob/e539bac79e666bba95bba86d690b4e609dca2286/src/selector/escapeSelector.js
    if (!$.escapeSelector) {
        // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

        var fcssescape = function (ch, asCodePoint) {
            if (asCodePoint) {
                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                if (ch === "\0") {
                    return "\uFFFD";
                }

                // Control characters and (dependent upon position) numbers get escaped as code points
                return (
                    ch.slice(0, -1) +
                    "\\" +
                    ch.charCodeAt(ch.length - 1).toString(16) +
                    " "
                );
            }

            // Other potentially-special ASCII characters get backslash-escaped
            return "\\" + ch;
        };

        $.escapeSelector = function (sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        };
    }

    // Support: jQuery 3.4.x or older
    // These methods have been defined in jQuery 3.5.0.
    if (!$.fn.even || !$.fn.odd) {
        $.fn.extend({
            even: function () {
                return this.filter(function (i) {
                    return i % 2 === 0;
                });
            },
            odd: function () {
                return this.filter(function (i) {
                    return i % 2 === 1;
                });
            },
        });
    }

    /*!
     * jQuery UI Keycode 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Keycode
    //>>group: Core
    //>>description: Provide keycodes as keynames
    //>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/

    var keycode = ($.ui.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38,
    });

    /*!
     * jQuery UI Labels 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: labels
    //>>group: Core
    //>>description: Find all the labels associated with a given input
    //>>docs: http://api.jqueryui.com/labels/

    var labels = ($.fn.labels = function () {
        var ancestor, selector, id, labels, ancestors;

        if (!this.length) {
            return this.pushStack([]);
        }

        // Check control.labels first
        if (this[0].labels && this[0].labels.length) {
            return this.pushStack(this[0].labels);
        }

        // Support: IE <= 11, FF <= 37, Android <= 2.3 only
        // Above browsers do not support control.labels. Everything below is to support them
        // as well as document fragments. control.labels does not work on document fragments
        labels = this.eq(0).parents("label");

        // Look for the label based on the id
        id = this.attr("id");
        if (id) {
            // We don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.eq(0).parents().last();

            // Get a full set of top level ancestors
            ancestors = ancestor.add(
                ancestor.length ? ancestor.siblings() : this.siblings()
            );

            // Create a selector for the label based on the id
            selector = "label[for='" + $.escapeSelector(id) + "']";

            labels = labels.add(ancestors.find(selector).addBack(selector));
        }

        // Return whatever we have found for labels
        return this.pushStack(labels);
    });

    /*!
     * jQuery UI Scroll Parent 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: scrollParent
    //>>group: Core
    //>>description: Get the closest ancestor element that is scrollable.
    //>>docs: http://api.jqueryui.com/scrollParent/

    var scrollParent = ($.fn.scrollParent = function (includeHidden) {
        var position = this.css("position"),
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden
                ? /(auto|scroll|hidden)/
                : /(auto|scroll)/,
            scrollParent = this.parents()
                .filter(function () {
                    var parent = $(this);
                    if (
                        excludeStaticParent &&
                        parent.css("position") === "static"
                    ) {
                        return false;
                    }
                    return overflowRegex.test(
                        parent.css("overflow") +
                            parent.css("overflow-y") +
                            parent.css("overflow-x")
                    );
                })
                .eq(0);

        return position === "fixed" || !scrollParent.length
            ? $(this[0].ownerDocument || document)
            : scrollParent;
    });

    /*!
     * jQuery UI Tabbable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: :tabbable Selector
    //>>group: Core
    //>>description: Selects elements which can be tabbed to.
    //>>docs: http://api.jqueryui.com/tabbable-selector/

    var tabbable = $.extend($.expr.pseudos, {
        tabbable: function (element) {
            var tabIndex = $.attr(element, "tabindex"),
                hasTabindex = tabIndex != null;
            return (
                (!hasTabindex || tabIndex >= 0) &&
                $.ui.focusable(element, hasTabindex)
            );
        },
    });

    /*!
     * jQuery UI Unique ID 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: uniqueId
    //>>group: Core
    //>>description: Functions to generate and remove uniqueId's
    //>>docs: http://api.jqueryui.com/uniqueId/

    var uniqueId = $.fn.extend({
        uniqueId: (function () {
            var uuid = 0;

            return function () {
                return this.each(function () {
                    if (!this.id) {
                        this.id = "ui-id-" + ++uuid;
                    }
                });
            };
        })(),

        removeUniqueId: function () {
            return this.each(function () {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        },
    });

    /*!
     * jQuery UI Accordion 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Accordion
    //>>group: Widgets
    /* eslint-disable max-len */
    //>>description: Displays collapsible content panels for presenting information in a limited amount of space.
    /* eslint-enable max-len */
    //>>docs: http://api.jqueryui.com/accordion/
    //>>demos: http://jqueryui.com/accordion/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/accordion.css
    //>>css.theme: ../../themes/base/theme.css

    var widgetsAccordion = $.widget("ui.accordion", {
        version: "1.13.2",
        options: {
            active: 0,
            animate: {},
            classes: {
                "ui-accordion-header": "ui-corner-top",
                "ui-accordion-header-collapsed": "ui-corner-all",
                "ui-accordion-content": "ui-corner-bottom",
            },
            collapsible: false,
            event: "click",
            header: function (elem) {
                return elem
                    .find("> li > :first-child")
                    .add(elem.find("> :not(li)").even());
            },
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e",
            },

            // Callbacks
            activate: null,
            beforeActivate: null,
        },

        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide",
        },

        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show",
        },

        _create: function () {
            var options = this.options;

            this.prevShow = this.prevHide = $();
            this._addClass("ui-accordion", "ui-widget ui-helper-reset");
            this.element.attr("role", "tablist");

            // Don't allow collapsible: false and active: false / null
            if (
                !options.collapsible &&
                (options.active === false || options.active == null)
            ) {
                options.active = 0;
            }

            this._processPanels();

            // handle negative values
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },

        _getCreateEventData: function () {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next(),
            };
        },

        _createIcons: function () {
            var icon,
                children,
                icons = this.options.icons;

            if (icons) {
                icon = $("<span>");
                this._addClass(
                    icon,
                    "ui-accordion-header-icon",
                    "ui-icon " + icons.header
                );
                icon.prependTo(this.headers);
                children = this.active.children(".ui-accordion-header-icon");
                this._removeClass(children, icons.header)
                    ._addClass(children, null, icons.activeHeader)
                    ._addClass(this.headers, "ui-accordion-icons");
            }
        },

        _destroyIcons: function () {
            this._removeClass(this.headers, "ui-accordion-icons");
            this.headers.children(".ui-accordion-header-icon").remove();
        },

        _destroy: function () {
            var contents;

            // Clean up main element
            this.element.removeAttr("role");

            // Clean up headers
            this.headers
                .removeAttr(
                    "role aria-expanded aria-selected aria-controls tabIndex"
                )
                .removeUniqueId();

            this._destroyIcons();

            // Clean up content panels
            contents = this.headers
                .next()
                .css("display", "")
                .removeAttr("role aria-hidden aria-labelledby")
                .removeUniqueId();

            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },

        _setOption: function (key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }

            this._super(key, value);

            // Setting collapsible: false while collapsed; open first panel
            if (
                key === "collapsible" &&
                !value &&
                this.options.active === false
            ) {
                this._activate(0);
            }

            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }
        },

        _setOptionDisabled: function (value) {
            this._super(value);

            this.element.attr("aria-disabled", value);

            // Support: IE8 Only
            // #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            this._toggleClass(null, "ui-state-disabled", !!value);
            this._toggleClass(
                this.headers.add(this.headers.next()),
                null,
                "ui-state-disabled",
                !!value
            );
        },

        _keydown: function (event) {
            if (event.altKey || event.ctrlKey) {
                return;
            }

            var keyCode = $.ui.keyCode,
                length = this.headers.length,
                currentIndex = this.headers.index(event.target),
                toFocus = false;

            switch (event.keyCode) {
                case keyCode.RIGHT:
                case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;
                case keyCode.LEFT:
                case keyCode.UP:
                    toFocus =
                        this.headers[(currentIndex - 1 + length) % length];
                    break;
                case keyCode.SPACE:
                case keyCode.ENTER:
                    this._eventHandler(event);
                    break;
                case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;
                case keyCode.END:
                    toFocus = this.headers[length - 1];
                    break;
            }

            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                $(toFocus).trigger("focus");
                event.preventDefault();
            }
        },

        _panelKeyDown: function (event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().trigger("focus");
            }
        },

        refresh: function () {
            var options = this.options;
            this._processPanels();

            // Was collapsed or no panel
            if (
                (options.active === false && options.collapsible === true) ||
                !this.headers.length
            ) {
                options.active = false;
                this.active = $();

                // active false only when collapsible is true
            } else if (options.active === false) {
                this._activate(0);

                // was active, but active panel is gone
            } else if (
                this.active.length &&
                !$.contains(this.element[0], this.active[0])
            ) {
                // all remaining panel are disabled
                if (
                    this.headers.length ===
                    this.headers.find(".ui-state-disabled").length
                ) {
                    options.active = false;
                    this.active = $();

                    // activate previous panel
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }

                // was active, active panel still exists
            } else {
                // make sure active index is correct
                options.active = this.headers.index(this.active);
            }

            this._destroyIcons();

            this._refresh();
        },

        _processPanels: function () {
            var prevHeaders = this.headers,
                prevPanels = this.panels;

            if (typeof this.options.header === "function") {
                this.headers = this.options.header(this.element);
            } else {
                this.headers = this.element.find(this.options.header);
            }
            this._addClass(
                this.headers,
                "ui-accordion-header ui-accordion-header-collapsed",
                "ui-state-default"
            );

            this.panels = this.headers
                .next()
                .filter(":not(.ui-accordion-content-active)")
                .hide();
            this._addClass(
                this.panels,
                "ui-accordion-content",
                "ui-helper-reset ui-widget-content"
            );

            // Avoid memory leaks (#10056)
            if (prevPanels) {
                this._off(prevHeaders.not(this.headers));
                this._off(prevPanels.not(this.panels));
            }
        },

        _refresh: function () {
            var maxHeight,
                options = this.options,
                heightStyle = options.heightStyle,
                parent = this.element.parent();

            this.active = this._findActive(options.active);
            this._addClass(
                this.active,
                "ui-accordion-header-active",
                "ui-state-active"
            )._removeClass(this.active, "ui-accordion-header-collapsed");
            this._addClass(this.active.next(), "ui-accordion-content-active");
            this.active.next().show();

            this.headers
                .attr("role", "tab")
                .each(function () {
                    var header = $(this),
                        headerId = header.uniqueId().attr("id"),
                        panel = header.next(),
                        panelId = panel.uniqueId().attr("id");
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                })
                .next()
                .attr("role", "tabpanel");

            this.headers
                .not(this.active)
                .attr({
                    "aria-selected": "false",
                    "aria-expanded": "false",
                    tabIndex: -1,
                })
                .next()
                .attr({
                    "aria-hidden": "true",
                })
                .hide();

            // Make sure at least one header is in the tab order
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active
                    .attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0,
                    })
                    .next()
                    .attr({
                        "aria-hidden": "false",
                    });
            }

            this._createIcons();

            this._setupEvents(options.event);

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.headers.each(function () {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.headers
                    .next()
                    .each(function () {
                        $(this).height(
                            Math.max(
                                0,
                                maxHeight -
                                    $(this).innerHeight() +
                                    $(this).height()
                            )
                        );
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers
                    .next()
                    .each(function () {
                        var isVisible = $(this).is(":visible");
                        if (!isVisible) {
                            $(this).show();
                        }
                        maxHeight = Math.max(
                            maxHeight,
                            $(this).css("height", "").height()
                        );
                        if (!isVisible) {
                            $(this).hide();
                        }
                    })
                    .height(maxHeight);
            }
        },

        _activate: function (index) {
            var active = this._findActive(index)[0];

            // Trying to activate the already active panel
            if (active === this.active[0]) {
                return;
            }

            // Trying to collapse, simulate a click on the currently active header
            active = active || this.active[0];

            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop,
            });
        },

        _findActive: function (selector) {
            return typeof selector === "number"
                ? this.headers.eq(selector)
                : $();
        },

        _setupEvents: function (event) {
            var events = {
                keydown: "_keydown",
            };
            if (event) {
                $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), { keydown: "_panelKeyDown" });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },

        _eventHandler: function (event) {
            var activeChildren,
                clickedChildren,
                options = this.options,
                active = this.active,
                clicked = $(event.currentTarget),
                clickedIsActive = clicked[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : clicked.next(),
                toHide = active.next(),
                eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow,
                };

            event.preventDefault();

            if (
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                this._trigger("beforeActivate", event, eventData) === false
            ) {
                return;
            }

            options.active = collapsing ? false : this.headers.index(clicked);

            // When the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);

            // Switch classes
            // corner classes on the previously active header stay after the animation
            this._removeClass(
                active,
                "ui-accordion-header-active",
                "ui-state-active"
            );
            if (options.icons) {
                activeChildren = active.children(".ui-accordion-header-icon");
                this._removeClass(
                    activeChildren,
                    null,
                    options.icons.activeHeader
                )._addClass(activeChildren, null, options.icons.header);
            }

            if (!clickedIsActive) {
                this._removeClass(
                    clicked,
                    "ui-accordion-header-collapsed"
                )._addClass(
                    clicked,
                    "ui-accordion-header-active",
                    "ui-state-active"
                );
                if (options.icons) {
                    clickedChildren = clicked.children(
                        ".ui-accordion-header-icon"
                    );
                    this._removeClass(
                        clickedChildren,
                        null,
                        options.icons.header
                    )._addClass(
                        clickedChildren,
                        null,
                        options.icons.activeHeader
                    );
                }

                this._addClass(clicked.next(), "ui-accordion-content-active");
            }
        },

        _toggle: function (data) {
            var toShow = data.newPanel,
                toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

            // Handle activating a panel during the animation for another activation
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;

            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }

            toHide.attr({
                "aria-hidden": "true",
            });
            toHide.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false",
            });

            // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            if (toShow.length && toHide.length) {
                toHide.prev().attr({
                    tabIndex: -1,
                    "aria-expanded": "false",
                });
            } else if (toShow.length) {
                this.headers
                    .filter(function () {
                        return parseInt($(this).attr("tabIndex"), 10) === 0;
                    })
                    .attr("tabIndex", -1);
            }

            toShow.attr("aria-hidden", "false").prev().attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0,
            });
        },

        _animate: function (toShow, toHide, data) {
            var total,
                easing,
                duration,
                that = this,
                adjust = 0,
                boxSizing = toShow.css("box-sizing"),
                down =
                    toShow.length &&
                    (!toHide.length || toShow.index() < toHide.index()),
                animate = this.options.animate || {},
                options = (down && animate.down) || animate,
                complete = function () {
                    that._toggleComplete(data);
                };

            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }

            // fall back from options to animation in case of partial down settings
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;

            if (!toHide.length) {
                return toShow.animate(
                    this.showProps,
                    duration,
                    easing,
                    complete
                );
            }
            if (!toShow.length) {
                return toHide.animate(
                    this.hideProps,
                    duration,
                    easing,
                    complete
                );
            }

            total = toShow.show().outerHeight();
            toHide.animate(this.hideProps, {
                duration: duration,
                easing: easing,
                step: function (now, fx) {
                    fx.now = Math.round(now);
                },
            });
            toShow.hide().animate(this.showProps, {
                duration: duration,
                easing: easing,
                complete: complete,
                step: function (now, fx) {
                    fx.now = Math.round(now);
                    if (fx.prop !== "height") {
                        if (boxSizing === "content-box") {
                            adjust += fx.now;
                        }
                    } else if (that.options.heightStyle !== "content") {
                        fx.now = Math.round(
                            total - toHide.outerHeight() - adjust
                        );
                        adjust = 0;
                    }
                },
            });
        },

        _toggleComplete: function (data) {
            var toHide = data.oldPanel,
                prev = toHide.prev();

            this._removeClass(toHide, "ui-accordion-content-active");
            this._removeClass(prev, "ui-accordion-header-active")._addClass(
                prev,
                "ui-accordion-header-collapsed"
            );

            // Work around for rendering bug in IE (#5421)
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }
            this._trigger("activate", null, data);
        },
    });

    var safeActiveElement = ($.ui.safeActiveElement = function (document) {
        var activeElement;

        // Support: IE 9 only
        // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
        try {
            activeElement = document.activeElement;
        } catch (error) {
            activeElement = document.body;
        }

        // Support: IE 9 - 11 only
        // IE may return null instead of an element
        // Interestingly, this only seems to occur when NOT in an iframe
        if (!activeElement) {
            activeElement = document.body;
        }

        // Support: IE 11 only
        // IE11 returns a seemingly empty object in some cases when accessing
        // document.activeElement from an <iframe>
        if (!activeElement.nodeName) {
            activeElement = document.body;
        }

        return activeElement;
    });

    /*!
     * jQuery UI Menu 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Menu
    //>>group: Widgets
    //>>description: Creates nestable menus.
    //>>docs: http://api.jqueryui.com/menu/
    //>>demos: http://jqueryui.com/menu/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/menu.css
    //>>css.theme: ../../themes/base/theme.css

    var widgetsMenu = $.widget("ui.menu", {
        version: "1.13.2",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-caret-1-e",
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left top",
                at: "right top",
            },
            role: "menu",

            // Callbacks
            blur: null,
            focus: null,
            select: null,
        },

        _create: function () {
            this.activeMenu = this.element;

            // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false;
            this.lastMousePosition = { x: null, y: null };
            this.element.uniqueId().attr({
                role: this.options.role,
                tabIndex: 0,
            });

            this._addClass("ui-menu", "ui-widget ui-widget-content");
            this._on({
                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item": function (event) {
                    event.preventDefault();

                    this._activateItem(event);
                },
                "click .ui-menu-item": function (event) {
                    var target = $(event.target);
                    var active = $($.ui.safeActiveElement(this.document[0]));
                    if (
                        !this.mouseHandled &&
                        target.not(".ui-state-disabled").length
                    ) {
                        this.select(event);

                        // Only set the mouseHandled flag if the event will bubble, see #9469.
                        if (!event.isPropagationStopped()) {
                            this.mouseHandled = true;
                        }

                        // Open submenu on click
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (
                            !this.element.is(":focus") &&
                            active.closest(".ui-menu").length
                        ) {
                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (
                                this.active &&
                                this.active.parents(".ui-menu").length === 1
                            ) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": "_activateItem",
                "mousemove .ui-menu-item": "_activateItem",
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function (event, keepActiveItem) {
                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this._menuItems().first();

                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function (event) {
                    this._delay(function () {
                        var notContained = !$.contains(
                            this.element[0],
                            $.ui.safeActiveElement(this.document[0])
                        );
                        if (notContained) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown",
            });

            this.refresh();

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
                click: function (event) {
                    if (this._closeOnDocumentClick(event)) {
                        this.collapseAll(event, true);
                    }

                    // Reset the mouseHandled flag
                    this.mouseHandled = false;
                },
            });
        },

        _activateItem: function (event) {
            // Ignore mouse events while typeahead is active, see #10458.
            // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
            // is over an item in the menu
            if (this.previousFilter) {
                return;
            }

            // If the mouse didn't actually move, but the page was scrolled, ignore the event (#9356)
            if (
                event.clientX === this.lastMousePosition.x &&
                event.clientY === this.lastMousePosition.y
            ) {
                return;
            }

            this.lastMousePosition = {
                x: event.clientX,
                y: event.clientY,
            };

            var actualTarget = $(event.target).closest(".ui-menu-item"),
                target = $(event.currentTarget);

            // Ignore bubbled events on parent items, see #11641
            if (actualTarget[0] !== target[0]) {
                return;
            }

            // If the item is already active, there's nothing to do
            if (target.is(".ui-state-active")) {
                return;
            }

            // Remove ui-state-active class from siblings of the newly focused menu item
            // to avoid a jump caused by adjacent elements both having a class with a border
            this._removeClass(
                target.siblings().children(".ui-state-active"),
                null,
                "ui-state-active"
            );
            this.focus(event, target);
        },

        _destroy: function () {
            var items = this.element
                    .find(".ui-menu-item")
                    .removeAttr("role aria-disabled"),
                submenus = items
                    .children(".ui-menu-item-wrapper")
                    .removeUniqueId()
                    .removeAttr("tabIndex role aria-haspopup");

            // Destroy (sub)menus
            this.element
                .removeAttr("aria-activedescendant")
                .find(".ui-menu")
                .addBack()
                .removeAttr(
                    "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
                        "tabIndex"
                )
                .removeUniqueId()
                .show();

            submenus.children().each(function () {
                var elem = $(this);
                if (elem.data("ui-menu-submenu-caret")) {
                    elem.remove();
                }
            });
        },

        _keydown: function (event) {
            var match,
                prev,
                character,
                skip,
                preventDefault = true;

            switch (event.keyCode) {
                case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;
                case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;
                case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;
                case $.ui.keyCode.UP:
                    this.previous(event);
                    break;
                case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;
                case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;
                case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;
                case $.ui.keyCode.ENTER:
                case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;
                case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;
                default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    skip = false;

                    // Support number pad values
                    character =
                        event.keyCode >= 96 && event.keyCode <= 105
                            ? (event.keyCode - 96).toString()
                            : String.fromCharCode(event.keyCode);

                    clearTimeout(this.filterTimer);

                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }

                    match = this._filterMenuItems(character);
                    match =
                        skip && match.index(this.active.next()) !== -1
                            ? this.active.nextAll(".ui-menu-item")
                            : match;

                    // If no matches on the current filter, reset to the last character pressed
                    // to move down the menu to the first item that starts with that character
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        match = this._filterMenuItems(character);
                    }

                    if (match.length) {
                        this.focus(event, match);
                        this.previousFilter = character;
                        this.filterTimer = this._delay(function () {
                            delete this.previousFilter;
                        }, 1000);
                    } else {
                        delete this.previousFilter;
                    }
            }

            if (preventDefault) {
                event.preventDefault();
            }
        },

        _activate: function (event) {
            if (this.active && !this.active.is(".ui-state-disabled")) {
                if (this.active.children("[aria-haspopup='true']").length) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },

        refresh: function () {
            var menus,
                items,
                newSubmenus,
                newItems,
                newWrappers,
                that = this,
                icon = this.options.icons.submenu,
                submenus = this.element.find(this.options.menus);

            this._toggleClass(
                "ui-menu-icons",
                null,
                !!this.element.find(".ui-icon").length
            );

            // Initialize nested menus
            newSubmenus = submenus
                .filter(":not(.ui-menu)")
                .hide()
                .attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false",
                })
                .each(function () {
                    var menu = $(this),
                        item = menu.prev(),
                        submenuCaret = $("<span>").data(
                            "ui-menu-submenu-caret",
                            true
                        );

                    that._addClass(
                        submenuCaret,
                        "ui-menu-icon",
                        "ui-icon " + icon
                    );
                    item.attr("aria-haspopup", "true").prepend(submenuCaret);
                    menu.attr("aria-labelledby", item.attr("id"));
                });

            this._addClass(
                newSubmenus,
                "ui-menu",
                "ui-widget ui-widget-content ui-front"
            );

            menus = submenus.add(this.element);
            items = menus.find(this.options.items);

            // Initialize menu-items containing spaces and/or dashes only as dividers
            items.not(".ui-menu-item").each(function () {
                var item = $(this);
                if (that._isDivider(item)) {
                    that._addClass(
                        item,
                        "ui-menu-divider",
                        "ui-widget-content"
                    );
                }
            });

            // Don't refresh list items that are already adapted
            newItems = items.not(".ui-menu-item, .ui-menu-divider");
            newWrappers = newItems.children().not(".ui-menu").uniqueId().attr({
                tabIndex: -1,
                role: this._itemRole(),
            });
            this._addClass(newItems, "ui-menu-item")._addClass(
                newWrappers,
                "ui-menu-item-wrapper"
            );

            // Add aria-disabled attribute to any disabled menu item
            items.filter(".ui-state-disabled").attr("aria-disabled", "true");

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },

        _itemRole: function () {
            return {
                menu: "menuitem",
                listbox: "option",
            }[this.options.role];
        },

        _setOption: function (key, value) {
            if (key === "icons") {
                var icons = this.element.find(".ui-menu-icon");
                this._removeClass(
                    icons,
                    null,
                    this.options.icons.submenu
                )._addClass(icons, null, value.submenu);
            }
            this._super(key, value);
        },

        _setOptionDisabled: function (value) {
            this._super(value);

            this.element.attr("aria-disabled", String(value));
            this._toggleClass(null, "ui-state-disabled", !!value);
        },

        focus: function (event, item) {
            var nested, focused, activeParent;
            this.blur(event, event && event.type === "focus");

            this._scrollIntoView(item);

            this.active = item.first();

            focused = this.active.children(".ui-menu-item-wrapper");
            this._addClass(focused, null, "ui-state-active");

            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }

            // Highlight active parent menu item, if any
            activeParent = this.active
                .parent()
                .closest(".ui-menu-item")
                .children(".ui-menu-item-wrapper");
            this._addClass(activeParent, null, "ui-state-active");

            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function () {
                    this._close();
                }, this.delay);
            }

            nested = item.children(".ui-menu");
            if (nested.length && event && /^mouse/.test(event.type)) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();

            this._trigger("focus", event, { item: item });
        },

        _scrollIntoView: function (item) {
            var borderTop,
                paddingTop,
                offset,
                scroll,
                elementHeight,
                itemHeight;
            if (this._hasScroll()) {
                borderTop =
                    parseFloat($.css(this.activeMenu[0], "borderTopWidth")) ||
                    0;
                paddingTop =
                    parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset =
                    item.offset().top -
                    this.activeMenu.offset().top -
                    borderTop -
                    paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.outerHeight();

                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(
                        scroll + offset - elementHeight + itemHeight
                    );
                }
            }
        },

        blur: function (event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }

            if (!this.active) {
                return;
            }

            this._removeClass(
                this.active.children(".ui-menu-item-wrapper"),
                null,
                "ui-state-active"
            );

            this._trigger("blur", event, { item: this.active });
            this.active = null;
        },

        _startOpening: function (submenu) {
            clearTimeout(this.timer);

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the caret icon
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }

            this.timer = this._delay(function () {
                this._close();
                this._open(submenu);
            }, this.delay);
        },

        _open: function (submenu) {
            var position = $.extend(
                {
                    of: this.active,
                },
                this.options.position
            );

            clearTimeout(this.timer);
            this.element
                .find(".ui-menu")
                .not(submenu.parents(".ui-menu"))
                .hide()
                .attr("aria-hidden", "true");

            submenu
                .show()
                .removeAttr("aria-hidden")
                .attr("aria-expanded", "true")
                .position(position);
        },

        collapseAll: function (event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(
                function () {
                    // If we were passed an event, look for the submenu that contains the event
                    var currentMenu = all
                        ? this.element
                        : $(event && event.target).closest(
                              this.element.find(".ui-menu")
                          );

                    // If we found no valid submenu ancestor, use the main menu to close all
                    // sub menus anyway
                    if (!currentMenu.length) {
                        currentMenu = this.element;
                    }

                    this._close(currentMenu);

                    this.blur(event);

                    // Work around active item staying active after menu is blurred
                    this._removeClass(
                        currentMenu.find(".ui-state-active"),
                        null,
                        "ui-state-active"
                    );

                    this.activeMenu = currentMenu;
                },
                all ? 0 : this.delay
            );
        },

        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function (startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }

            startMenu
                .find(".ui-menu")
                .hide()
                .attr("aria-hidden", "true")
                .attr("aria-expanded", "false");
        },

        _closeOnDocumentClick: function (event) {
            return !$(event.target).closest(".ui-menu").length;
        },

        _isDivider: function (item) {
            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test(item.text());
        },

        collapse: function (event) {
            var newItem =
                this.active &&
                this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },

        expand: function (event) {
            var newItem =
                this.active &&
                this._menuItems(this.active.children(".ui-menu")).first();

            if (newItem && newItem.length) {
                this._open(newItem.parent());

                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                this._delay(function () {
                    this.focus(event, newItem);
                });
            }
        },

        next: function (event) {
            this._move("next", "first", event);
        },

        previous: function (event) {
            this._move("prev", "last", event);
        },

        isFirstItem: function () {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },

        isLastItem: function () {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },

        _menuItems: function (menu) {
            return (menu || this.element)
                .find(this.options.items)
                .filter(".ui-menu-item");
        },

        _move: function (direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next =
                        this.active[
                            direction === "first" ? "prevAll" : "nextAll"
                        ](".ui-menu-item").last();
                } else {
                    next =
                        this.active[direction + "All"](".ui-menu-item").first();
                }
            }
            if (!next || !next.length || !this.active) {
                next = this._menuItems(this.activeMenu)[filter]();
            }

            this.focus(event, next);
        },

        nextPage: function (event) {
            var item, base, height;

            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.innerHeight();

                // jQuery 3.2 doesn't include scrollbars in innerHeight, add it back.
                if ($.fn.jquery.indexOf("3.2.") === 0) {
                    height +=
                        this.element[0].offsetHeight -
                        this.element.outerHeight();
                }

                this.active.nextAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });

                this.focus(event, item);
            } else {
                this.focus(
                    event,
                    this._menuItems(this.activeMenu)[
                        !this.active ? "first" : "last"
                    ]()
                );
            }
        },

        previousPage: function (event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.innerHeight();

                // jQuery 3.2 doesn't include scrollbars in innerHeight, add it back.
                if ($.fn.jquery.indexOf("3.2.") === 0) {
                    height +=
                        this.element[0].offsetHeight -
                        this.element.outerHeight();
                }

                this.active.prevAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this._menuItems(this.activeMenu).first());
            }
        },

        _hasScroll: function () {
            return (
                this.element.outerHeight() < this.element.prop("scrollHeight")
            );
        },

        select: function (event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active =
                this.active || $(event.target).closest(".ui-menu-item");
            var ui = { item: this.active };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        },

        _filterMenuItems: function (character) {
            var escapedCharacter = character.replace(
                    /[\-\[\]{}()*+?.,\\\^$|#\s]/g,
                    "\\$&"
                ),
                regex = new RegExp("^" + escapedCharacter, "i");

            return (
                this.activeMenu
                    .find(this.options.items)

                    // Only match on items, not dividers or other content (#10571)
                    .filter(".ui-menu-item")
                    .filter(function () {
                        return regex.test(
                            String.prototype.trim.call(
                                $(this).children(".ui-menu-item-wrapper").text()
                            )
                        );
                    })
            );
        },
    });

    /*!
     * jQuery UI Autocomplete 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Autocomplete
    //>>group: Widgets
    //>>description: Lists suggested words as the user is typing.
    //>>docs: http://api.jqueryui.com/autocomplete/
    //>>demos: http://jqueryui.com/autocomplete/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/autocomplete.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.autocomplete", {
        version: "1.13.2",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none",
            },
            source: null,

            // Callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null,
        },

        requestIndex: 0,
        pending: 0,
        liveRegionTimer: null,

        _create: function () {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress,
                suppressKeyPressRepeat,
                suppressInput,
                nodeName = this.element[0].nodeName.toLowerCase(),
                isTextarea = nodeName === "textarea",
                isInput = nodeName === "input";

            // Textareas are always multi-line
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            // All other element types are determined by whether or not they're contentEditable
            this.isMultiLine =
                isTextarea ||
                (!isInput && this._isContentEditable(this.element));

            this.valueMethod =
                this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;

            this._addClass("ui-autocomplete-input");
            this.element.attr("autocomplete", "off");

            this._on(this.element, {
                keydown: function (event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }

                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:
                            // when menu is open and has focus
                            if (this.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                if (!this.isMultiLine) {
                                    this._value(this.term);
                                }
                                this.close(event);

                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;
                        default:
                            suppressKeyPressRepeat = true;

                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                    }
                },
                keypress: function (event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (
                            !this.isMultiLine ||
                            this.menu.element.is(":visible")
                        ) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }

                    // Replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                    }
                },
                input: function (event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function () {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function (event) {
                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                },
            });

            this._initSource();
            this.menu = $("<ul>")
                .appendTo(this._appendTo())
                .menu({
                    // disable ARIA support, the live region takes care of that
                    role: null,
                })
                .hide()

                // Support: IE 11 only, Edge <= 14
                // For other browsers, we preventDefault() on the mousedown event
                // to keep the dropdown from taking focus from the input. This doesn't
                // work for IE/Edge, causing problems with selection and scrolling (#9638)
                // Happily, IE and Edge support an "unselectable" attribute that
                // prevents an element from receiving focus, exactly what we want here.
                .attr({
                    unselectable: "on",
                })
                .menu("instance");

            this._addClass(this.menu.element, "ui-autocomplete", "ui-front");
            this._on(this.menu.element, {
                mousedown: function (event) {
                    // Prevent moving focus out of the text field
                    event.preventDefault();
                },
                menufocus: function (event, ui) {
                    var label, item;

                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (
                            event.originalEvent &&
                            /^mouse/.test(event.originalEvent.type)
                        ) {
                            this.menu.blur();

                            this.document.one("mousemove", function () {
                                $(event.target).trigger(event.originalEvent);
                            });

                            return;
                        }
                    }

                    item = ui.item.data("ui-autocomplete-item");
                    if (
                        false !== this._trigger("focus", event, { item: item })
                    ) {
                        // use value to match what will end up in the input, if it was a key event
                        if (
                            event.originalEvent &&
                            /^key/.test(event.originalEvent.type)
                        ) {
                            this._value(item.value);
                        }
                    }

                    // Announce the value in the liveRegion
                    label = ui.item.attr("aria-label") || item.value;
                    if (label && String.prototype.trim.call(label).length) {
                        clearTimeout(this.liveRegionTimer);
                        this.liveRegionTimer = this._delay(function () {
                            this.liveRegion.html($("<div>").text(label));
                        }, 100);
                    }
                },
                menuselect: function (event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"),
                        previous = this.previous;

                    // Only trigger when focus was lost (click on menu)
                    if (
                        this.element[0] !==
                        $.ui.safeActiveElement(this.document[0])
                    ) {
                        this.element.trigger("focus");
                        this.previous = previous;

                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay(function () {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }

                    if (
                        false !== this._trigger("select", event, { item: item })
                    ) {
                        this._value(item.value);
                    }

                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();

                    this.close(event);
                    this.selectedItem = item;
                },
            });

            this.liveRegion = $("<div>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions",
            }).appendTo(this.document[0].body);

            this._addClass(
                this.liveRegion,
                null,
                "ui-helper-hidden-accessible"
            );

            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                },
            });
        },

        _destroy: function () {
            clearTimeout(this.searching);
            this.element.removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _isEventTargetInWidget: function (event) {
            var menuElement = this.menu.element[0];

            return (
                event.target === this.element[0] ||
                event.target === menuElement ||
                $.contains(menuElement, event.target)
            );
        },

        _closeOnClickOutside: function (event) {
            if (!this._isEventTargetInWidget(event)) {
                this.close();
            }
        },

        _appendTo: function () {
            var element = this.options.appendTo;

            if (element) {
                element =
                    element.jquery || element.nodeType
                        ? $(element)
                        : this.document.find(element).eq(0);
            }

            if (!element || !element[0]) {
                element = this.element.closest(".ui-front, dialog");
            }

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _initSource: function () {
            var array,
                url,
                that = this;
            if (Array.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function (request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function (request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function (data) {
                            response(data);
                        },
                        error: function () {
                            response([]);
                        },
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },

        _searchTimeout: function (event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function () {
                // Search if the value has changed, or if the user retypes the same value (see #7434)
                var equalValues = this.term === this._value(),
                    menuVisible = this.menu.element.is(":visible"),
                    modifierKey =
                        event.altKey ||
                        event.ctrlKey ||
                        event.metaKey ||
                        event.shiftKey;

                if (
                    !equalValues ||
                    (equalValues && !menuVisible && !modifierKey)
                ) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },

        search: function (value, event) {
            value = value != null ? value : this._value();

            // Always save the actual value, not the one passed as an argument
            this.term = this._value();

            if (value.length < this.options.minLength) {
                return this.close(event);
            }

            if (this._trigger("search", event) === false) {
                return;
            }

            return this._search(value);
        },

        _search: function (value) {
            this.pending++;
            this._addClass("ui-autocomplete-loading");
            this.cancelSearch = false;

            this.source({ term: value }, this._response());
        },

        _response: function () {
            var index = ++this.requestIndex;

            return function (content) {
                if (index === this.requestIndex) {
                    this.__response(content);
                }

                this.pending--;
                if (!this.pending) {
                    this._removeClass("ui-autocomplete-loading");
                }
            }.bind(this);
        },

        __response: function (content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, { content: content });
            if (
                !this.options.disabled &&
                content &&
                content.length &&
                !this.cancelSearch
            ) {
                this._suggest(content);
                this._trigger("open");
            } else {
                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },

        close: function (event) {
            this.cancelSearch = true;
            this._close(event);
        },

        _close: function (event) {
            // Remove the handler that closes the menu on outside clicks
            this._off(this.document, "mousedown");

            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },

        _change: function (event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, { item: this.selectedItem });
            }
        },

        _normalize: function (items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function (item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item,
                    };
                }
                return $.extend({}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label,
                });
            });
        },

        _suggest: function (items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();

            // Size and position menu
            ul.show();
            this._resizeMenu();
            ul.position(
                $.extend(
                    {
                        of: this.element,
                    },
                    this.options.position
                )
            );

            if (this.options.autoFocus) {
                this.menu.next();
            }

            // Listen for interactions outside of the widget (#6642)
            this._on(this.document, {
                mousedown: "_closeOnClickOutside",
            });
        },

        _resizeMenu: function () {
            var ul = this.menu.element;
            ul.outerWidth(
                Math.max(
                    // Firefox wraps long text (possibly a rounding bug)
                    // so we add 1px to avoid the wrapping (#7513)
                    ul.width("").outerWidth() + 1,
                    this.element.outerWidth()
                )
            );
        },

        _renderMenu: function (ul, items) {
            var that = this;
            $.each(items, function (index, item) {
                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function (ul, item) {
            return this._renderItem(ul, item).data(
                "ui-autocomplete-item",
                item
            );
        },

        _renderItem: function (ul, item) {
            return $("<li>").append($("<div>").text(item.label)).appendTo(ul);
        },

        _move: function (direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (
                (this.menu.isFirstItem() && /^previous/.test(direction)) ||
                (this.menu.isLastItem() && /^next/.test(direction))
            ) {
                if (!this.isMultiLine) {
                    this._value(this.term);
                }

                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },

        widget: function () {
            return this.menu.element;
        },

        _value: function () {
            return this.valueMethod.apply(this.element, arguments);
        },

        _keyEvent: function (keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);

                // Prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        },

        // Support: Chrome <=50
        // We should be able to just use this.element.prop( "isContentEditable" )
        // but hidden elements always report false in Chrome.
        // https://code.google.com/p/chromium/issues/detail?id=313082
        _isContentEditable: function (element) {
            if (!element.length) {
                return false;
            }

            var editable = element.prop("contentEditable");

            if (editable === "inherit") {
                return this._isContentEditable(element.parent());
            }

            return editable === "true";
        },
    });

    $.extend($.ui.autocomplete, {
        escapeRegex: function (value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function (array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function (value) {
                return matcher.test(value.label || value.value || value);
            });
        },
    });

    // Live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function (amount) {
                    return (
                        amount +
                        (amount > 1 ? " results are" : " result is") +
                        " available, use up and down arrow keys to navigate."
                    );
                },
            },
        },

        __response: function (content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            clearTimeout(this.liveRegionTimer);
            this.liveRegionTimer = this._delay(function () {
                this.liveRegion.html($("<div>").text(message));
            }, 100);
        },
    });

    var widgetsAutocomplete = $.ui.autocomplete;

    /*!
     * jQuery UI Controlgroup 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Controlgroup
    //>>group: Widgets
    //>>description: Visually groups form control widgets
    //>>docs: http://api.jqueryui.com/controlgroup/
    //>>demos: http://jqueryui.com/controlgroup/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/controlgroup.css
    //>>css.theme: ../../themes/base/theme.css

    var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

    var widgetsControlgroup = $.widget("ui.controlgroup", {
        version: "1.13.2",
        defaultElement: "<div>",
        options: {
            direction: "horizontal",
            disabled: null,
            onlyVisible: true,
            items: {
                button: "input[type=button], input[type=submit], input[type=reset], button, a",
                controlgroupLabel: ".ui-controlgroup-label",
                checkboxradio: "input[type='checkbox'], input[type='radio']",
                selectmenu: "select",
                spinner: ".ui-spinner-input",
            },
        },

        _create: function () {
            this._enhance();
        },

        // To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
        _enhance: function () {
            this.element.attr("role", "toolbar");
            this.refresh();
        },

        _destroy: function () {
            this._callChildMethod("destroy");
            this.childWidgets.removeData("ui-controlgroup-data");
            this.element.removeAttr("role");
            if (this.options.items.controlgroupLabel) {
                this.element
                    .find(this.options.items.controlgroupLabel)
                    .find(".ui-controlgroup-label-contents")
                    .contents()
                    .unwrap();
            }
        },

        _initWidgets: function () {
            var that = this,
                childWidgets = [];

            // First we iterate over each of the items options
            $.each(this.options.items, function (widget, selector) {
                var labels;
                var options = {};

                // Make sure the widget has a selector set
                if (!selector) {
                    return;
                }

                if (widget === "controlgroupLabel") {
                    labels = that.element.find(selector);
                    labels.each(function () {
                        var element = $(this);

                        if (
                            element.children(".ui-controlgroup-label-contents")
                                .length
                        ) {
                            return;
                        }
                        element
                            .contents()
                            .wrapAll(
                                "<span class='ui-controlgroup-label-contents'></span>"
                            );
                    });
                    that._addClass(
                        labels,
                        null,
                        "ui-widget ui-widget-content ui-state-default"
                    );
                    childWidgets = childWidgets.concat(labels.get());
                    return;
                }

                // Make sure the widget actually exists
                if (!$.fn[widget]) {
                    return;
                }

                // We assume everything is in the middle to start because we can't determine
                // first / last elements until all enhancments are done.
                if (that["_" + widget + "Options"]) {
                    options = that["_" + widget + "Options"]("middle");
                } else {
                    options = { classes: {} };
                }

                // Find instances of this widget inside controlgroup and init them
                that.element.find(selector).each(function () {
                    var element = $(this);
                    var instance = element[widget]("instance");

                    // We need to clone the default options for this type of widget to avoid
                    // polluting the variable options which has a wider scope than a single widget.
                    var instanceOptions = $.widget.extend({}, options);

                    // If the button is the child of a spinner ignore it
                    // TODO: Find a more generic solution
                    if (
                        widget === "button" &&
                        element.parent(".ui-spinner").length
                    ) {
                        return;
                    }

                    // Create the widget if it doesn't exist
                    if (!instance) {
                        instance = element[widget]()[widget]("instance");
                    }
                    if (instance) {
                        instanceOptions.classes = that._resolveClassesValues(
                            instanceOptions.classes,
                            instance
                        );
                    }
                    element[widget](instanceOptions);

                    // Store an instance of the controlgroup to be able to reference
                    // from the outermost element for changing options and refresh
                    var widgetElement = element[widget]("widget");
                    $.data(
                        widgetElement[0],
                        "ui-controlgroup-data",
                        instance ? instance : element[widget]("instance")
                    );

                    childWidgets.push(widgetElement[0]);
                });
            });

            this.childWidgets = $($.uniqueSort(childWidgets));
            this._addClass(this.childWidgets, "ui-controlgroup-item");
        },

        _callChildMethod: function (method) {
            this.childWidgets.each(function () {
                var element = $(this),
                    data = element.data("ui-controlgroup-data");
                if (data && data[method]) {
                    data[method]();
                }
            });
        },

        _updateCornerClass: function (element, position) {
            var remove =
                "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
            var add = this._buildSimpleOptions(position, "label").classes.label;

            this._removeClass(element, null, remove);
            this._addClass(element, null, add);
        },

        _buildSimpleOptions: function (position, key) {
            var direction = this.options.direction === "vertical";
            var result = {
                classes: {},
            };
            result.classes[key] = {
                middle: "",
                first: "ui-corner-" + (direction ? "top" : "left"),
                last: "ui-corner-" + (direction ? "bottom" : "right"),
                only: "ui-corner-all",
            }[position];

            return result;
        },

        _spinnerOptions: function (position) {
            var options = this._buildSimpleOptions(position, "ui-spinner");

            options.classes["ui-spinner-up"] = "";
            options.classes["ui-spinner-down"] = "";

            return options;
        },

        _buttonOptions: function (position) {
            return this._buildSimpleOptions(position, "ui-button");
        },

        _checkboxradioOptions: function (position) {
            return this._buildSimpleOptions(position, "ui-checkboxradio-label");
        },

        _selectmenuOptions: function (position) {
            var direction = this.options.direction === "vertical";
            return {
                width: direction ? "auto" : false,
                classes: {
                    middle: {
                        "ui-selectmenu-button-open": "",
                        "ui-selectmenu-button-closed": "",
                    },
                    first: {
                        "ui-selectmenu-button-open":
                            "ui-corner-" + (direction ? "top" : "tl"),
                        "ui-selectmenu-button-closed":
                            "ui-corner-" + (direction ? "top" : "left"),
                    },
                    last: {
                        "ui-selectmenu-button-open": direction
                            ? ""
                            : "ui-corner-tr",
                        "ui-selectmenu-button-closed":
                            "ui-corner-" + (direction ? "bottom" : "right"),
                    },
                    only: {
                        "ui-selectmenu-button-open": "ui-corner-top",
                        "ui-selectmenu-button-closed": "ui-corner-all",
                    },
                }[position],
            };
        },

        _resolveClassesValues: function (classes, instance) {
            var result = {};
            $.each(classes, function (key) {
                var current = instance.options.classes[key] || "";
                current = String.prototype.trim.call(
                    current.replace(controlgroupCornerRegex, "")
                );
                result[key] = (current + " " + classes[key]).replace(
                    /\s+/g,
                    " "
                );
            });
            return result;
        },

        _setOption: function (key, value) {
            if (key === "direction") {
                this._removeClass("ui-controlgroup-" + this.options.direction);
            }

            this._super(key, value);
            if (key === "disabled") {
                this._callChildMethod(value ? "disable" : "enable");
                return;
            }

            this.refresh();
        },

        refresh: function () {
            var children,
                that = this;

            this._addClass(
                "ui-controlgroup ui-controlgroup-" + this.options.direction
            );

            if (this.options.direction === "horizontal") {
                this._addClass(null, "ui-helper-clearfix");
            }
            this._initWidgets();

            children = this.childWidgets;

            // We filter here because we need to track all childWidgets not just the visible ones
            if (this.options.onlyVisible) {
                children = children.filter(":visible");
            }

            if (children.length) {
                // We do this last because we need to make sure all enhancment is done
                // before determining first and last
                $.each(["first", "last"], function (index, value) {
                    var instance = children[value]().data(
                        "ui-controlgroup-data"
                    );

                    if (
                        instance &&
                        that["_" + instance.widgetName + "Options"]
                    ) {
                        var options = that[
                            "_" + instance.widgetName + "Options"
                        ](children.length === 1 ? "only" : value);
                        options.classes = that._resolveClassesValues(
                            options.classes,
                            instance
                        );
                        instance.element[instance.widgetName](options);
                    } else {
                        that._updateCornerClass(children[value](), value);
                    }
                });

                // Finally call the refresh method on each of the child widgets.
                this._callChildMethod("refresh");
            }
        },
    });

    /*!
     * jQuery UI Checkboxradio 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Checkboxradio
    //>>group: Widgets
    //>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
    //>>docs: http://api.jqueryui.com/checkboxradio/
    //>>demos: http://jqueryui.com/checkboxradio/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/button.css
    //>>css.structure: ../../themes/base/checkboxradio.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.checkboxradio", [
        $.ui.formResetMixin,
        {
            version: "1.13.2",
            options: {
                disabled: null,
                label: null,
                icon: true,
                classes: {
                    "ui-checkboxradio-label": "ui-corner-all",
                    "ui-checkboxradio-icon": "ui-corner-all",
                },
            },

            _getCreateOptions: function () {
                var disabled, labels, labelContents;
                var options = this._super() || {};

                // We read the type here, because it makes more sense to throw a element type error first,
                // rather then the error for lack of a label. Often if its the wrong type, it
                // won't have a label (e.g. calling on a div, btn, etc)
                this._readType();

                labels = this.element.labels();

                // If there are multiple labels, use the last one
                this.label = $(labels[labels.length - 1]);
                if (!this.label.length) {
                    $.error("No label found for checkboxradio widget");
                }

                this.originalLabel = "";

                // We need to get the label text but this may also need to make sure it does not contain the
                // input itself.
                // The label contents could be text, html, or a mix. We wrap all elements
                // and read the wrapper's `innerHTML` to get a string representation of
                // the label, without the input as part of it.
                labelContents = this.label.contents().not(this.element[0]);

                if (labelContents.length) {
                    this.originalLabel += labelContents
                        .clone()
                        .wrapAll("<div></div>")
                        .parent()
                        .html();
                }

                // Set the label option if we found label text
                if (this.originalLabel) {
                    options.label = this.originalLabel;
                }

                disabled = this.element[0].disabled;
                if (disabled != null) {
                    options.disabled = disabled;
                }
                return options;
            },

            _create: function () {
                var checked = this.element[0].checked;

                this._bindFormResetHandler();

                if (this.options.disabled == null) {
                    this.options.disabled = this.element[0].disabled;
                }

                this._setOption("disabled", this.options.disabled);
                this._addClass(
                    "ui-checkboxradio",
                    "ui-helper-hidden-accessible"
                );
                this._addClass(
                    this.label,
                    "ui-checkboxradio-label",
                    "ui-button ui-widget"
                );

                if (this.type === "radio") {
                    this._addClass(this.label, "ui-checkboxradio-radio-label");
                }

                if (
                    this.options.label &&
                    this.options.label !== this.originalLabel
                ) {
                    this._updateLabel();
                } else if (this.originalLabel) {
                    this.options.label = this.originalLabel;
                }

                this._enhance();

                if (checked) {
                    this._addClass(
                        this.label,
                        "ui-checkboxradio-checked",
                        "ui-state-active"
                    );
                }

                this._on({
                    change: "_toggleClasses",
                    focus: function () {
                        this._addClass(
                            this.label,
                            null,
                            "ui-state-focus ui-visual-focus"
                        );
                    },
                    blur: function () {
                        this._removeClass(
                            this.label,
                            null,
                            "ui-state-focus ui-visual-focus"
                        );
                    },
                });
            },

            _readType: function () {
                var nodeName = this.element[0].nodeName.toLowerCase();
                this.type = this.element[0].type;
                if (nodeName !== "input" || !/radio|checkbox/.test(this.type)) {
                    $.error(
                        "Can't create checkboxradio on element.nodeName=" +
                            nodeName +
                            " and element.type=" +
                            this.type
                    );
                }
            },

            // Support jQuery Mobile enhanced option
            _enhance: function () {
                this._updateIcon(this.element[0].checked);
            },

            widget: function () {
                return this.label;
            },

            _getRadioGroup: function () {
                var group;
                var name = this.element[0].name;
                var nameSelector =
                    "input[name='" + $.escapeSelector(name) + "']";

                if (!name) {
                    return $([]);
                }

                if (this.form.length) {
                    group = $(this.form[0].elements).filter(nameSelector);
                } else {
                    // Not inside a form, check all inputs that also are not inside a form
                    group = $(nameSelector).filter(function () {
                        return $(this)._form().length === 0;
                    });
                }

                return group.not(this.element);
            },

            _toggleClasses: function () {
                var checked = this.element[0].checked;
                this._toggleClass(
                    this.label,
                    "ui-checkboxradio-checked",
                    "ui-state-active",
                    checked
                );

                if (this.options.icon && this.type === "checkbox") {
                    this._toggleClass(
                        this.icon,
                        null,
                        "ui-icon-check ui-state-checked",
                        checked
                    )._toggleClass(this.icon, null, "ui-icon-blank", !checked);
                }

                if (this.type === "radio") {
                    this._getRadioGroup().each(function () {
                        var instance = $(this).checkboxradio("instance");

                        if (instance) {
                            instance._removeClass(
                                instance.label,
                                "ui-checkboxradio-checked",
                                "ui-state-active"
                            );
                        }
                    });
                }
            },

            _destroy: function () {
                this._unbindFormResetHandler();

                if (this.icon) {
                    this.icon.remove();
                    this.iconSpace.remove();
                }
            },

            _setOption: function (key, value) {
                // We don't allow the value to be set to nothing
                if (key === "label" && !value) {
                    return;
                }

                this._super(key, value);

                if (key === "disabled") {
                    this._toggleClass(
                        this.label,
                        null,
                        "ui-state-disabled",
                        value
                    );
                    this.element[0].disabled = value;

                    // Don't refresh when setting disabled
                    return;
                }
                this.refresh();
            },

            _updateIcon: function (checked) {
                var toAdd = "ui-icon ui-icon-background ";

                if (this.options.icon) {
                    if (!this.icon) {
                        this.icon = $("<span>");
                        this.iconSpace = $("<span> </span>");
                        this._addClass(
                            this.iconSpace,
                            "ui-checkboxradio-icon-space"
                        );
                    }

                    if (this.type === "checkbox") {
                        toAdd += checked
                            ? "ui-icon-check ui-state-checked"
                            : "ui-icon-blank";
                        this._removeClass(
                            this.icon,
                            null,
                            checked ? "ui-icon-blank" : "ui-icon-check"
                        );
                    } else {
                        toAdd += "ui-icon-blank";
                    }
                    this._addClass(this.icon, "ui-checkboxradio-icon", toAdd);
                    if (!checked) {
                        this._removeClass(
                            this.icon,
                            null,
                            "ui-icon-check ui-state-checked"
                        );
                    }
                    this.icon.prependTo(this.label).after(this.iconSpace);
                } else if (this.icon !== undefined) {
                    this.icon.remove();
                    this.iconSpace.remove();
                    delete this.icon;
                }
            },

            _updateLabel: function () {
                // Remove the contents of the label ( minus the icon, icon space, and input )
                var contents = this.label.contents().not(this.element[0]);
                if (this.icon) {
                    contents = contents.not(this.icon[0]);
                }
                if (this.iconSpace) {
                    contents = contents.not(this.iconSpace[0]);
                }
                contents.remove();

                this.label.append(this.options.label);
            },

            refresh: function () {
                var checked = this.element[0].checked,
                    isDisabled = this.element[0].disabled;

                this._updateIcon(checked);
                this._toggleClass(
                    this.label,
                    "ui-checkboxradio-checked",
                    "ui-state-active",
                    checked
                );
                if (this.options.label !== null) {
                    this._updateLabel();
                }

                if (isDisabled !== this.options.disabled) {
                    this._setOptions({ disabled: isDisabled });
                }
            },
        },
    ]);

    var widgetsCheckboxradio = $.ui.checkboxradio;

    /*!
     * jQuery UI Button 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Button
    //>>group: Widgets
    //>>description: Enhances a form with themeable buttons.
    //>>docs: http://api.jqueryui.com/button/
    //>>demos: http://jqueryui.com/button/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/button.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.button", {
        version: "1.13.2",
        defaultElement: "<button>",
        options: {
            classes: {
                "ui-button": "ui-corner-all",
            },
            disabled: null,
            icon: null,
            iconPosition: "beginning",
            label: null,
            showLabel: true,
        },

        _getCreateOptions: function () {
            var disabled,
                // This is to support cases like in jQuery Mobile where the base widget does have
                // an implementation of _getCreateOptions
                options = this._super() || {};

            this.isInput = this.element.is("input");

            disabled = this.element[0].disabled;
            if (disabled != null) {
                options.disabled = disabled;
            }

            this.originalLabel = this.isInput
                ? this.element.val()
                : this.element.html();
            if (this.originalLabel) {
                options.label = this.originalLabel;
            }

            return options;
        },

        _create: function () {
            if (!this.option.showLabel & !this.options.icon) {
                this.options.showLabel = true;
            }

            // We have to check the option again here even though we did in _getCreateOptions,
            // because null may have been passed on init which would override what was set in
            // _getCreateOptions
            if (this.options.disabled == null) {
                this.options.disabled = this.element[0].disabled || false;
            }

            this.hasTitle = !!this.element.attr("title");

            // Check to see if the label needs to be set or if its already correct
            if (
                this.options.label &&
                this.options.label !== this.originalLabel
            ) {
                if (this.isInput) {
                    this.element.val(this.options.label);
                } else {
                    this.element.html(this.options.label);
                }
            }
            this._addClass("ui-button", "ui-widget");
            this._setOption("disabled", this.options.disabled);
            this._enhance();

            if (this.element.is("a")) {
                this._on({
                    keyup: function (event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            event.preventDefault();

                            // Support: PhantomJS <= 1.9, IE 8 Only
                            // If a native click is available use it so we actually cause navigation
                            // otherwise just trigger a click event
                            if (this.element[0].click) {
                                this.element[0].click();
                            } else {
                                this.element.trigger("click");
                            }
                        }
                    },
                });
            }
        },

        _enhance: function () {
            if (!this.element.is("button")) {
                this.element.attr("role", "button");
            }

            if (this.options.icon) {
                this._updateIcon("icon", this.options.icon);
                this._updateTooltip();
            }
        },

        _updateTooltip: function () {
            this.title = this.element.attr("title");

            if (!this.options.showLabel && !this.title) {
                this.element.attr("title", this.options.label);
            }
        },

        _updateIcon: function (option, value) {
            var icon = option !== "iconPosition",
                position = icon ? this.options.iconPosition : value,
                displayBlock = position === "top" || position === "bottom";

            // Create icon
            if (!this.icon) {
                this.icon = $("<span>");

                this._addClass(this.icon, "ui-button-icon", "ui-icon");

                if (!this.options.showLabel) {
                    this._addClass("ui-button-icon-only");
                }
            } else if (icon) {
                // If we are updating the icon remove the old icon class
                this._removeClass(this.icon, null, this.options.icon);
            }

            // If we are updating the icon add the new icon class
            if (icon) {
                this._addClass(this.icon, null, value);
            }

            this._attachIcon(position);

            // If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
            // the iconSpace if there is one.
            if (displayBlock) {
                this._addClass(this.icon, null, "ui-widget-icon-block");
                if (this.iconSpace) {
                    this.iconSpace.remove();
                }
            } else {
                // Position is beginning or end so remove the ui-widget-icon-block class and add the
                // space if it does not exist
                if (!this.iconSpace) {
                    this.iconSpace = $("<span> </span>");
                    this._addClass(this.iconSpace, "ui-button-icon-space");
                }
                this._removeClass(this.icon, null, "ui-wiget-icon-block");
                this._attachIconSpace(position);
            }
        },

        _destroy: function () {
            this.element.removeAttr("role");

            if (this.icon) {
                this.icon.remove();
            }
            if (this.iconSpace) {
                this.iconSpace.remove();
            }
            if (!this.hasTitle) {
                this.element.removeAttr("title");
            }
        },

        _attachIconSpace: function (iconPosition) {
            this.icon[
                /^(?:end|bottom)/.test(iconPosition) ? "before" : "after"
            ](this.iconSpace);
        },

        _attachIcon: function (iconPosition) {
            this.element[
                /^(?:end|bottom)/.test(iconPosition) ? "append" : "prepend"
            ](this.icon);
        },

        _setOptions: function (options) {
            var newShowLabel =
                    options.showLabel === undefined
                        ? this.options.showLabel
                        : options.showLabel,
                newIcon =
                    options.icon === undefined
                        ? this.options.icon
                        : options.icon;

            if (!newShowLabel && !newIcon) {
                options.showLabel = true;
            }
            this._super(options);
        },

        _setOption: function (key, value) {
            if (key === "icon") {
                if (value) {
                    this._updateIcon(key, value);
                } else if (this.icon) {
                    this.icon.remove();
                    if (this.iconSpace) {
                        this.iconSpace.remove();
                    }
                }
            }

            if (key === "iconPosition") {
                this._updateIcon(key, value);
            }

            // Make sure we can't end up with a button that has neither text nor icon
            if (key === "showLabel") {
                this._toggleClass("ui-button-icon-only", null, !value);
                this._updateTooltip();
            }

            if (key === "label") {
                if (this.isInput) {
                    this.element.val(value);
                } else {
                    // If there is an icon, append it, else nothing then append the value
                    // this avoids removal of the icon when setting label text
                    this.element.html(value);
                    if (this.icon) {
                        this._attachIcon(this.options.iconPosition);
                        this._attachIconSpace(this.options.iconPosition);
                    }
                }
            }

            this._super(key, value);

            if (key === "disabled") {
                this._toggleClass(null, "ui-state-disabled", value);
                this.element[0].disabled = value;
                if (value) {
                    this.element.trigger("blur");
                }
            }
        },

        refresh: function () {
            // Make sure to only check disabled if its an element that supports this otherwise
            // check for the disabled class to determine state
            var isDisabled = this.element.is("input, button")
                ? this.element[0].disabled
                : this.element.hasClass("ui-button-disabled");

            if (isDisabled !== this.options.disabled) {
                this._setOptions({ disabled: isDisabled });
            }

            this._updateTooltip();
        },
    });

    // DEPRECATED
    if ($.uiBackCompat !== false) {
        // Text and Icons options
        $.widget("ui.button", $.ui.button, {
            options: {
                text: true,
                icons: {
                    primary: null,
                    secondary: null,
                },
            },

            _create: function () {
                if (this.options.showLabel && !this.options.text) {
                    this.options.showLabel = this.options.text;
                }
                if (!this.options.showLabel && this.options.text) {
                    this.options.text = this.options.showLabel;
                }
                if (
                    !this.options.icon &&
                    (this.options.icons.primary || this.options.icons.secondary)
                ) {
                    if (this.options.icons.primary) {
                        this.options.icon = this.options.icons.primary;
                    } else {
                        this.options.icon = this.options.icons.secondary;
                        this.options.iconPosition = "end";
                    }
                } else if (this.options.icon) {
                    this.options.icons.primary = this.options.icon;
                }
                this._super();
            },

            _setOption: function (key, value) {
                if (key === "text") {
                    this._super("showLabel", value);
                    return;
                }
                if (key === "showLabel") {
                    this.options.text = value;
                }
                if (key === "icon") {
                    this.options.icons.primary = value;
                }
                if (key === "icons") {
                    if (value.primary) {
                        this._super("icon", value.primary);
                        this._super("iconPosition", "beginning");
                    } else if (value.secondary) {
                        this._super("icon", value.secondary);
                        this._super("iconPosition", "end");
                    }
                }
                this._superApply(arguments);
            },
        });

        $.fn.button = (function (orig) {
            return function (options) {
                var isMethodCall = typeof options === "string";
                var args = Array.prototype.slice.call(arguments, 1);
                var returnValue = this;

                if (isMethodCall) {
                    // If this is an empty collection, we need to have the instance method
                    // return undefined instead of the jQuery instance
                    if (!this.length && options === "instance") {
                        returnValue = undefined;
                    } else {
                        this.each(function () {
                            var methodValue;
                            var type = $(this).attr("type");
                            var name =
                                type !== "checkbox" && type !== "radio"
                                    ? "button"
                                    : "checkboxradio";
                            var instance = $.data(this, "ui-" + name);

                            if (options === "instance") {
                                returnValue = instance;
                                return false;
                            }

                            if (!instance) {
                                return $.error(
                                    "cannot call methods on button" +
                                        " prior to initialization; " +
                                        "attempted to call method '" +
                                        options +
                                        "'"
                                );
                            }

                            if (
                                typeof instance[options] !== "function" ||
                                options.charAt(0) === "_"
                            ) {
                                return $.error(
                                    "no such method '" +
                                        options +
                                        "' for button" +
                                        " widget instance"
                                );
                            }

                            methodValue = instance[options].apply(
                                instance,
                                args
                            );

                            if (
                                methodValue !== instance &&
                                methodValue !== undefined
                            ) {
                                returnValue =
                                    methodValue && methodValue.jquery
                                        ? returnValue.pushStack(
                                              methodValue.get()
                                          )
                                        : methodValue;
                                return false;
                            }
                        });
                    }
                } else {
                    // Allow multiple hashes to be passed on init
                    if (args.length) {
                        options = $.widget.extend.apply(
                            null,
                            [options].concat(args)
                        );
                    }

                    this.each(function () {
                        var type = $(this).attr("type");
                        var name =
                            type !== "checkbox" && type !== "radio"
                                ? "button"
                                : "checkboxradio";
                        var instance = $.data(this, "ui-" + name);

                        if (instance) {
                            instance.option(options || {});
                            if (instance._init) {
                                instance._init();
                            }
                        } else {
                            if (name === "button") {
                                orig.call($(this), options);
                                return;
                            }

                            $(this).checkboxradio(
                                $.extend({ icon: false }, options)
                            );
                        }
                    });
                }

                return returnValue;
            };
        })($.fn.button);

        $.fn.buttonset = function () {
            if (!$.ui.controlgroup) {
                $.error("Controlgroup widget missing");
            }
            if (
                arguments[0] === "option" &&
                arguments[1] === "items" &&
                arguments[2]
            ) {
                return this.controlgroup.apply(this, [
                    arguments[0],
                    "items.button",
                    arguments[2],
                ]);
            }
            if (arguments[0] === "option" && arguments[1] === "items") {
                return this.controlgroup.apply(this, [
                    arguments[0],
                    "items.button",
                ]);
            }
            if (typeof arguments[0] === "object" && arguments[0].items) {
                arguments[0].items = {
                    button: arguments[0].items,
                };
            }
            return this.controlgroup.apply(this, arguments);
        };
    }

    var widgetsButton = $.ui.button;

    /* eslint-disable max-len, camelcase */
    /*!
     * jQuery UI Datepicker 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Datepicker
    //>>group: Widgets
    //>>description: Displays a calendar from an input or inline for selecting dates.
    //>>docs: http://api.jqueryui.com/datepicker/
    //>>demos: http://jqueryui.com/datepicker/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/datepicker.css
    //>>css.theme: ../../themes/base/theme.css

    $.extend($.ui, { datepicker: { version: "1.13.2" } });

    var datepicker_instActive;

    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css("position");
            if (
                position === "absolute" ||
                position === "relative" ||
                position === "fixed"
            ) {
                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }

        return 0;
    }

    /* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[""] = {
            // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ], // Names of months for drop-down and formatting
            monthNamesShort: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ], // For formatting
            dayNames: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ], // For formatting
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "", // Additional text to append to the year in the month headers,
            selectMonthLabel: "Select month", // Invisible label for month selector
            selectYearLabel: "Select year", // Invisible label for year selector
        };
        this._defaults = {
            // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
            // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
            // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            onUpdateDatepicker: null, // Define a callback function when the datepicker is updated
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false, // The initial disabled state
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover(
            $(
                "<div id='" +
                    this._mainDivId +
                    "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"
            )
        );
    }

    $.extend(Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",

        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,

        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function () {
            return this.dpDiv;
        },

        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function (settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function (target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === "div" || nodeName === "span";
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },

        /* Create a new instance object. */
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
            return {
                id: id,
                input: target, // associated target
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0, // current selection
                drawMonth: 0,
                drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: !inline
                    ? this.dpDiv // presentation div
                    : datepicker_bindHover(
                          $(
                              "<div class='" +
                                  this._inlineClass +
                                  " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"
                          )
                      ),
            };
        },

        /* Attach the date picker to an input field. */
        _connectDatepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input
                .addClass(this.markerClassName)
                .on("keydown", this._doKeyDown)
                .on("keypress", this._doKeyPress)
                .on("keyup", this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);

            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },

        /* Make attachments based on settings. */
        _attachments: function (input, inst) {
            var showOn,
                buttonText,
                buttonImage,
                appendText = this._get(inst, "appendText"),
                isRTL = this._get(inst, "isRTL");

            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span>")
                    .addClass(this._appendClass)
                    .text(appendText);
                input[isRTL ? "before" : "after"](inst.append);
            }

            input.off("focus", this._showDatepicker);

            if (inst.trigger) {
                inst.trigger.remove();
            }

            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") {
                // pop-up date picker when in the marked field
                input.on("focus", this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") {
                // pop-up date picker when button clicked
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");

                if (this._get(inst, "buttonImageOnly")) {
                    inst.trigger = $("<img>")
                        .addClass(this._triggerClass)
                        .attr({
                            src: buttonImage,
                            alt: buttonText,
                            title: buttonText,
                        });
                } else {
                    inst.trigger = $("<button type='button'>").addClass(
                        this._triggerClass
                    );
                    if (buttonImage) {
                        inst.trigger.html(
                            $("<img>").attr({
                                src: buttonImage,
                                alt: buttonText,
                                title: buttonText,
                            })
                        );
                    } else {
                        inst.trigger.text(buttonText);
                    }
                }

                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.on("click", function () {
                    if (
                        $.datepicker._datepickerShowing &&
                        $.datepicker._lastInput === input[0]
                    ) {
                        $.datepicker._hideDatepicker();
                    } else if (
                        $.datepicker._datepickerShowing &&
                        $.datepicker._lastInput !== input[0]
                    ) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },

        /* Apply the maximum length for the date format. */
        _autoSize: function (inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax,
                    max,
                    maxI,
                    i,
                    date = new Date(2009, 12 - 1, 20), // Ensure double digits
                    dateFormat = this._get(inst, "dateFormat");

                if (dateFormat.match(/[DM]/)) {
                    findMax = function (names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(
                        findMax(
                            this._get(
                                inst,
                                dateFormat.match(/MM/)
                                    ? "monthNames"
                                    : "monthNamesShort"
                            )
                        )
                    );
                    date.setDate(
                        findMax(
                            this._get(
                                inst,
                                dateFormat.match(/DD/)
                                    ? "dayNames"
                                    : "dayNamesShort"
                            )
                        ) +
                            20 -
                            date.getDay()
                    );
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },

        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function (target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);

            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }

            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css("display", "block");
        },

        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date	string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *					event - with x/y coordinates or
         *					leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function (input, date, onSelect, settings, pos) {
            var id,
                browserWidth,
                browserHeight,
                scrollX,
                scrollY,
                inst = this._dialogInst; // internal instance

            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $(
                    "<input type='text' id='" +
                        id +
                        "' style='position: absolute; top: -100px; width: 0px;'/>"
                );
                this._dialogInput.on("keydown", this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(
                    this._dialogInput,
                    false
                );
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date =
                date && date.constructor === Date
                    ? this._formatDate(inst, date)
                    : date;
            this._dialogInput.val(date);

            this._pos = pos
                ? pos.length
                    ? pos
                    : [pos.pageX, pos.pageY]
                : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX =
                    document.documentElement.scrollLeft ||
                    document.body.scrollLeft;
                scrollY =
                    document.documentElement.scrollTop ||
                    document.body.scrollTop;
                this._pos =
                    // should use actual width/height below
                    [
                        browserWidth / 2 - 100 + scrollX,
                        browserHeight / 2 - 150 + scrollY,
                    ];
            }

            // Move input on screen for focus, but hidden behind dialog
            this._dialogInput
                .css("left", this._pos[0] + 20 + "px")
                .css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },

        /* Detach a datepicker from its control.
         * @param  target	element - the target input field or division or span
         */
        _destroyDatepicker: function (target) {
            var nodeName,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target
                    .removeClass(this.markerClassName)
                    .off("focus", this._showDatepicker)
                    .off("keydown", this._doKeyDown)
                    .off("keypress", this._doKeyPress)
                    .off("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }

            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
                this._curInst = null;
            }
        },

        /* Enable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _enableDatepicker: function (target) {
            var nodeName,
                inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger
                    .filter("button")
                    .each(function () {
                        this.disabled = false;
                    })
                    .end()
                    .filter("img")
                    .css({ opacity: "1.0", cursor: "" });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline
                    .find(
                        "select.ui-datepicker-month, select.ui-datepicker-year"
                    )
                    .prop("disabled", false);
            }
            this._disabledInputs = $.map(
                this._disabledInputs,

                // Delete entry
                function (value) {
                    return value === target ? null : value;
                }
            );
        },

        /* Disable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _disableDatepicker: function (target) {
            var nodeName,
                inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger
                    .filter("button")
                    .each(function () {
                        this.disabled = true;
                    })
                    .end()
                    .filter("img")
                    .css({ opacity: "0.5", cursor: "default" });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline
                    .find(
                        "select.ui-datepicker-month, select.ui-datepicker-year"
                    )
                    .prop("disabled", true);
            }
            this._disabledInputs = $.map(
                this._disabledInputs,

                // Delete entry
                function (value) {
                    return value === target ? null : value;
                }
            );
            this._disabledInputs[this._disabledInputs.length] = target;
        },

        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target	element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function (target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },

        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function (target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },

        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name	object - the new settings to update or
         *				string - the name of the setting to change or retrieve,
         *				when retrieving also "all" for all instance settings or
         *				"defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *				(omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function (target, name, value) {
            var settings,
                date,
                minDate,
                maxDate,
                inst = this._getInst(target);

            if (arguments.length === 2 && typeof name === "string") {
                return name === "defaults"
                    ? $.extend({}, $.datepicker._defaults)
                    : inst
                    ? name === "all"
                        ? $.extend({}, inst.settings)
                        : this._get(inst, name)
                    : null;
            }

            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }

            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }

                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);

                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if (
                    minDate !== null &&
                    settings.dateFormat !== undefined &&
                    settings.minDate === undefined
                ) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (
                    maxDate !== null &&
                    settings.dateFormat !== undefined &&
                    settings.maxDate === undefined
                ) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },

        // Change method deprecated
        _changeDatepicker: function (target, name, value) {
            this._optionDatepicker(target, name, value);
        },

        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function (target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },

        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date	Date - the new date
         */
        _setDateDatepicker: function (target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },

        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function (target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },

        /* Handle keystrokes. */
        _doKeyDown: function (event) {
            var onSelect,
                dateStr,
                sel,
                inst = $.datepicker._getInst(event.target),
                handled = true,
                isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                    case 9:
                        $.datepicker._hideDatepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13:
                        sel = $(
                            "td." +
                                $.datepicker._dayOverClass +
                                ":not(." +
                                $.datepicker._currentClass +
                                ")",
                            inst.dpDiv
                        );
                        if (sel[0]) {
                            $.datepicker._selectDay(
                                event.target,
                                inst.selectedMonth,
                                inst.selectedYear,
                                sel[0]
                            );
                        }

                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);

                            // Trigger custom callback
                            onSelect.apply(inst.input ? inst.input[0] : null, [
                                dateStr,
                                inst,
                            ]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }

                        return false; // don't submit the form
                    case 27:
                        $.datepicker._hideDatepicker();
                        break; // hide on escape
                    case 33:
                        $.datepicker._adjustDate(
                            event.target,
                            event.ctrlKey
                                ? -$.datepicker._get(inst, "stepBigMonths")
                                : -$.datepicker._get(inst, "stepMonths"),
                            "M"
                        );
                        break; // previous month/year on page up/+ ctrl
                    case 34:
                        $.datepicker._adjustDate(
                            event.target,
                            event.ctrlKey
                                ? +$.datepicker._get(inst, "stepBigMonths")
                                : +$.datepicker._get(inst, "stepMonths"),
                            "M"
                        );
                        break; // next month/year on page down/+ ctrl
                    case 35:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // clear on ctrl or command +end
                    case 36:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // current on ctrl or command +home
                    case 37:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(
                                event.target,
                                isRTL ? +1 : -1,
                                "D"
                            );
                        }
                        handled = event.ctrlKey || event.metaKey;

                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(
                                event.target,
                                event.ctrlKey
                                    ? -$.datepicker._get(inst, "stepBigMonths")
                                    : -$.datepicker._get(inst, "stepMonths"),
                                "M"
                            );
                        }

                        // next month/year on alt +left on Mac
                        break;
                    case 38:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // -1 week on ctrl or command +up
                    case 39:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(
                                event.target,
                                isRTL ? -1 : +1,
                                "D"
                            );
                        }
                        handled = event.ctrlKey || event.metaKey;

                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(
                                event.target,
                                event.ctrlKey
                                    ? +$.datepicker._get(inst, "stepBigMonths")
                                    : +$.datepicker._get(inst, "stepMonths"),
                                "M"
                            );
                        }

                        // next month/year on alt +right
                        break;
                    case 40:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // +1 week on ctrl or command +down
                    default:
                        handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                // display the date picker on ctrl+home
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Filter entered characters - based on date format. */
        _doKeyPress: function (event) {
            var chars,
                chr,
                inst = $.datepicker._getInst(event.target);

            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars(
                    $.datepicker._get(inst, "dateFormat")
                );
                chr = String.fromCharCode(
                    event.charCode == null ? event.keyCode : event.charCode
                );
                return (
                    event.ctrlKey ||
                    event.metaKey ||
                    chr < " " ||
                    !chars ||
                    chars.indexOf(chr) > -1
                );
            }
        },

        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function (event) {
            var date,
                inst = $.datepicker._getInst(event.target);

            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate(
                        $.datepicker._get(inst, "dateFormat"),
                        inst.input ? inst.input.val() : null,
                        $.datepicker._getFormatConfig(inst)
                    );

                    if (date) {
                        // only if valid
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },

        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *					event - if triggered by focus
         */
        _showDatepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") {
                // find from button/image trigger
                input = $("input", input.parentNode)[0];
            }

            if (
                $.datepicker._isDisabledDatepicker(input) ||
                $.datepicker._lastInput === input
            ) {
                // already here
                return;
            }

            var inst,
                beforeShow,
                beforeShowSettings,
                isFixed,
                offset,
                showAnim,
                duration;

            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker(
                        $.datepicker._curInst.input[0]
                    );
                }
            }

            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow
                ? beforeShow.apply(input, [input, inst])
                : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);

            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);

            if ($.datepicker._inDialog) {
                // hide cursor
                input.value = "";
            }
            if (!$.datepicker._pos) {
                // position below input
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight; // add the height
            }

            isFixed = false;
            $(input)
                .parents()
                .each(function () {
                    isFixed |= $(this).css("position") === "fixed";
                    return !isFixed;
                });

            offset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] };
            $.datepicker._pos = null;

            //to avoid flashes on Firefox
            inst.dpDiv.empty();

            // determine sizing offscreen
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px",
            });
            $.datepicker._updateDatepicker(inst);

            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position:
                    $.datepicker._inDialog && $.blockUI
                        ? "static"
                        : isFixed
                        ? "fixed"
                        : "absolute",
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px",
            });

            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;

                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(
                        showAnim,
                        $.datepicker._get(inst, "showOptions"),
                        duration
                    );
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }

                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.trigger("focus");
                }

                $.datepicker._curInst = inst;
            }
        },

        /* Generate the date picker content. */
        _updateDatepicker: function (inst) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            datepicker_instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);

            var origyearshtml,
                numMonths = this._getNumberOfMonths(inst),
                cols = numMonths[1],
                width = 17,
                activeCell = inst.dpDiv.find("." + this._dayOverClass + " a"),
                onUpdateDatepicker = $.datepicker._get(
                    inst,
                    "onUpdateDatepicker"
                );

            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }

            inst.dpDiv
                .removeClass(
                    "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4"
                )
                .width("");
            if (cols > 1) {
                inst.dpDiv
                    .addClass("ui-datepicker-multi-" + cols)
                    .css("width", width * cols + "em");
            }
            inst.dpDiv[
                (numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                    "Class"
            ]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"](
                "ui-datepicker-rtl"
            );

            if (
                inst === $.datepicker._curInst &&
                $.datepicker._datepickerShowing &&
                $.datepicker._shouldFocusInput(inst)
            ) {
                inst.input.trigger("focus");
            }

            // Deffered render of the years select (to avoid flashes on Firefox)
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function () {
                    //assure that inst.yearshtml didn't change.
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv
                            .find("select.ui-datepicker-year")
                            .first()
                            .replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }

            if (onUpdateDatepicker) {
                onUpdateDatepicker.apply(inst.input ? inst.input[0] : null, [
                    inst,
                ]);
            }
        },

        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function (inst) {
            return (
                inst.input &&
                inst.input.is(":visible") &&
                !inst.input.is(":disabled") &&
                !inst.input.is(":focus")
            );
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function (inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth =
                    document.documentElement.clientWidth +
                    (isFixed ? 0 : $(document).scrollLeft()),
                viewHeight =
                    document.documentElement.clientHeight +
                    (isFixed ? 0 : $(document).scrollTop());

            offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
            offset.left -=
                isFixed && offset.left === inst.input.offset().left
                    ? $(document).scrollLeft()
                    : 0;
            offset.top -=
                isFixed && offset.top === inst.input.offset().top + inputHeight
                    ? $(document).scrollTop()
                    : 0;

            // Now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(
                offset.left,
                offset.left + dpWidth > viewWidth && viewWidth > dpWidth
                    ? Math.abs(offset.left + dpWidth - viewWidth)
                    : 0
            );
            offset.top -= Math.min(
                offset.top,
                offset.top + dpHeight > viewHeight && viewHeight > dpHeight
                    ? Math.abs(dpHeight + inputHeight)
                    : 0
            );

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function (obj) {
            var position,
                inst = this._getInst(obj),
                isRTL = this._get(inst, "isRTL");

            while (
                obj &&
                (obj.type === "hidden" ||
                    obj.nodeType !== 1 ||
                    $.expr.pseudos.hidden(obj))
            ) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }

            position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function (input) {
            var showAnim,
                duration,
                postProcess,
                onClose,
                inst = this._curInst;

            if (!inst || (input && inst !== $.data(input, "datepicker"))) {
                return;
            }

            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function () {
                    $.datepicker._tidyDialog(inst);
                };

                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if (
                    $.effects &&
                    ($.effects.effect[showAnim] || $.effects[showAnim])
                ) {
                    inst.dpDiv.hide(
                        showAnim,
                        $.datepicker._get(inst, "showOptions"),
                        duration,
                        postProcess
                    );
                } else {
                    inst.dpDiv[
                        showAnim === "slideDown"
                            ? "slideUp"
                            : showAnim === "fadeIn"
                            ? "fadeOut"
                            : "hide"
                    ](showAnim ? duration : null, postProcess);
                }

                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;

                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [
                        inst.input ? inst.input.val() : "",
                        inst,
                    ]);
                }

                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px",
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },

        /* Tidy up after a dialog display. */
        _tidyDialog: function (inst) {
            inst.dpDiv
                .removeClass(this._dialogClass)
                .off(".ui-datepicker-calendar");
        },

        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function (event) {
            if (!$.datepicker._curInst) {
                return;
            }

            var $target = $(event.target),
                inst = $.datepicker._getInst($target[0]);

            if (
                ($target[0].id !== $.datepicker._mainDivId &&
                    $target.parents("#" + $.datepicker._mainDivId).length ===
                        0 &&
                    !$target.hasClass($.datepicker.markerClassName) &&
                    !$target.closest("." + $.datepicker._triggerClass).length &&
                    $.datepicker._datepickerShowing &&
                    !($.datepicker._inDialog && $.blockUI)) ||
                ($target.hasClass($.datepicker.markerClassName) &&
                    $.datepicker._curInst !== inst)
            ) {
                $.datepicker._hideDatepicker();
            }
        },

        /* Adjust one of the date sub-fields. */
        _adjustDate: function (id, offset, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset, period);
            this._updateDatepicker(inst);
        },

        /* Action for current link. */
        _gotoToday: function (id) {
            var date,
                target = $(id),
                inst = this._getInst(target[0]);

            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a new month/year. */
        _selectMonthYear: function (id, select, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            inst["selected" + (period === "M" ? "Month" : "Year")] = inst[
                "draw" + (period === "M" ? "Month" : "Year")
            ] = parseInt(select.options[select.selectedIndex].value, 10);

            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a day. */
        _selectDay: function (id, month, year, td) {
            var inst,
                target = $(id);

            if (
                $(td).hasClass(this._unselectableClass) ||
                this._isDisabledDatepicker(target[0])
            ) {
                return;
            }

            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = parseInt(
                $("a", td).attr("data-date")
            );
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(
                id,
                this._formatDate(
                    inst,
                    inst.currentDay,
                    inst.currentMonth,
                    inst.currentYear
                )
            );
        },

        /* Erase the input field and hide the date picker. */
        _clearDate: function (id) {
            var target = $(id);
            this._selectDate(target, "");
        },

        /* Update the input field with the selected date. */
        _selectDate: function (id, dateStr) {
            var onSelect,
                target = $(id),
                inst = this._getInst(target[0]);

            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);

            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [
                    dateStr,
                    inst,
                ]); // trigger custom callback
            } else if (inst.input) {
                inst.input.trigger("change"); // fire the change event
            }

            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== "object") {
                    inst.input.trigger("focus"); // restore focus
                }
                this._lastInput = null;
            }
        },

        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function (inst) {
            var altFormat,
                date,
                dateStr,
                altField = this._get(inst, "altField");

            if (altField) {
                // update alternate field too
                altFormat =
                    this._get(inst, "altFormat") ||
                    this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(
                    altFormat,
                    date,
                    this._getFormatConfig(inst)
                );
                $(document).find(altField).val(dateStr);
            }
        },

        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function (date) {
            var day = date.getDay();
            return [day > 0 && day < 6, ""];
        },

        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function (date) {
            var time,
                checkDate = new Date(date.getTime());

            // Find Thursday of this week starting on Monday
            checkDate.setDate(
                checkDate.getDate() + 4 - (checkDate.getDay() || 7)
            );

            time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return (
                Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1
            );
        },

        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *					shortYearCutoff  number - the cutoff year for determining the century (optional)
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function (format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }

            value = typeof value === "object" ? value.toString() : value + "";
            if (value === "") {
                return null;
            }

            var iFormat,
                dim,
                extra,
                iValue = 0,
                shortYearCutoffTemp =
                    (settings ? settings.shortYearCutoff : null) ||
                    this._defaults.shortYearCutoff,
                shortYearCutoff =
                    typeof shortYearCutoffTemp !== "string"
                        ? shortYearCutoffTemp
                        : (new Date().getFullYear() % 100) +
                          parseInt(shortYearCutoffTemp, 10),
                dayNamesShort =
                    (settings ? settings.dayNamesShort : null) ||
                    this._defaults.dayNamesShort,
                dayNames =
                    (settings ? settings.dayNames : null) ||
                    this._defaults.dayNames,
                monthNamesShort =
                    (settings ? settings.monthNamesShort : null) ||
                    this._defaults.monthNamesShort,
                monthNames =
                    (settings ? settings.monthNames : null) ||
                    this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches =
                        iFormat + 1 < format.length &&
                        format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Extract a number from the string value
                getNumber = function (match) {
                    var isDoubled = lookAhead(match),
                        size =
                            match === "@"
                                ? 14
                                : match === "!"
                                ? 20
                                : match === "y" && isDoubled
                                ? 4
                                : match === "o"
                                ? 3
                                : 2,
                        minSize = match === "y" ? size : 1,
                        digits = new RegExp(
                            "^\\d{" + minSize + "," + size + "}"
                        ),
                        num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                },
                // Extract a name from the string value and convert to an index
                getName = function (match, shortNames, longNames) {
                    var index = -1,
                        names = $.map(
                            lookAhead(match) ? longNames : shortNames,
                            function (v, k) {
                                return [[k, v]];
                            }
                        ).sort(function (a, b) {
                            return -(a[1].length - b[1].length);
                        });

                    $.each(names, function (i, pair) {
                        var name = pair[1];
                        if (
                            value.substr(iValue, name.length).toLowerCase() ===
                            name.toLowerCase()
                        ) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },
                // Confirm that a literal character matches the string value
                checkLiteral = function () {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            day = getNumber("d");
                            break;
                        case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;
                        case "o":
                            doy = getNumber("o");
                            break;
                        case "m":
                            month = getNumber("m");
                            break;
                        case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;
                        case "y":
                            year = getNumber("y");
                            break;
                        case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date(
                                (getNumber("!") - this._ticksTo1970) / 10000
                            );
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }

            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }

            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year +=
                    new Date().getFullYear() -
                    (new Date().getFullYear() % 100) +
                    (year <= shortYearCutoff ? 0 : -100);
            }

            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }

            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (
                date.getFullYear() !== year ||
                date.getMonth() + 1 !== month ||
                date.getDate() !== day
            ) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },

        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601

        _ticksTo1970:
            ((1970 - 1) * 365 +
                Math.floor(1970 / 4) -
                Math.floor(1970 / 100) +
                Math.floor(1970 / 400)) *
            24 *
            60 *
            60 *
            10000000,

        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function (format, date, settings) {
            if (!date) {
                return "";
            }

            var iFormat,
                dayNamesShort =
                    (settings ? settings.dayNamesShort : null) ||
                    this._defaults.dayNamesShort,
                dayNames =
                    (settings ? settings.dayNames : null) ||
                    this._defaults.dayNames,
                monthNamesShort =
                    (settings ? settings.monthNamesShort : null) ||
                    this._defaults.monthNamesShort,
                monthNames =
                    (settings ? settings.monthNames : null) ||
                    this._defaults.monthNames,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches =
                        iFormat + 1 < format.length &&
                        format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Format a number, with leading zero if necessary
                formatNumber = function (match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },
                // Format a name, short or long as requested
                formatName = function (match, value, shortNames, longNames) {
                    return lookAhead(match)
                        ? longNames[value]
                        : shortNames[value];
                },
                output = "",
                literal = false;

            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;
                            case "D":
                                output += formatName(
                                    "D",
                                    date.getDay(),
                                    dayNamesShort,
                                    dayNames
                                );
                                break;
                            case "o":
                                output += formatNumber(
                                    "o",
                                    Math.round(
                                        (new Date(
                                            date.getFullYear(),
                                            date.getMonth(),
                                            date.getDate()
                                        ).getTime() -
                                            new Date(
                                                date.getFullYear(),
                                                0,
                                                0
                                            ).getTime()) /
                                            86400000
                                    ),
                                    3
                                );
                                break;
                            case "m":
                                output += formatNumber(
                                    "m",
                                    date.getMonth() + 1,
                                    2
                                );
                                break;
                            case "M":
                                output += formatName(
                                    "M",
                                    date.getMonth(),
                                    monthNamesShort,
                                    monthNames
                                );
                                break;
                            case "y":
                                output += lookAhead("y")
                                    ? date.getFullYear()
                                    : (date.getFullYear() % 100 < 10
                                          ? "0"
                                          : "") +
                                      (date.getFullYear() % 100);
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output +=
                                    date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },

        /* Extract all possible characters from the date format. */
        _possibleChars: function (format) {
            var iFormat,
                chars = "",
                literal = false,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches =
                        iFormat + 1 < format.length &&
                        format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                        case "m":
                        case "y":
                        case "@":
                            chars += "0123456789";
                            break;
                        case "D":
                        case "M":
                            return null; // Accept anything
                        case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function (inst, name) {
            return inst.settings[name] !== undefined
                ? inst.settings[name]
                : this._defaults[name];
        },

        /* Parse existing date and initialise date picker. */
        _setDateFromField: function (inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }

            var dateFormat = this._get(inst, "dateFormat"),
                dates = (inst.lastVal = inst.input ? inst.input.val() : null),
                defaultDate = this._getDefaultDate(inst),
                date = defaultDate,
                settings = this._getFormatConfig(inst);

            try {
                date =
                    this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? "" : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },

        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function (inst) {
            return this._restrictMinMax(
                inst,
                this._determineDate(
                    inst,
                    this._get(inst, "defaultDate"),
                    new Date()
                )
            );
        },

        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function (inst, date, defaultDate) {
            var offsetNumeric = function (offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                },
                offsetString = function (offset) {
                    try {
                        return $.datepicker.parseDate(
                            $.datepicker._get(inst, "dateFormat"),
                            offset,
                            $.datepicker._getFormatConfig(inst)
                        );
                    } catch (e) {
                        // Ignore
                    }

                    var date =
                            (offset.toLowerCase().match(/^c/)
                                ? $.datepicker._getDate(inst)
                                : null) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec(offset);

                    while (matches) {
                        switch (matches[2] || "d") {
                            case "d":
                            case "D":
                                day += parseInt(matches[1], 10);
                                break;
                            case "w":
                            case "W":
                                day += parseInt(matches[1], 10) * 7;
                                break;
                            case "m":
                            case "M":
                                month += parseInt(matches[1], 10);
                                day = Math.min(
                                    day,
                                    $.datepicker._getDaysInMonth(year, month)
                                );
                                break;
                            case "y":
                            case "Y":
                                year += parseInt(matches[1], 10);
                                day = Math.min(
                                    day,
                                    $.datepicker._getDaysInMonth(year, month)
                                );
                                break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                },
                newDate =
                    date == null || date === ""
                        ? defaultDate
                        : typeof date === "string"
                        ? offsetString(date)
                        : typeof date === "number"
                        ? isNaN(date)
                            ? defaultDate
                            : offsetNumeric(date)
                        : new Date(date.getTime());

            newDate =
                newDate && newDate.toString() === "Invalid Date"
                    ? defaultDate
                    : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },

        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function (date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },

        /* Set the date(s) directly. */
        _setDate: function (inst, date, noChange) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax(
                    inst,
                    this._determineDate(inst, date, new Date())
                );

            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth =
                inst.selectedMonth =
                inst.currentMonth =
                    newDate.getMonth();
            inst.drawYear =
                inst.selectedYear =
                inst.currentYear =
                    newDate.getFullYear();
            if (
                (origMonth !== inst.selectedMonth ||
                    origYear !== inst.selectedYear) &&
                !noChange
            ) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },

        /* Retrieve the date(s) directly. */
        _getDate: function (inst) {
            var startDate =
                !inst.currentYear || (inst.input && inst.input.val() === "")
                    ? null
                    : this._daylightSavingAdjust(
                          new Date(
                              inst.currentYear,
                              inst.currentMonth,
                              inst.currentDay
                          )
                      );
            return startDate;
        },

        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function (inst) {
            var stepMonths = this._get(inst, "stepMonths"),
                id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function () {
                var handler = {
                    prev: function () {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function () {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function () {
                        $.datepicker._hideDatepicker();
                    },
                    today: function () {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function () {
                        $.datepicker._selectDay(
                            id,
                            +this.getAttribute("data-month"),
                            +this.getAttribute("data-year"),
                            this
                        );
                        return false;
                    },
                    selectMonth: function () {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function () {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    },
                };
                $(this).on(
                    this.getAttribute("data-event"),
                    handler[this.getAttribute("data-handler")]
                );
            });
        },

        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function (inst) {
            var maxDraw,
                prevText,
                prev,
                nextText,
                next,
                currentText,
                gotoDate,
                controls,
                buttonPanel,
                firstDay,
                showWeek,
                dayNames,
                dayNamesMin,
                monthNames,
                monthNamesShort,
                beforeShowDay,
                showOtherMonths,
                selectOtherMonths,
                defaultDate,
                html,
                dow,
                row,
                group,
                col,
                selectedDate,
                cornerClass,
                calender,
                thead,
                day,
                daysInMonth,
                leadDays,
                curRows,
                numRows,
                printDate,
                dRow,
                tbody,
                daySettings,
                otherMonth,
                unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date(
                        tempDate.getFullYear(),
                        tempDate.getMonth(),
                        tempDate.getDate()
                    )
                ), // clear time
                isRTL = this._get(inst, "isRTL"),
                showButtonPanel = this._get(inst, "showButtonPanel"),
                hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                navigationAsDateFormat = this._get(
                    inst,
                    "navigationAsDateFormat"
                ),
                numMonths = this._getNumberOfMonths(inst),
                showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                stepMonths = this._get(inst, "stepMonths"),
                isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1,
                currentDate = this._daylightSavingAdjust(
                    !inst.currentDay
                        ? new Date(9999, 9, 9)
                        : new Date(
                              inst.currentYear,
                              inst.currentMonth,
                              inst.currentDay
                          )
                ),
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;

            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(
                    new Date(
                        maxDate.getFullYear(),
                        maxDate.getMonth() - numMonths[0] * numMonths[1] + 1,
                        maxDate.getDate()
                    )
                );
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (
                    this._daylightSavingAdjust(
                        new Date(drawYear, drawMonth, 1)
                    ) > maxDraw
                ) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;

            prevText = this._get(inst, "prevText");
            prevText = !navigationAsDateFormat
                ? prevText
                : this.formatDate(
                      prevText,
                      this._daylightSavingAdjust(
                          new Date(drawYear, drawMonth - stepMonths, 1)
                      ),
                      this._getFormatConfig(inst)
                  );

            if (this._canAdjustMonth(inst, -1, drawYear, drawMonth)) {
                prev = $("<a>")
                    .attr({
                        class: "ui-datepicker-prev ui-corner-all",
                        "data-handler": "prev",
                        "data-event": "click",
                        title: prevText,
                    })
                    .append(
                        $("<span>")
                            .addClass(
                                "ui-icon ui-icon-circle-triangle-" +
                                    (isRTL ? "e" : "w")
                            )
                            .text(prevText)
                    )[0].outerHTML;
            } else if (hideIfNoPrevNext) {
                prev = "";
            } else {
                prev = $("<a>")
                    .attr({
                        class: "ui-datepicker-prev ui-corner-all ui-state-disabled",
                        title: prevText,
                    })
                    .append(
                        $("<span>")
                            .addClass(
                                "ui-icon ui-icon-circle-triangle-" +
                                    (isRTL ? "e" : "w")
                            )
                            .text(prevText)
                    )[0].outerHTML;
            }

            nextText = this._get(inst, "nextText");
            nextText = !navigationAsDateFormat
                ? nextText
                : this.formatDate(
                      nextText,
                      this._daylightSavingAdjust(
                          new Date(drawYear, drawMonth + stepMonths, 1)
                      ),
                      this._getFormatConfig(inst)
                  );

            if (this._canAdjustMonth(inst, +1, drawYear, drawMonth)) {
                next = $("<a>")
                    .attr({
                        class: "ui-datepicker-next ui-corner-all",
                        "data-handler": "next",
                        "data-event": "click",
                        title: nextText,
                    })
                    .append(
                        $("<span>")
                            .addClass(
                                "ui-icon ui-icon-circle-triangle-" +
                                    (isRTL ? "w" : "e")
                            )
                            .text(nextText)
                    )[0].outerHTML;
            } else if (hideIfNoPrevNext) {
                next = "";
            } else {
                next = $("<a>")
                    .attr({
                        class: "ui-datepicker-next ui-corner-all ui-state-disabled",
                        title: nextText,
                    })
                    .append(
                        $("<span>")
                            .attr(
                                "class",
                                "ui-icon ui-icon-circle-triangle-" +
                                    (isRTL ? "w" : "e")
                            )
                            .text(nextText)
                    )[0].outerHTML;
            }

            currentText = this._get(inst, "currentText");
            gotoDate =
                this._get(inst, "gotoCurrent") && inst.currentDay
                    ? currentDate
                    : today;
            currentText = !navigationAsDateFormat
                ? currentText
                : this.formatDate(
                      currentText,
                      gotoDate,
                      this._getFormatConfig(inst)
                  );

            controls = "";
            if (!inst.inline) {
                controls = $("<button>")
                    .attr({
                        type: "button",
                        class: "ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all",
                        "data-handler": "hide",
                        "data-event": "click",
                    })
                    .text(this._get(inst, "closeText"))[0].outerHTML;
            }

            buttonPanel = "";
            if (showButtonPanel) {
                buttonPanel = $(
                    "<div class='ui-datepicker-buttonpane ui-widget-content'>"
                )
                    .append(isRTL ? controls : "")
                    .append(
                        this._isInRange(inst, gotoDate)
                            ? $("<button>")
                                  .attr({
                                      type: "button",
                                      class: "ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all",
                                      "data-handler": "today",
                                      "data-event": "click",
                                  })
                                  .text(currentText)
                            : ""
                    )
                    .append(isRTL ? "" : controls)[0].outerHTML;
            }

            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;

            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";

            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(
                        new Date(drawYear, drawMonth, inst.selectedDay)
                    );
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                                case 0:
                                    calender += " ui-datepicker-group-first";
                                    cornerClass =
                                        " ui-corner-" +
                                        (isRTL ? "right" : "left");
                                    break;
                                case numMonths[1] - 1:
                                    calender += " ui-datepicker-group-last";
                                    cornerClass =
                                        " ui-corner-" +
                                        (isRTL ? "left" : "right");
                                    break;
                                default:
                                    calender += " ui-datepicker-group-middle";
                                    cornerClass = "";
                                    break;
                            }
                        }
                        calender += "'>";
                    }
                    calender +=
                        "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" +
                        cornerClass +
                        "'>" +
                        (/all|left/.test(cornerClass) && row === 0
                            ? isRTL
                                ? next
                                : prev
                            : "") +
                        (/all|right/.test(cornerClass) && row === 0
                            ? isRTL
                                ? prev
                                : next
                            : "") +
                        this._generateMonthYearHeader(
                            inst,
                            drawMonth,
                            drawYear,
                            minDate,
                            maxDate,
                            row > 0 || col > 0,
                            monthNames,
                            monthNamesShort
                        ) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = showWeek
                        ? "<th class='ui-datepicker-week-col'>" +
                          this._get(inst, "weekHeader") +
                          "</th>"
                        : "";
                    for (dow = 0; dow < 7; dow++) {
                        // days of the week
                        day = (dow + firstDay) % 7;
                        thead +=
                            "<th scope='col'" +
                            ((dow + firstDay + 6) % 7 >= 5
                                ? " class='ui-datepicker-week-end'"
                                : "") +
                            ">" +
                            "<span title='" +
                            dayNames[day] +
                            "'>" +
                            dayNamesMin[day] +
                            "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (
                        drawYear === inst.selectedYear &&
                        drawMonth === inst.selectedMonth
                    ) {
                        inst.selectedDay = Math.min(
                            inst.selectedDay,
                            daysInMonth
                        );
                    }
                    leadDays =
                        (this._getFirstDayOfMonth(drawYear, drawMonth) -
                            firstDay +
                            7) %
                        7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                    numRows = isMultiMonth
                        ? this.maxRows > curRows
                            ? this.maxRows
                            : curRows
                        : curRows; //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(
                        new Date(drawYear, drawMonth, 1 - leadDays)
                    );
                    for (dRow = 0; dRow < numRows; dRow++) {
                        // create date picker rows
                        calender += "<tr>";
                        tbody = !showWeek
                            ? ""
                            : "<td class='ui-datepicker-week-col'>" +
                              this._get(inst, "calculateWeek")(printDate) +
                              "</td>";
                        for (dow = 0; dow < 7; dow++) {
                            // create date picker days
                            daySettings = beforeShowDay
                                ? beforeShowDay.apply(
                                      inst.input ? inst.input[0] : null,
                                      [printDate]
                                  )
                                : [true, ""];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable =
                                (otherMonth && !selectOtherMonths) ||
                                !daySettings[0] ||
                                (minDate && printDate < minDate) ||
                                (maxDate && printDate > maxDate);
                            tbody +=
                                "<td class='" +
                                ((dow + firstDay + 6) % 7 >= 5
                                    ? " ui-datepicker-week-end"
                                    : "") + // highlight weekends
                                (otherMonth
                                    ? " ui-datepicker-other-month"
                                    : "") + // highlight days from other months
                                ((printDate.getTime() ===
                                    selectedDate.getTime() &&
                                    drawMonth === inst.selectedMonth &&
                                    inst._keyEvent) || // user pressed key
                                (defaultDate.getTime() ===
                                    printDate.getTime() &&
                                    defaultDate.getTime() ===
                                        selectedDate.getTime())
                                    ? // or defaultDate is current printedDate and defaultDate is selectedDate
                                      " " + this._dayOverClass
                                    : "") + // highlight selected day
                                (unselectable
                                    ? " " +
                                      this._unselectableClass +
                                      " ui-state-disabled"
                                    : "") + // highlight unselectable days
                                (otherMonth && !showOtherMonths
                                    ? ""
                                    : " " +
                                      daySettings[1] + // highlight custom dates
                                      (printDate.getTime() ===
                                      currentDate.getTime()
                                          ? " " + this._currentClass
                                          : "") + // highlight selected day
                                      (printDate.getTime() === today.getTime()
                                          ? " ui-datepicker-today"
                                          : "")) +
                                "'" + // highlight today (if different)
                                ((!otherMonth || showOtherMonths) &&
                                daySettings[2]
                                    ? " title='" +
                                      daySettings[2].replace(/'/g, "&#39;") +
                                      "'"
                                    : "") + // cell title
                                (unselectable
                                    ? ""
                                    : " data-handler='selectDay' data-event='click' data-month='" +
                                      printDate.getMonth() +
                                      "' data-year='" +
                                      printDate.getFullYear() +
                                      "'") +
                                ">" + // actions
                                (otherMonth && !showOtherMonths
                                    ? "&#xa0;" // display for other months
                                    : unselectable
                                    ? "<span class='ui-state-default'>" +
                                      printDate.getDate() +
                                      "</span>"
                                    : "<a class='ui-state-default" +
                                      (printDate.getTime() === today.getTime()
                                          ? " ui-state-highlight"
                                          : "") +
                                      (printDate.getTime() ===
                                      currentDate.getTime()
                                          ? " ui-state-active"
                                          : "") + // highlight selected day
                                      (otherMonth
                                          ? " ui-priority-secondary"
                                          : "") + // distinguish dates from other months
                                      "' href='#' aria-current='" +
                                      (printDate.getTime() ===
                                      currentDate.getTime()
                                          ? "true"
                                          : "false") + // mark date as selected for screen reader
                                      "' data-date='" +
                                      printDate.getDate() + // store date as data
                                      "'>" +
                                      printDate.getDate() +
                                      "</a>") +
                                "</td>"; // display selectable date
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender +=
                        "</tbody></table>" +
                        (isMultiMonth
                            ? "</div>" +
                              (numMonths[0] > 0 && col === numMonths[1] - 1
                                  ? "<div class='ui-datepicker-row-break'></div>"
                                  : "")
                            : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },

        /* Generate the month and year header. */
        _generateMonthYearHeader: function (
            inst,
            drawMonth,
            drawYear,
            minDate,
            maxDate,
            secondary,
            monthNames,
            monthNamesShort
        ) {
            var inMinYear,
                inMaxYear,
                month,
                years,
                thisYear,
                determineYear,
                year,
                endYear,
                changeMonth = this._get(inst, "changeMonth"),
                changeYear = this._get(inst, "changeYear"),
                showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                selectMonthLabel = this._get(inst, "selectMonthLabel"),
                selectYearLabel = this._get(inst, "selectYearLabel"),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";

            // Month selection
            if (secondary || !changeMonth) {
                monthHtml +=
                    "<span class='ui-datepicker-month'>" +
                    monthNames[drawMonth] +
                    "</span>";
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml +=
                    "<select class='ui-datepicker-month' aria-label='" +
                    selectMonthLabel +
                    "' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if (
                        (!inMinYear || month >= minDate.getMonth()) &&
                        (!inMaxYear || month <= maxDate.getMonth())
                    ) {
                        monthHtml +=
                            "<option value='" +
                            month +
                            "'" +
                            (month === drawMonth
                                ? " selected='selected'"
                                : "") +
                            ">" +
                            monthNamesShort[month] +
                            "</option>";
                    }
                }
                monthHtml += "</select>";
            }

            if (!showMonthAfterYear) {
                html +=
                    monthHtml +
                    (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }

            // Year selection
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html +=
                        "<span class='ui-datepicker-year'>" +
                        drawYear +
                        "</span>";
                } else {
                    // determine range of years to display
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function (value) {
                        var year = value.match(/c[+\-].*/)
                            ? drawYear + parseInt(value.substring(1), 10)
                            : value.match(/[+\-].*/)
                            ? thisYear + parseInt(value, 10)
                            : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = minDate
                        ? Math.max(year, minDate.getFullYear())
                        : year;
                    endYear = maxDate
                        ? Math.min(endYear, maxDate.getFullYear())
                        : endYear;
                    inst.yearshtml +=
                        "<select class='ui-datepicker-year' aria-label='" +
                        selectYearLabel +
                        "' data-handler='selectYear' data-event='change'>";
                    for (; year <= endYear; year++) {
                        inst.yearshtml +=
                            "<option value='" +
                            year +
                            "'" +
                            (year === drawYear ? " selected='selected'" : "") +
                            ">" +
                            year +
                            "</option>";
                    }
                    inst.yearshtml += "</select>";

                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }

            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html +=
                    (secondary || !(changeMonth && changeYear)
                        ? "&#xa0;"
                        : "") + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },

        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function (inst, offset, period) {
            var year = inst.selectedYear + (period === "Y" ? offset : 0),
                month = inst.selectedMonth + (period === "M" ? offset : 0),
                day =
                    Math.min(
                        inst.selectedDay,
                        this._getDaysInMonth(year, month)
                    ) + (period === "D" ? offset : 0),
                date = this._restrictMinMax(
                    inst,
                    this._daylightSavingAdjust(new Date(year, month, day))
                );

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },

        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function (inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },

        /* Notify change of month/year. */
        _notifyChange: function (inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [
                    inst.selectedYear,
                    inst.selectedMonth + 1,
                    inst,
                ]);
            }
        },

        /* Determine the number of months to show. */
        _getNumberOfMonths: function (inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return numMonths == null
                ? [1, 1]
                : typeof numMonths === "number"
                ? [1, numMonths]
                : numMonths;
        },

        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function (inst, minMax) {
            return this._determineDate(
                inst,
                this._get(inst, minMax + "Date"),
                null
            );
        },

        /* Find the number of days in a given month. */
        _getDaysInMonth: function (year, month) {
            return (
                32 -
                this._daylightSavingAdjust(new Date(year, month, 32)).getDate()
            );
        },

        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function (year, month) {
            return new Date(year, month, 1).getDay();
        },

        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function (inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst),
                date = this._daylightSavingAdjust(
                    new Date(
                        curYear,
                        curMonth +
                            (offset < 0 ? offset : numMonths[0] * numMonths[1]),
                        1
                    )
                );

            if (offset < 0) {
                date.setDate(
                    this._getDaysInMonth(date.getFullYear(), date.getMonth())
                );
            }
            return this._isInRange(inst, date);
        },

        /* Is the given date in the accepted range? */
        _isInRange: function (inst, date) {
            var yearSplit,
                currentYear,
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                minYear = null,
                maxYear = null,
                years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }

            return (
                (!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()) &&
                (!minYear || date.getFullYear() >= minYear) &&
                (!maxYear || date.getFullYear() <= maxYear)
            );
        },

        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function (inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff =
                typeof shortYearCutoff !== "string"
                    ? shortYearCutoff
                    : (new Date().getFullYear() % 100) +
                      parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames"),
            };
        },

        /* Format the given date for display. */
        _formatDate: function (inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day
                ? typeof day === "object"
                    ? day
                    : this._daylightSavingAdjust(new Date(year, month, day))
                : this._daylightSavingAdjust(
                      new Date(
                          inst.currentYear,
                          inst.currentMonth,
                          inst.currentDay
                      )
                  );
            return this.formatDate(
                this._get(inst, "dateFormat"),
                date,
                this._getFormatConfig(inst)
            );
        },
    });

    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function datepicker_bindHover(dpDiv) {
        var selector =
            "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv
            .on("mouseout", selector, function () {
                $(this).removeClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).removeClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).removeClass("ui-datepicker-next-hover");
                }
            })
            .on("mouseover", selector, datepicker_handleMouseover);
    }

    function datepicker_handleMouseover() {
        if (
            !$.datepicker._isDisabledDatepicker(
                datepicker_instActive.inline
                    ? datepicker_instActive.dpDiv.parent()[0]
                    : datepicker_instActive.input[0]
            )
        ) {
            $(this)
                .parents(".ui-datepicker-calendar")
                .find("a")
                .removeClass("ui-state-hover");
            $(this).addClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).addClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).addClass("ui-datepicker-next-hover");
            }
        }
    }

    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }

    /* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
    $.fn.datepicker = function (options) {
        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if (!this.length) {
            return this;
        }

        /* Initialise the date picker. */
        if (!$.datepicker.initialized) {
            $(document).on("mousedown", $.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }

        /* Append datepicker main container to body if not exist. */
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (
            typeof options === "string" &&
            (options === "isDisabled" ||
                options === "getDate" ||
                options === "widget")
        ) {
            return $.datepicker["_" + options + "Datepicker"].apply(
                $.datepicker,
                [this[0]].concat(otherArgs)
            );
        }
        if (
            options === "option" &&
            arguments.length === 2 &&
            typeof arguments[1] === "string"
        ) {
            return $.datepicker["_" + options + "Datepicker"].apply(
                $.datepicker,
                [this[0]].concat(otherArgs)
            );
        }
        return this.each(function () {
            if (typeof options === "string") {
                $.datepicker["_" + options + "Datepicker"].apply(
                    $.datepicker,
                    [this].concat(otherArgs)
                );
            } else {
                $.datepicker._attachDatepicker(this, options);
            }
        });
    };

    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.13.2";

    var widgetsDatepicker = $.datepicker;

    // This file is deprecated
    var ie = ($.ui.ie = !!/msie [\w.]+/.exec(
        navigator.userAgent.toLowerCase()
    ));

    /*!
     * jQuery UI Mouse 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Mouse
    //>>group: Widgets
    //>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
    //>>docs: http://api.jqueryui.com/mouse/

    var mouseHandled = false;
    $(document).on("mouseup", function () {
        mouseHandled = false;
    });

    var widgetsMouse = $.widget("ui.mouse", {
        version: "1.13.2",
        options: {
            cancel: "input, textarea, button, select, option",
            distance: 1,
            delay: 0,
        },
        _mouseInit: function () {
            var that = this;

            this.element
                .on("mousedown." + this.widgetName, function (event) {
                    return that._mouseDown(event);
                })
                .on("click." + this.widgetName, function (event) {
                    if (
                        true ===
                        $.data(
                            event.target,
                            that.widgetName + ".preventClickEvent"
                        )
                    ) {
                        $.removeData(
                            event.target,
                            that.widgetName + ".preventClickEvent"
                        );
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function () {
            this.element.off("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                this.document
                    .off(
                        "mousemove." + this.widgetName,
                        this._mouseMoveDelegate
                    )
                    .off("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function (event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) {
                return;
            }

            this._mouseMoved = false;

            // We may have missed mouseup (out of window)
            if (this._mouseStarted) {
                this._mouseUp(event);
            }

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = event.which === 1,
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel =
                    typeof this.options.cancel === "string" &&
                    event.target.nodeName
                        ? $(event.target).closest(this.options.cancel).length
                        : false;
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function () {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(event) !== false;
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (
                true ===
                $.data(event.target, this.widgetName + ".preventClickEvent")
            ) {
                $.removeData(
                    event.target,
                    this.widgetName + ".preventClickEvent"
                );
            }

            // These delegates are required to keep context
            this._mouseMoveDelegate = function (event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function (event) {
                return that._mouseUp(event);
            };

            this.document
                .on("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .on("mouseup." + this.widgetName, this._mouseUpDelegate);

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function (event) {
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if (this._mouseMoved) {
                // IE mouseup check - mouseup happened when mouse was out of window
                if (
                    $.ui.ie &&
                    (!document.documentMode || document.documentMode < 9) &&
                    !event.button
                ) {
                    return this._mouseUp(event);

                    // Iframe mouseup check - mouseup occurred in another document
                } else if (!event.which) {
                    // Support: Safari <=8 - 9
                    // Safari sets which to 0 if you press any of the following keys
                    // during a drag (#14461)
                    if (
                        event.originalEvent.altKey ||
                        event.originalEvent.ctrlKey ||
                        event.originalEvent.metaKey ||
                        event.originalEvent.shiftKey
                    ) {
                        this.ignoreMissingWhich = true;
                    } else if (!this.ignoreMissingWhich) {
                        return this._mouseUp(event);
                    }
                }
            }

            if (event.which || event.button) {
                this._mouseMoved = true;
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    this._mouseStart(this._mouseDownEvent, event) !== false;
                if (this._mouseStarted) {
                    this._mouseDrag(event);
                } else {
                    this._mouseUp(event);
                }
            }

            return !this._mouseStarted;
        },

        _mouseUp: function (event) {
            this.document
                .off("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .off("mouseup." + this.widgetName, this._mouseUpDelegate);

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(
                        event.target,
                        this.widgetName + ".preventClickEvent",
                        true
                    );
                }

                this._mouseStop(event);
            }

            if (this._mouseDelayTimer) {
                clearTimeout(this._mouseDelayTimer);
                delete this._mouseDelayTimer;
            }

            this.ignoreMissingWhich = false;
            mouseHandled = false;
            event.preventDefault();
        },

        _mouseDistanceMet: function (event) {
            return (
                Math.max(
                    Math.abs(this._mouseDownEvent.pageX - event.pageX),
                    Math.abs(this._mouseDownEvent.pageY - event.pageY)
                ) >= this.options.distance
            );
        },

        _mouseDelayMet: function (/* event */) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function (/* event */) {},
        _mouseDrag: function (/* event */) {},
        _mouseStop: function (/* event */) {},
        _mouseCapture: function (/* event */) {
            return true;
        },
    });

    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    var plugin = ($.ui.plugin = {
        add: function (module, option, set) {
            var i,
                proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([option, set[i]]);
            }
        },
        call: function (instance, name, args, allowDisconnected) {
            var i,
                set = instance.plugins[name];

            if (!set) {
                return;
            }

            if (
                !allowDisconnected &&
                (!instance.element[0].parentNode ||
                    instance.element[0].parentNode.nodeType === 11)
            ) {
                return;
            }

            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        },
    });

    var safeBlur = ($.ui.safeBlur = function (element) {
        // Support: IE9 - 10 only
        // If the <body> is blurred, IE will switch windows, see #9420
        if (element && element.nodeName.toLowerCase() !== "body") {
            $(element).trigger("blur");
        }
    });

    /*!
     * jQuery UI Draggable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Draggable
    //>>group: Interactions
    //>>description: Enables dragging functionality for any element.
    //>>docs: http://api.jqueryui.com/draggable/
    //>>demos: http://jqueryui.com/draggable/
    //>>css.structure: ../../themes/base/draggable.css

    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.13.2",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // Callbacks
            drag: null,
            start: null,
            stop: null,
        },
        _create: function () {
            if (this.options.helper === "original") {
                this._setPositionRelative();
            }
            if (this.options.addClasses) {
                this._addClass("ui-draggable");
            }
            this._setHandleClassName();

            this._mouseInit();
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },

        _destroy: function () {
            if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                this.destroyOnClear = true;
                return;
            }
            this._removeHandleClassName();
            this._mouseDestroy();
        },

        _mouseCapture: function (event) {
            var o = this.options;

            // Among others, prevent a drag on a resizable-handle
            if (
                this.helper ||
                o.disabled ||
                $(event.target).closest(".ui-resizable-handle").length > 0
            ) {
                return false;
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }

            this._blurActiveElement(event);

            this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);

            return true;
        },

        _blockFrames: function (selector) {
            this.iframeBlocks = this.document.find(selector).map(function () {
                var iframe = $(this);

                return $("<div>")
                    .css("position", "absolute")
                    .appendTo(iframe.parent())
                    .outerWidth(iframe.outerWidth())
                    .outerHeight(iframe.outerHeight())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function () {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _blurActiveElement: function (event) {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
                target = $(event.target);

            // Don't blur if the event occurred on an element that is within
            // the currently focused element
            // See #10527, #12472
            if (target.closest(activeElement).length) {
                return;
            }

            // Blur any element that currently has focus, see #4261
            $.ui.safeBlur(activeElement);
        },

        _mouseStart: function (event) {
            var o = this.options;

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            this._addClass(this.helper, "ui-draggable-dragging");

            //Cache the helper size
            this._cacheHelperProportions();

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Store the helper's css position
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent(true);
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor =
                this.helper.parents().filter(function () {
                    return $(this).css("position") === "fixed";
                }).length > 0;

            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset();
            this._refreshOffsets(event);

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition(
                event,
                false
            );
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            if (o.cursorAt) {
                this._adjustOffsetFromHelper(o.cursorAt);
            }

            //Set a containment if given in the options
            this._setContainment();

            //Trigger event + callbacks
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }

            //Recache the helper size
            this._cacheHelperProportions();

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            // Execute the drag once - this causes the helper not to be visible before getting its
            // correct position
            this._mouseDrag(event, true);

            // If the ddmanager is used for droppables, inform the manager that dragging has started
            // (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }

            return true;
        },

        _refreshOffsets: function (event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset(),
            };

            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top,
            };
        },

        _mouseDrag: function (event, noPropagation) {
            // reset any necessary cached properties (see #5009)
            if (this.hasFixedAncestor) {
                this.offset.parent = this._getParentOffset();
            }

            //Compute the helpers position
            this.position = this._generatePosition(event, true);
            this.positionAbs = this._convertPositionTo("absolute");

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp(new $.Event("mouseup", event));
                    return false;
                }
                this.position = ui.position;
            }

            this.helper[0].style.left = this.position.left + "px";
            this.helper[0].style.top = this.position.top + "px";

            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            return false;
        },

        _mouseStop: function (event) {
            //If we are using droppables, inform the manager about the drop
            var that = this,
                dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }

            if (
                (this.options.revert === "invalid" && !dropped) ||
                (this.options.revert === "valid" && dropped) ||
                this.options.revert === true ||
                (typeof this.options.revert === "function" &&
                    this.options.revert.call(this.element, dropped))
            ) {
                $(this.helper).animate(
                    this.originalPosition,
                    parseInt(this.options.revertDuration, 10),
                    function () {
                        if (that._trigger("stop", event) !== false) {
                            that._clear();
                        }
                    }
                );
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }

            return false;
        },

        _mouseUp: function (event) {
            this._unblockFrames();

            // If the ddmanager is used for droppables, inform the manager that dragging has stopped
            // (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }

            // Only need to focus if the event occurred on the draggable itself, see #10527
            if (this.handleElement.is(event.target)) {
                // The interaction is over; whether or not the click resulted in a drag,
                // focus the element
                this.element.trigger("focus");
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },

        cancel: function () {
            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp(
                    new $.Event("mouseup", { target: this.element[0] })
                );
            } else {
                this._clear();
            }

            return this;
        },

        _getHandle: function (event) {
            return this.options.handle
                ? !!$(event.target).closest(
                      this.element.find(this.options.handle)
                  ).length
                : true;
        },

        _setHandleClassName: function () {
            this.handleElement = this.options.handle
                ? this.element.find(this.options.handle)
                : this.element;
            this._addClass(this.handleElement, "ui-draggable-handle");
        },

        _removeHandleClassName: function () {
            this._removeClass(this.handleElement, "ui-draggable-handle");
        },

        _createHelper: function (event) {
            var o = this.options,
                helperIsFunction = typeof o.helper === "function",
                helper = helperIsFunction
                    ? $(o.helper.apply(this.element[0], [event]))
                    : o.helper === "clone"
                    ? this.element.clone().removeAttr("id")
                    : this.element;

            if (!helper.parents("body").length) {
                helper.appendTo(
                    o.appendTo === "parent"
                        ? this.element[0].parentNode
                        : o.appendTo
                );
            }

            // Http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if (helperIsFunction && helper[0] === this.element[0]) {
                this._setPositionRelative();
            }

            if (
                helper[0] !== this.element[0] &&
                !/(fixed|absolute)/.test(helper.css("position"))
            ) {
                helper.css("position", "absolute");
            }

            return helper;
        },

        _setPositionRelative: function () {
            if (!/^(?:r|a|f)/.test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if (Array.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left =
                    this.helperProportions.width -
                    obj.right +
                    this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top =
                    this.helperProportions.height -
                    obj.bottom +
                    this.margins.top;
            }
        },

        _isRootNode: function (element) {
            return (
                /(html|body)/i.test(element.tagName) ||
                element === this.document[0]
            );
        },

        _getParentOffset: function () {
            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
                document = this.document[0];

            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if (
                this.cssPosition === "absolute" &&
                this.scrollParent[0] !== document &&
                $.contains(this.scrollParent[0], this.offsetParent[0])
            ) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            if (this._isRootNode(this.offsetParent[0])) {
                po = { top: 0, left: 0 };
            }

            return {
                top:
                    po.top +
                    (parseInt(this.offsetParent.css("borderTopWidth"), 10) ||
                        0),
                left:
                    po.left +
                    (parseInt(this.offsetParent.css("borderLeftWidth"), 10) ||
                        0),
            };
        },

        _getRelativeOffset: function () {
            if (this.cssPosition !== "relative") {
                return { top: 0, left: 0 };
            }

            var p = this.element.position(),
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);

            return {
                top:
                    p.top -
                    (parseInt(this.helper.css("top"), 10) || 0) +
                    (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                left:
                    p.left -
                    (parseInt(this.helper.css("left"), 10) || 0) +
                    (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0),
            };
        },

        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0,
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight(),
            };
        },

        _setContainment: function () {
            var isUserScrollable,
                c,
                ce,
                o = this.options,
                document = this.document[0];

            this.relativeContainer = null;

            if (!o.containment) {
                this.containment = null;
                return;
            }

            if (o.containment === "window") {
                this.containment = [
                    $(window).scrollLeft() -
                        this.offset.relative.left -
                        this.offset.parent.left,
                    $(window).scrollTop() -
                        this.offset.relative.top -
                        this.offset.parent.top,
                    $(window).scrollLeft() +
                        $(window).width() -
                        this.helperProportions.width -
                        this.margins.left,
                    $(window).scrollTop() +
                        ($(window).height() ||
                            document.body.parentNode.scrollHeight) -
                        this.helperProportions.height -
                        this.margins.top,
                ];
                return;
            }

            if (o.containment === "document") {
                this.containment = [
                    0,
                    0,
                    $(document).width() -
                        this.helperProportions.width -
                        this.margins.left,
                    ($(document).height() ||
                        document.body.parentNode.scrollHeight) -
                        this.helperProportions.height -
                        this.margins.top,
                ];
                return;
            }

            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return;
            }

            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }

            c = $(o.containment);
            ce = c[0];

            if (!ce) {
                return;
            }

            isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));

            this.containment = [
                (parseInt(c.css("borderLeftWidth"), 10) || 0) +
                    (parseInt(c.css("paddingLeft"), 10) || 0),
                (parseInt(c.css("borderTopWidth"), 10) || 0) +
                    (parseInt(c.css("paddingTop"), 10) || 0),
                (isUserScrollable
                    ? Math.max(ce.scrollWidth, ce.offsetWidth)
                    : ce.offsetWidth) -
                    (parseInt(c.css("borderRightWidth"), 10) || 0) -
                    (parseInt(c.css("paddingRight"), 10) || 0) -
                    this.helperProportions.width -
                    this.margins.left -
                    this.margins.right,
                (isUserScrollable
                    ? Math.max(ce.scrollHeight, ce.offsetHeight)
                    : ce.offsetHeight) -
                    (parseInt(c.css("borderBottomWidth"), 10) || 0) -
                    (parseInt(c.css("paddingBottom"), 10) || 0) -
                    this.helperProportions.height -
                    this.margins.top -
                    this.margins.bottom,
            ];
            this.relativeContainer = c;
        },

        _convertPositionTo: function (d, pos) {
            if (!pos) {
                pos = this.position;
            }

            var mod = d === "absolute" ? 1 : -1,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);

            return {
                top:
                    // The absolute mouse position
                    pos.top +
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top * mod +
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top * mod -
                    (this.cssPosition === "fixed"
                        ? -this.offset.scroll.top
                        : scrollIsRootNode
                        ? 0
                        : this.offset.scroll.top) *
                        mod,
                left:
                    // The absolute mouse position
                    pos.left +
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left * mod +
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left * mod -
                    (this.cssPosition === "fixed"
                        ? -this.offset.scroll.left
                        : scrollIsRootNode
                        ? 0
                        : this.offset.scroll.left) *
                        mod,
            };
        },

        _generatePosition: function (event, constrainPosition) {
            var containment,
                co,
                top,
                left,
                o = this.options,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
                pageX = event.pageX,
                pageY = event.pageY;

            // Cache the scroll
            if (!scrollIsRootNode || !this.offset.scroll) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft(),
                };
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            // If we are not dragging yet, we won't check for options
            if (constrainPosition) {
                if (this.containment) {
                    if (this.relativeContainer) {
                        co = this.relativeContainer.offset();
                        containment = [
                            this.containment[0] + co.left,
                            this.containment[1] + co.top,
                            this.containment[2] + co.left,
                            this.containment[3] + co.top,
                        ];
                    } else {
                        containment = this.containment;
                    }

                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
                    // argument errors in IE (see ticket #6950)
                    top = o.grid[1]
                        ? this.originalPageY +
                          Math.round((pageY - this.originalPageY) / o.grid[1]) *
                              o.grid[1]
                        : this.originalPageY;
                    pageY = containment
                        ? top - this.offset.click.top >= containment[1] ||
                          top - this.offset.click.top > containment[3]
                            ? top
                            : top - this.offset.click.top >= containment[1]
                            ? top - o.grid[1]
                            : top + o.grid[1]
                        : top;

                    left = o.grid[0]
                        ? this.originalPageX +
                          Math.round((pageX - this.originalPageX) / o.grid[0]) *
                              o.grid[0]
                        : this.originalPageX;
                    pageX = containment
                        ? left - this.offset.click.left >= containment[0] ||
                          left - this.offset.click.left > containment[2]
                            ? left
                            : left - this.offset.click.left >= containment[0]
                            ? left - o.grid[0]
                            : left + o.grid[0]
                        : left;
                }

                if (o.axis === "y") {
                    pageX = this.originalPageX;
                }

                if (o.axis === "x") {
                    pageY = this.originalPageY;
                }
            }

            return {
                top:
                    // The absolute mouse position
                    pageY -
                    // Click offset (relative to the element)
                    this.offset.click.top -
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top -
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top +
                    (this.cssPosition === "fixed"
                        ? -this.offset.scroll.top
                        : scrollIsRootNode
                        ? 0
                        : this.offset.scroll.top),
                left:
                    // The absolute mouse position
                    pageX -
                    // Click offset (relative to the element)
                    this.offset.click.left -
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left -
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left +
                    (this.cssPosition === "fixed"
                        ? -this.offset.scroll.left
                        : scrollIsRootNode
                        ? 0
                        : this.offset.scroll.left),
            };
        },

        _clear: function () {
            this._removeClass(this.helper, "ui-draggable-dragging");
            if (
                this.helper[0] !== this.element[0] &&
                !this.cancelHelperRemoval
            ) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if (this.destroyOnClear) {
                this.destroy();
            }
        },

        // From now on bulk stuff - mainly helpers

        _trigger: function (type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [event, ui, this], true);

            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if (/^(drag|start|stop)/.test(type)) {
                this.positionAbs = this._convertPositionTo("absolute");
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },

        plugins: {},

        _uiHash: function () {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs,
            };
        },
    });

    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element,
            });

            draggable.sortables = [];
            $(draggable.options.connectToSortable).each(function () {
                var sortable = $(this).sortable("instance");

                if (sortable && !sortable.options.disabled) {
                    draggable.sortables.push(sortable);

                    // RefreshPositions is called at drag start to refresh the containerCache
                    // which is used in drag. This ensures it's initialized and synchronized
                    // with any changes that might have happened on the page since initialization.
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element,
            });

            draggable.cancelHelperRemoval = false;

            $.each(draggable.sortables, function () {
                var sortable = this;

                if (sortable.isOver) {
                    sortable.isOver = 0;

                    // Allow this sortable to handle removing the helper
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;

                    // Use _storedCSS To restore properties in the sortable,
                    // as this also handles revert (#9675) since the draggable
                    // may have modified them in unexpected ways (#8809)
                    sortable._storedCSS = {
                        position: sortable.placeholder.css("position"),
                        top: sortable.placeholder.css("top"),
                        left: sortable.placeholder.css("left"),
                    };

                    sortable._mouseStop(event);

                    // Once drag has ended, the sortable should return to using
                    // its original helper, not the shared helper from draggable
                    sortable.options.helper = sortable.options._helper;
                } else {
                    // Prevent this Sortable from removing the helper.
                    // However, don't set the draggable to remove the helper
                    // either as another connected Sortable may yet handle the removal.
                    sortable.cancelHelperRemoval = true;

                    sortable._trigger("deactivate", event, uiSortable);
                }
            });
        },
        drag: function (event, ui, draggable) {
            $.each(draggable.sortables, function () {
                var innermostIntersecting = false,
                    sortable = this;

                // Copy over variables that sortable's _intersectsWith uses
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;

                if (sortable._intersectsWith(sortable.containerCache)) {
                    innermostIntersecting = true;

                    $.each(draggable.sortables, function () {
                        // Copy over variables that sortable's _intersectsWith uses
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;

                        if (
                            this !== sortable &&
                            this._intersectsWith(this.containerCache) &&
                            $.contains(sortable.element[0], this.element[0])
                        ) {
                            innermostIntersecting = false;
                        }

                        return innermostIntersecting;
                    });
                }

                if (innermostIntersecting) {
                    // If it intersects, we use a little isOver variable and set it once,
                    // so that the move-in stuff gets fired only once.
                    if (!sortable.isOver) {
                        sortable.isOver = 1;

                        // Store draggable's parent in case we need to reappend to it later.
                        draggable._parent = ui.helper.parent();

                        sortable.currentItem = ui.helper
                            .appendTo(sortable.element)
                            .data("ui-sortable-item", true);

                        // Store helper option to later restore it
                        sortable.options._helper = sortable.options.helper;

                        sortable.options.helper = function () {
                            return ui.helper[0];
                        };

                        // Fire the start events of the sortable with our passed browser event,
                        // and our own helper (so it doesn't create a new one)
                        event.target = sortable.currentItem[0];
                        sortable._mouseCapture(event, true);
                        sortable._mouseStart(event, true, true);

                        // Because the browser event is way off the new appended portlet,
                        // modify necessary variables to reflect the changes
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left =
                            draggable.offset.click.left;
                        sortable.offset.parent.left -=
                            draggable.offset.parent.left -
                            sortable.offset.parent.left;
                        sortable.offset.parent.top -=
                            draggable.offset.parent.top -
                            sortable.offset.parent.top;

                        draggable._trigger("toSortable", event);

                        // Inform draggable that the helper is in a valid drop zone,
                        // used solely in the revert option to handle "valid/invalid".
                        draggable.dropped = sortable.element;

                        // Need to refreshPositions of all sortables in the case that
                        // adding to one sortable changes the location of the other sortables (#9675)
                        $.each(draggable.sortables, function () {
                            this.refreshPositions();
                        });

                        // Hack so receive/update callbacks work (mostly)
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }

                    if (sortable.currentItem) {
                        sortable._mouseDrag(event);

                        // Copy the sortable's position because the draggable's can potentially reflect
                        // a relative position, while sortable is always absolute, which the dragged
                        // element has now become. (#8809)
                        ui.position = sortable.position;
                    }
                } else {
                    // If it doesn't intersect with the sortable, and it intersected before,
                    // we fake the drag stop of the sortable, but make sure it doesn't remove
                    // the helper by using cancelHelperRemoval.
                    if (sortable.isOver) {
                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;

                        // Calling sortable's mouseStop would trigger a revert,
                        // so revert must be temporarily false until after mouseStop is called.
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;

                        sortable._trigger(
                            "out",
                            event,
                            sortable._uiHash(sortable)
                        );
                        sortable._mouseStop(event, true);

                        // Restore sortable behaviors that were modfied
                        // when the draggable entered the sortable area (#9481)
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;

                        if (sortable.placeholder) {
                            sortable.placeholder.remove();
                        }

                        // Restore and recalculate the draggable's offset considering the sortable
                        // may have modified them in unexpected ways. (#8809, #10669)
                        ui.helper.appendTo(draggable._parent);
                        draggable._refreshOffsets(event);
                        ui.position = draggable._generatePosition(event, true);

                        draggable._trigger("fromSortable", event);

                        // Inform draggable that the helper is no longer in a valid drop zone
                        draggable.dropped = false;

                        // Need to refreshPositions of all sortables just in case removing
                        // from one sortable changes the location of other sortables (#9675)
                        $.each(draggable.sortables, function () {
                            this.refreshPositions();
                        });
                    }
                }
            });
        },
    });

    $.ui.plugin.add("draggable", "cursor", {
        start: function (event, ui, instance) {
            var t = $("body"),
                o = instance.options;

            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function (event, ui, instance) {
            var o = instance.options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        },
    });

    $.ui.plugin.add("draggable", "opacity", {
        start: function (event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function (event, ui, instance) {
            var o = instance.options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        },
    });

    $.ui.plugin.add("draggable", "scroll", {
        start: function (event, ui, i) {
            if (!i.scrollParentNotHidden) {
                i.scrollParentNotHidden = i.helper.scrollParent(false);
            }

            if (
                i.scrollParentNotHidden[0] !== i.document[0] &&
                i.scrollParentNotHidden[0].tagName !== "HTML"
            ) {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function (event, ui, i) {
            var o = i.options,
                scrolled = false,
                scrollParent = i.scrollParentNotHidden[0],
                document = i.document[0];

            if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                if (!o.axis || o.axis !== "x") {
                    if (
                        i.overflowOffset.top +
                            scrollParent.offsetHeight -
                            event.pageY <
                        o.scrollSensitivity
                    ) {
                        scrollParent.scrollTop = scrolled =
                            scrollParent.scrollTop + o.scrollSpeed;
                    } else if (
                        event.pageY - i.overflowOffset.top <
                        o.scrollSensitivity
                    ) {
                        scrollParent.scrollTop = scrolled =
                            scrollParent.scrollTop - o.scrollSpeed;
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if (
                        i.overflowOffset.left +
                            scrollParent.offsetWidth -
                            event.pageX <
                        o.scrollSensitivity
                    ) {
                        scrollParent.scrollLeft = scrolled =
                            scrollParent.scrollLeft + o.scrollSpeed;
                    } else if (
                        event.pageX - i.overflowOffset.left <
                        o.scrollSensitivity
                    ) {
                        scrollParent.scrollLeft = scrolled =
                            scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }
            } else {
                if (!o.axis || o.axis !== "x") {
                    if (
                        event.pageY - $(document).scrollTop() <
                        o.scrollSensitivity
                    ) {
                        scrolled = $(document).scrollTop(
                            $(document).scrollTop() - o.scrollSpeed
                        );
                    } else if (
                        $(window).height() -
                            (event.pageY - $(document).scrollTop()) <
                        o.scrollSensitivity
                    ) {
                        scrolled = $(document).scrollTop(
                            $(document).scrollTop() + o.scrollSpeed
                        );
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if (
                        event.pageX - $(document).scrollLeft() <
                        o.scrollSensitivity
                    ) {
                        scrolled = $(document).scrollLeft(
                            $(document).scrollLeft() - o.scrollSpeed
                        );
                    } else if (
                        $(window).width() -
                            (event.pageX - $(document).scrollLeft()) <
                        o.scrollSensitivity
                    ) {
                        scrolled = $(document).scrollLeft(
                            $(document).scrollLeft() + o.scrollSpeed
                        );
                    }
                }
            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }
        },
    });

    $.ui.plugin.add("draggable", "snap", {
        start: function (event, ui, i) {
            var o = i.options;

            i.snapElements = [];

            $(
                o.snap.constructor !== String
                    ? o.snap.items || ":data(ui-draggable)"
                    : o.snap
            ).each(function () {
                var $t = $(this),
                    $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(),
                        height: $t.outerHeight(),
                        top: $o.top,
                        left: $o.left,
                    });
                }
            });
        },
        drag: function (event, ui, inst) {
            var ts,
                bs,
                ls,
                rs,
                l,
                r,
                t,
                b,
                i,
                first,
                o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left,
                x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top,
                y2 = y1 + inst.helperProportions.height;

            for (i = inst.snapElements.length - 1; i >= 0; i--) {
                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;

                if (
                    x2 < l - d ||
                    x1 > r + d ||
                    y2 < t - d ||
                    y1 > b + d ||
                    !$.contains(
                        inst.snapElements[i].item.ownerDocument,
                        inst.snapElements[i].item
                    )
                ) {
                    if (inst.snapElements[i].snapping) {
                        if (inst.options.snap.release) {
                            inst.options.snap.release.call(
                                inst.element,
                                event,
                                $.extend(inst._uiHash(), {
                                    snapItem: inst.snapElements[i].item,
                                })
                            );
                        }
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }

                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t - inst.helperProportions.height,
                            left: 0,
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b,
                            left: 0,
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l - inst.helperProportions.width,
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r,
                        }).left;
                    }
                }

                first = ts || bs || ls || rs;

                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t,
                            left: 0,
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b - inst.helperProportions.height,
                            left: 0,
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l,
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r - inst.helperProportions.width,
                        }).left;
                    }
                }

                if (
                    !inst.snapElements[i].snapping &&
                    (ts || bs || ls || rs || first)
                ) {
                    if (inst.options.snap.snap) {
                        inst.options.snap.snap.call(
                            inst.element,
                            event,
                            $.extend(inst._uiHash(), {
                                snapItem: inst.snapElements[i].item,
                            })
                        );
                    }
                }
                inst.snapElements[i].snapping = ts || bs || ls || rs || first;
            }
        },
    });

    $.ui.plugin.add("draggable", "stack", {
        start: function (event, ui, instance) {
            var min,
                o = instance.options,
                group = $.makeArray($(o.stack)).sort(function (a, b) {
                    return (
                        (parseInt($(a).css("zIndex"), 10) || 0) -
                        (parseInt($(b).css("zIndex"), 10) || 0)
                    );
                });

            if (!group.length) {
                return;
            }

            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function (i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", min + group.length);
        },
    });

    $.ui.plugin.add("draggable", "zIndex", {
        start: function (event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;

            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function (event, ui, instance) {
            var o = instance.options;

            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        },
    });

    var widgetsDraggable = $.ui.draggable;

    /*!
     * jQuery UI Resizable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Resizable
    //>>group: Interactions
    //>>description: Enables resize functionality for any element.
    //>>docs: http://api.jqueryui.com/resizable/
    //>>demos: http://jqueryui.com/resizable/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/resizable.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.13.2",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            classes: {
                "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se",
            },
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,

            // See #7960
            zIndex: 90,

            // Callbacks
            resize: null,
            start: null,
            stop: null,
        },

        _num: function (value) {
            return parseFloat(value) || 0;
        },

        _isNumber: function (value) {
            return !isNaN(parseFloat(value));
        },

        _hasScroll: function (el, a) {
            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = a && a === "left" ? "scrollLeft" : "scrollTop",
                has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            try {
                el[scroll] = 1;
                has = el[scroll] > 0;
                el[scroll] = 0;
            } catch (e) {
                // `el` might be a string, then setting `scroll` will throw
                // an error in strict mode; ignore it.
            }
            return has;
        },

        _create: function () {
            var margins,
                o = this.options,
                that = this;
            this._addClass("ui-resizable");

            $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper:
                    o.helper || o.ghost || o.animate
                        ? o.helper || "ui-resizable-helper"
                        : null,
            });

            // Wrap the element if it cannot hold child nodes
            if (
                this.element[0].nodeName.match(
                    /^(canvas|textarea|input|select|button|img)$/i
                )
            ) {
                this.element.wrap(
                    $("<div class='ui-wrapper'></div>").css({
                        overflow: "hidden",
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left"),
                    })
                );

                this.element = this.element
                    .parent()
                    .data("ui-resizable", this.element.resizable("instance"));

                this.elementIsWrapper = true;

                margins = {
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom"),
                    marginLeft: this.originalElement.css("marginLeft"),
                };

                this.element.css(margins);
                this.originalElement.css("margin", 0);

                // support: Safari
                // Prevent Safari textarea resize
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");

                this._proportionallyResizeElements.push(
                    this.originalElement.css({
                        position: "static",
                        zoom: 1,
                        display: "block",
                    })
                );

                // Support: IE9
                // avoid IE jump (hard set the margin)
                this.originalElement.css(margins);

                this._proportionallyResize();
            }

            this._setupHandles();

            if (o.autoHide) {
                $(this.element)
                    .on("mouseenter", function () {
                        if (o.disabled) {
                            return;
                        }
                        that._removeClass("ui-resizable-autohide");
                        that._handles.show();
                    })
                    .on("mouseleave", function () {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            that._addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
            }

            this._mouseInit();
        },

        _destroy: function () {
            this._mouseDestroy();
            this._addedHandles.remove();

            var wrapper,
                _destroy = function (exp) {
                    $(exp)
                        .removeData("resizable")
                        .removeData("ui-resizable")
                        .off(".resizable");
                };

            // TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement
                    .css({
                        position: wrapper.css("position"),
                        width: wrapper.outerWidth(),
                        height: wrapper.outerHeight(),
                        top: wrapper.css("top"),
                        left: wrapper.css("left"),
                    })
                    .insertAfter(wrapper);
                wrapper.remove();
            }

            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);

            return this;
        },

        _setOption: function (key, value) {
            this._super(key, value);

            switch (key) {
                case "handles":
                    this._removeHandles();
                    this._setupHandles();
                    break;
                case "aspectRatio":
                    this._aspectRatio = !!value;
                    break;
                default:
                    break;
            }
        },

        _setupHandles: function () {
            var o = this.options,
                handle,
                i,
                n,
                hname,
                axis,
                that = this;
            this.handles =
                o.handles ||
                (!$(".ui-resizable-handle", this.element).length
                    ? "e,s,se"
                    : {
                          n: ".ui-resizable-n",
                          e: ".ui-resizable-e",
                          s: ".ui-resizable-s",
                          w: ".ui-resizable-w",
                          se: ".ui-resizable-se",
                          sw: ".ui-resizable-sw",
                          ne: ".ui-resizable-ne",
                          nw: ".ui-resizable-nw",
                      });

            this._handles = $();
            this._addedHandles = $();
            if (this.handles.constructor === String) {
                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }

                n = this.handles.split(",");
                this.handles = {};

                for (i = 0; i < n.length; i++) {
                    handle = String.prototype.trim.call(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div>");
                    this._addClass(axis, "ui-resizable-handle " + hname);

                    axis.css({ zIndex: o.zIndex });

                    this.handles[handle] = ".ui-resizable-" + handle;
                    if (!this.element.children(this.handles[handle]).length) {
                        this.element.append(axis);
                        this._addedHandles = this._addedHandles.add(axis);
                    }
                }
            }

            this._renderAxis = function (target) {
                var i, axis, padPos, padWrapper;

                target = target || this.element;

                for (i in this.handles) {
                    if (this.handles[i].constructor === String) {
                        this.handles[i] = this.element
                            .children(this.handles[i])
                            .first()
                            .show();
                    } else if (
                        this.handles[i].jquery ||
                        this.handles[i].nodeType
                    ) {
                        this.handles[i] = $(this.handles[i]);
                        this._on(this.handles[i], {
                            mousedown: that._mouseDown,
                        });
                    }

                    if (
                        this.elementIsWrapper &&
                        this.originalElement[0].nodeName.match(
                            /^(textarea|input|select|button)$/i
                        )
                    ) {
                        axis = $(this.handles[i], this.element);

                        padWrapper = /sw|ne|nw|se|n|s/.test(i)
                            ? axis.outerHeight()
                            : axis.outerWidth();

                        padPos = [
                            "padding",
                            /ne|nw|n/.test(i)
                                ? "Top"
                                : /se|sw|s/.test(i)
                                ? "Bottom"
                                : /^e$/.test(i)
                                ? "Right"
                                : "Left",
                        ].join("");

                        target.css(padPos, padWrapper);

                        this._proportionallyResize();
                    }

                    this._handles = this._handles.add(this.handles[i]);
                }
            };

            // TODO: make renderAxis a prototype function
            this._renderAxis(this.element);

            this._handles = this._handles.add(
                this.element.find(".ui-resizable-handle")
            );
            this._handles.disableSelection();

            this._handles.on("mouseover", function () {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(
                            /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i
                        );
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });

            if (o.autoHide) {
                this._handles.hide();
                this._addClass("ui-resizable-autohide");
            }
        },

        _removeHandles: function () {
            this._addedHandles.remove();
        },

        _mouseCapture: function (event) {
            var i,
                handle,
                capture = false;

            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (
                    handle === event.target ||
                    $.contains(handle, event.target)
                ) {
                    capture = true;
                }
            }

            return !this.options.disabled && capture;
        },

        _mouseStart: function (event) {
            var curleft,
                curtop,
                cursor,
                o = this.options,
                el = this.element;

            this.resizing = true;

            this._renderProxy();

            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));

            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }

            this.offset = this.helper.offset();
            this.position = { left: curleft, top: curtop };

            this.size = this._helper
                ? {
                      width: this.helper.width(),
                      height: this.helper.height(),
                  }
                : {
                      width: el.width(),
                      height: el.height(),
                  };

            this.originalSize = this._helper
                ? {
                      width: el.outerWidth(),
                      height: el.outerHeight(),
                  }
                : {
                      width: el.width(),
                      height: el.height(),
                  };

            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height(),
            };

            this.originalPosition = { left: curleft, top: curtop };
            this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY,
            };

            this.aspectRatio =
                typeof o.aspectRatio === "number"
                    ? o.aspectRatio
                    : this.originalSize.width / this.originalSize.height || 1;

            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css(
                "cursor",
                cursor === "auto" ? this.axis + "-resize" : cursor
            );

            this._addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },

        _mouseDrag: function (event) {
            var data,
                props,
                smp = this.originalMousePosition,
                a = this.axis,
                dx = event.pageX - smp.left || 0,
                dy = event.pageY - smp.top || 0,
                trigger = this._change[a];

            this._updatePrevProperties();

            if (!trigger) {
                return false;
            }

            data = trigger.apply(this, [event, dx, dy]);

            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }

            data = this._respectSize(data, event);

            this._updateCache(data);

            this._propagate("resize", event);

            props = this._applyChanges();

            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }

            if (!$.isEmptyObject(props)) {
                this._updatePrevProperties();
                this._trigger("resize", event, this.ui());
                this._applyChanges();
            }

            return false;
        },

        _mouseStop: function (event) {
            this.resizing = false;
            var pr,
                ista,
                soffseth,
                soffsetw,
                s,
                left,
                top,
                o = this.options,
                that = this;

            if (this._helper) {
                pr = this._proportionallyResizeElements;
                ista = pr.length && /textarea/i.test(pr[0].nodeName);
                soffseth =
                    ista && this._hasScroll(pr[0], "left")
                        ? 0
                        : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;

                s = {
                    width: that.helper.width() - soffsetw,
                    height: that.helper.height() - soffseth,
                };
                left =
                    parseFloat(that.element.css("left")) +
                        (that.position.left - that.originalPosition.left) ||
                    null;
                top =
                    parseFloat(that.element.css("top")) +
                        (that.position.top - that.originalPosition.top) || null;

                if (!o.animate) {
                    this.element.css($.extend(s, { top: top, left: left }));
                }

                that.helper.height(that.size.height);
                that.helper.width(that.size.width);

                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }

            $("body").css("cursor", "auto");

            this._removeClass("ui-resizable-resizing");

            this._propagate("stop", event);

            if (this._helper) {
                this.helper.remove();
            }

            return false;
        },

        _updatePrevProperties: function () {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left,
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height,
            };
        },

        _applyChanges: function () {
            var props = {};

            if (this.position.top !== this.prevPosition.top) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== this.prevPosition.left) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== this.prevSize.width) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== this.prevSize.height) {
                props.height = this.size.height + "px";
            }

            this.helper.css(props);

            return props;
        },

        _updateVirtualBoundaries: function (forceAspectRatio) {
            var pMinWidth,
                pMaxWidth,
                pMinHeight,
                pMaxHeight,
                b,
                o = this.options;

            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity,
            };

            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;

                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },

        _updateCache: function (data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (this._isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (this._isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (this._isNumber(data.width)) {
                this.size.width = data.width;
            }
        },

        _updateRatio: function (data) {
            var cpos = this.position,
                csize = this.size,
                a = this.axis;

            if (this._isNumber(data.height)) {
                data.width = data.height * this.aspectRatio;
            } else if (this._isNumber(data.width)) {
                data.height = data.width / this.aspectRatio;
            }

            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }

            return data;
        },

        _respectSize: function (data) {
            var o = this._vBoundaries,
                a = this.axis,
                ismaxw =
                    this._isNumber(data.width) &&
                    o.maxWidth &&
                    o.maxWidth < data.width,
                ismaxh =
                    this._isNumber(data.height) &&
                    o.maxHeight &&
                    o.maxHeight < data.height,
                isminw =
                    this._isNumber(data.width) &&
                    o.minWidth &&
                    o.minWidth > data.width,
                isminh =
                    this._isNumber(data.height) &&
                    o.minHeight &&
                    o.minHeight > data.height,
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.originalPosition.top + this.originalSize.height,
                cw = /sw|nw|w/.test(a),
                ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }

            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }

            // Fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }

            return data;
        },

        _getPaddingPlusBorderDimensions: function (element) {
            var i = 0,
                widths = [],
                borders = [
                    element.css("borderTopWidth"),
                    element.css("borderRightWidth"),
                    element.css("borderBottomWidth"),
                    element.css("borderLeftWidth"),
                ],
                paddings = [
                    element.css("paddingTop"),
                    element.css("paddingRight"),
                    element.css("paddingBottom"),
                    element.css("paddingLeft"),
                ];

            for (; i < 4; i++) {
                widths[i] = parseFloat(borders[i]) || 0;
                widths[i] += parseFloat(paddings[i]) || 0;
            }

            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3],
            };
        },

        _proportionallyResize: function () {
            if (!this._proportionallyResizeElements.length) {
                return;
            }

            var prel,
                i = 0,
                element = this.helper || this.element;

            for (; i < this._proportionallyResizeElements.length; i++) {
                prel = this._proportionallyResizeElements[i];

                // TODO: Seems like a bug to cache this.outerDimensions
                // considering that we are in a loop.
                if (!this.outerDimensions) {
                    this.outerDimensions =
                        this._getPaddingPlusBorderDimensions(prel);
                }

                prel.css({
                    height: element.height() - this.outerDimensions.height || 0,
                    width: element.width() - this.outerDimensions.width || 0,
                });
            }
        },

        _renderProxy: function () {
            var el = this.element,
                o = this.options;
            this.elementOffset = el.offset();

            if (this._helper) {
                this.helper =
                    this.helper || $("<div></div>").css({ overflow: "hidden" });

                this._addClass(this.helper, this._helper);
                this.helper.css({
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex, //TODO: Don't modify option
                });

                this.helper.appendTo("body").disableSelection();
            } else {
                this.helper = this.element;
            }
        },

        _change: {
            e: function (event, dx) {
                return { width: this.originalSize.width + dx };
            },
            w: function (event, dx) {
                var cs = this.originalSize,
                    sp = this.originalPosition;
                return { left: sp.left + dx, width: cs.width - dx };
            },
            n: function (event, dx, dy) {
                var cs = this.originalSize,
                    sp = this.originalPosition;
                return { top: sp.top + dy, height: cs.height - dy };
            },
            s: function (event, dx, dy) {
                return { height: this.originalSize.height + dy };
            },
            se: function (event, dx, dy) {
                return $.extend(
                    this._change.s.apply(this, arguments),
                    this._change.e.apply(this, [event, dx, dy])
                );
            },
            sw: function (event, dx, dy) {
                return $.extend(
                    this._change.s.apply(this, arguments),
                    this._change.w.apply(this, [event, dx, dy])
                );
            },
            ne: function (event, dx, dy) {
                return $.extend(
                    this._change.n.apply(this, arguments),
                    this._change.e.apply(this, [event, dx, dy])
                );
            },
            nw: function (event, dx, dy) {
                return $.extend(
                    this._change.n.apply(this, arguments),
                    this._change.w.apply(this, [event, dx, dy])
                );
            },
        },

        _propagate: function (n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()]);
            if (n !== "resize") {
                this._trigger(n, event, this.ui());
            }
        },

        plugins: {},

        ui: function () {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition,
            };
        },
    });

    /*
     * Resizable Extensions
     */

    $.ui.plugin.add("resizable", "animate", {
        stop: function (event) {
            var that = $(this).resizable("instance"),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && /textarea/i.test(pr[0].nodeName),
                soffseth =
                    ista && that._hasScroll(pr[0], "left")
                        ? 0
                        : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = {
                    width: that.size.width - soffsetw,
                    height: that.size.height - soffseth,
                },
                left =
                    parseFloat(that.element.css("left")) +
                        (that.position.left - that.originalPosition.left) ||
                    null,
                top =
                    parseFloat(that.element.css("top")) +
                        (that.position.top - that.originalPosition.top) || null;

            that.element.animate(
                $.extend(style, top && left ? { top: top, left: left } : {}),
                {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function () {
                        var data = {
                            width: parseFloat(that.element.css("width")),
                            height: parseFloat(that.element.css("height")),
                            top: parseFloat(that.element.css("top")),
                            left: parseFloat(that.element.css("left")),
                        };

                        if (pr && pr.length) {
                            $(pr[0]).css({
                                width: data.width,
                                height: data.height,
                            });
                        }

                        // Propagating resize, and updating values for each animation step
                        that._updateCache(data);
                        that._propagate("resize", event);
                    },
                }
            );
        },
    });

    $.ui.plugin.add("resizable", "containment", {
        start: function () {
            var element,
                p,
                co,
                ch,
                cw,
                width,
                height,
                that = $(this).resizable("instance"),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce =
                    oc instanceof $
                        ? oc.get(0)
                        : /parent/.test(oc)
                        ? el.parent().get(0)
                        : oc;

            if (!ce) {
                return;
            }

            that.containerElement = $(ce);

            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0,
                };
                that.containerPosition = {
                    left: 0,
                    top: 0,
                };

                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height:
                        $(document).height() ||
                        document.body.parentNode.scrollHeight,
                };
            } else {
                element = $(ce);
                p = [];
                $(["Top", "Right", "Left", "Bottom"]).each(function (i, name) {
                    p[i] = that._num(element.css("padding" + name));
                });

                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: element.innerHeight() - p[3],
                    width: element.innerWidth() - p[1],
                };

                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
                height = that._hasScroll(ce) ? ce.scrollHeight : ch;

                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height,
                };
            }
        },

        resize: function (event) {
            var woset,
                hoset,
                isParent,
                isOffsetRelative,
                that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = {
                    top: 0,
                    left: 0,
                },
                ce = that.containerElement,
                continueResize = true;

            if (ce[0] !== document && /static/.test(ce.css("position"))) {
                cop = co;
            }

            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width =
                    that.size.width +
                    (that._helper
                        ? that.position.left - co.left
                        : that.position.left - cop.left);

                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }

            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height =
                    that.size.height +
                    (that._helper
                        ? that.position.top - co.top
                        : that.position.top);

                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }

            isParent =
                that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(
                that.containerElement.css("position")
            );

            if (isParent && isOffsetRelative) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }

            woset = Math.abs(
                that.sizeDiff.width +
                    (that._helper
                        ? that.offset.left - cop.left
                        : that.offset.left - co.left)
            );

            hoset = Math.abs(
                that.sizeDiff.height +
                    (that._helper
                        ? that.offset.top - cop.top
                        : that.offset.top - co.top)
            );

            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }

            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }

            if (!continueResize) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },

        stop: function () {
            var that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $(that.helper),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;

            if (
                that._helper &&
                !o.animate &&
                /relative/.test(ce.css("position"))
            ) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h,
                });
            }

            if (
                that._helper &&
                !o.animate &&
                /static/.test(ce.css("position"))
            ) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h,
                });
            }
        },
    });

    $.ui.plugin.add("resizable", "alsoResize", {
        start: function () {
            var that = $(this).resizable("instance"),
                o = that.options;

            $(o.alsoResize).each(function () {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseFloat(el.width()),
                    height: parseFloat(el.height()),
                    left: parseFloat(el.css("left")),
                    top: parseFloat(el.css("top")),
                });
            });
        },

        resize: function (event, ui) {
            var that = $(this).resizable("instance"),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: that.size.height - os.height || 0,
                    width: that.size.width - os.width || 0,
                    top: that.position.top - op.top || 0,
                    left: that.position.left - op.left || 0,
                };

            $(o.alsoResize).each(function () {
                var el = $(this),
                    start = $(this).data("ui-resizable-alsoresize"),
                    style = {},
                    css = el.parents(ui.originalElement[0]).length
                        ? ["width", "height"]
                        : ["width", "height", "top", "left"];

                $.each(css, function (i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) {
                        style[prop] = sum || null;
                    }
                });

                el.css(style);
            });
        },

        stop: function () {
            $(this).removeData("ui-resizable-alsoresize");
        },
    });

    $.ui.plugin.add("resizable", "ghost", {
        start: function () {
            var that = $(this).resizable("instance"),
                cs = that.size;

            that.ghost = that.originalElement.clone();
            that.ghost.css({
                opacity: 0.25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0,
            });

            that._addClass(that.ghost, "ui-resizable-ghost");

            // DEPRECATED
            // TODO: remove after 1.12
            if (
                $.uiBackCompat !== false &&
                typeof that.options.ghost === "string"
            ) {
                // Ghost option
                that.ghost.addClass(this.options.ghost);
            }

            that.ghost.appendTo(that.helper);
        },

        resize: function () {
            var that = $(this).resizable("instance");
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width,
                });
            }
        },

        stop: function () {
            var that = $(this).resizable("instance");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        },
    });

    $.ui.plugin.add("resizable", "grid", {
        resize: function () {
            var outerDimensions,
                that = $(this).resizable("instance"),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                gridX = grid[0] || 1,
                gridY = grid[1] || 1,
                ox = Math.round((cs.width - os.width) / gridX) * gridX,
                oy = Math.round((cs.height - os.height) / gridY) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
                isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
                isMinWidth = o.minWidth && o.minWidth > newWidth,
                isMinHeight = o.minHeight && o.minHeight > newHeight;

            o.grid = grid;

            if (isMinWidth) {
                newWidth += gridX;
            }
            if (isMinHeight) {
                newHeight += gridY;
            }
            if (isMaxWidth) {
                newWidth -= gridX;
            }
            if (isMaxHeight) {
                newHeight -= gridY;
            }

            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                    outerDimensions =
                        that._getPaddingPlusBorderDimensions(this);
                }

                if (newHeight - gridY > 0) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if (newWidth - gridX > 0) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        },
    });

    var widgetsResizable = $.ui.resizable;

    /*!
     * jQuery UI Dialog 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Dialog
    //>>group: Widgets
    //>>description: Displays customizable dialog windows.
    //>>docs: http://api.jqueryui.com/dialog/
    //>>demos: http://jqueryui.com/dialog/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/dialog.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.dialog", {
        version: "1.13.2",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            classes: {
                "ui-dialog": "ui-corner-all",
                "ui-dialog-titlebar": "ui-corner-all",
            },
            closeOnEscape: true,
            closeText: "Close",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",

                // Ensure the titlebar is always visible
                using: function (pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                },
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,

            // Callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null,
        },

        sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true,
        },

        resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
        },

        _create: function () {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height,
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element),
            };
            this.originalTitle = this.element.attr("title");
            if (this.options.title == null && this.originalTitle != null) {
                this.options.title = this.originalTitle;
            }

            // Dialogs can't be disabled
            if (this.options.disabled) {
                this.options.disabled = false;
            }

            this._createWrapper();

            this.element.show().removeAttr("title").appendTo(this.uiDialog);

            this._addClass("ui-dialog-content", "ui-widget-content");

            this._createTitlebar();
            this._createButtonPane();

            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }

            this._isOpen = false;

            this._trackFocus();
        },

        _init: function () {
            if (this.options.autoOpen) {
                this.open();
            }
        },

        _appendTo: function () {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },

        _destroy: function () {
            var next,
                originalPosition = this.originalPosition;

            this._untrackInstance();
            this._destroyOverlay();

            this.element
                .removeUniqueId()
                .css(this.originalCss)

                // Without detaching first, the following becomes really slow
                .detach();

            this.uiDialog.remove();

            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }

            next = originalPosition.parent
                .children()
                .eq(originalPosition.index);

            // Don't try to place the dialog next to itself (#8613)
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },

        widget: function () {
            return this.uiDialog;
        },

        disable: $.noop,
        enable: $.noop,

        close: function (event) {
            var that = this;

            if (
                !this._isOpen ||
                this._trigger("beforeClose", event) === false
            ) {
                return;
            }

            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();

            if (!this.opener.filter(":focusable").trigger("focus").length) {
                // Hiding a focused element doesn't trigger blur in WebKit
                // so in case we have nothing to focus on, explicitly blur the active element
                // https://bugs.webkit.org/show_bug.cgi?id=47182
                $.ui.safeBlur($.ui.safeActiveElement(this.document[0]));
            }

            this._hide(this.uiDialog, this.options.hide, function () {
                that._trigger("close", event);
            });
        },

        isOpen: function () {
            return this._isOpen;
        },

        moveToTop: function () {
            this._moveToTop();
        },

        _moveToTop: function (event, silent) {
            var moved = false,
                zIndices = this.uiDialog
                    .siblings(".ui-front:visible")
                    .map(function () {
                        return +$(this).css("z-index");
                    })
                    .get(),
                zIndexMax = Math.max.apply(null, zIndices);

            if (zIndexMax >= +this.uiDialog.css("z-index")) {
                this.uiDialog.css("z-index", zIndexMax + 1);
                moved = true;
            }

            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },

        open: function () {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }

            this._isOpen = true;
            this.opener = $($.ui.safeActiveElement(this.document[0]));

            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);

            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if (this.overlay) {
                this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
            }

            this._show(this.uiDialog, this.options.show, function () {
                that._focusTabbable();
                that._trigger("focus");
            });

            // Track the dialog immediately upon opening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget();

            this._trigger("open");
        },

        _focusTabbable: function () {
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement;
            if (!hasFocus) {
                hasFocus = this.element.find("[autofocus]");
            }
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).trigger("focus");
        },

        _restoreTabbableFocus: function () {
            var activeElement = $.ui.safeActiveElement(this.document[0]),
                isActive =
                    this.uiDialog[0] === activeElement ||
                    $.contains(this.uiDialog[0], activeElement);
            if (!isActive) {
                this._focusTabbable();
            }
        },

        _keepFocus: function (event) {
            event.preventDefault();
            this._restoreTabbableFocus();

            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(this._restoreTabbableFocus);
        },

        _createWrapper: function () {
            this.uiDialog = $("<div>")
                .hide()
                .attr({
                    // Setting tabIndex makes the div focusable
                    tabIndex: -1,
                    role: "dialog",
                })
                .appendTo(this._appendTo());

            this._addClass(
                this.uiDialog,
                "ui-dialog",
                "ui-widget ui-widget-content ui-front"
            );
            this._on(this.uiDialog, {
                keydown: function (event) {
                    if (
                        this.options.closeOnEscape &&
                        !event.isDefaultPrevented() &&
                        event.keyCode &&
                        event.keyCode === $.ui.keyCode.ESCAPE
                    ) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }

                    // Prevent tabbing out of dialogs
                    if (
                        event.keyCode !== $.ui.keyCode.TAB ||
                        event.isDefaultPrevented()
                    ) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"),
                        first = tabbables.first(),
                        last = tabbables.last();

                    if (
                        (event.target === last[0] ||
                            event.target === this.uiDialog[0]) &&
                        !event.shiftKey
                    ) {
                        this._delay(function () {
                            first.trigger("focus");
                        });
                        event.preventDefault();
                    } else if (
                        (event.target === first[0] ||
                            event.target === this.uiDialog[0]) &&
                        event.shiftKey
                    ) {
                        this._delay(function () {
                            last.trigger("focus");
                        });
                        event.preventDefault();
                    }
                },
                mousedown: function (event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                },
            });

            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id"),
                });
            }
        },

        _createTitlebar: function () {
            var uiDialogTitle;

            this.uiDialogTitlebar = $("<div>");
            this._addClass(
                this.uiDialogTitlebar,
                "ui-dialog-titlebar",
                "ui-widget-header ui-helper-clearfix"
            );
            this._on(this.uiDialogTitlebar, {
                mousedown: function (event) {
                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                        // Dialog isn't getting focus when dragging (#8063)
                        this.uiDialog.trigger("focus");
                    }
                },
            });

            // Support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $("<button type='button'></button>")
                .button({
                    label: $("<a>").text(this.options.closeText).html(),
                    icon: "ui-icon-closethick",
                    showLabel: false,
                })
                .appendTo(this.uiDialogTitlebar);

            this._addClass(
                this.uiDialogTitlebarClose,
                "ui-dialog-titlebar-close"
            );
            this._on(this.uiDialogTitlebarClose, {
                click: function (event) {
                    event.preventDefault();
                    this.close(event);
                },
            });

            uiDialogTitle = $("<span>")
                .uniqueId()
                .prependTo(this.uiDialogTitlebar);
            this._addClass(uiDialogTitle, "ui-dialog-title");
            this._title(uiDialogTitle);

            this.uiDialogTitlebar.prependTo(this.uiDialog);

            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id"),
            });
        },

        _title: function (title) {
            if (this.options.title) {
                title.text(this.options.title);
            } else {
                title.html("&#160;");
            }
        },

        _createButtonPane: function () {
            this.uiDialogButtonPane = $("<div>");
            this._addClass(
                this.uiDialogButtonPane,
                "ui-dialog-buttonpane",
                "ui-widget-content ui-helper-clearfix"
            );

            this.uiButtonSet = $("<div>").appendTo(this.uiDialogButtonPane);
            this._addClass(this.uiButtonSet, "ui-dialog-buttonset");

            this._createButtons();
        },

        _createButtons: function () {
            var that = this,
                buttons = this.options.buttons;

            // If we already have a button pane, remove it
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();

            if (
                $.isEmptyObject(buttons) ||
                (Array.isArray(buttons) && !buttons.length)
            ) {
                this._removeClass(this.uiDialog, "ui-dialog-buttons");
                return;
            }

            $.each(buttons, function (name, props) {
                var click, buttonOptions;
                props =
                    typeof props === "function"
                        ? { click: props, text: name }
                        : props;

                // Default to a non-submitting button
                props = $.extend({ type: "button" }, props);

                // Change the context for the click callback to be the main element
                click = props.click;
                buttonOptions = {
                    icon: props.icon,
                    iconPosition: props.iconPosition,
                    showLabel: props.showLabel,

                    // Deprecated options
                    icons: props.icons,
                    text: props.text,
                };

                delete props.click;
                delete props.icon;
                delete props.iconPosition;
                delete props.showLabel;

                // Deprecated options
                delete props.icons;
                if (typeof props.text === "boolean") {
                    delete props.text;
                }

                $("<button></button>", props)
                    .button(buttonOptions)
                    .appendTo(that.uiButtonSet)
                    .on("click", function () {
                        click.apply(that.element[0], arguments);
                    });
            });
            this._addClass(this.uiDialog, "ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },

        _makeDraggable: function () {
            var that = this,
                options = this.options;

            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset,
                };
            }

            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function (event, ui) {
                    that._addClass($(this), "ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function (event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(),
                        top = ui.offset.top - that.document.scrollTop();

                    options.position = {
                        my: "left top",
                        at:
                            "left" +
                            (left >= 0 ? "+" : "") +
                            left +
                            " " +
                            "top" +
                            (top >= 0 ? "+" : "") +
                            top,
                        of: that.window,
                    };
                    that._removeClass($(this), "ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                },
            });
        },

        _makeResizable: function () {
            var that = this,
                options = this.options,
                handles = options.resizable,
                // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                position = this.uiDialog.css("position"),
                resizeHandles =
                    typeof handles === "string"
                        ? handles
                        : "n,e,s,w,se,sw,ne,nw";

            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size,
                };
            }

            this.uiDialog
                .resizable({
                    cancel: ".ui-dialog-content",
                    containment: "document",
                    alsoResize: this.element,
                    maxWidth: options.maxWidth,
                    maxHeight: options.maxHeight,
                    minWidth: options.minWidth,
                    minHeight: this._minHeight(),
                    handles: resizeHandles,
                    start: function (event, ui) {
                        that._addClass($(this), "ui-dialog-resizing");
                        that._blockFrames();
                        that._trigger("resizeStart", event, filteredUi(ui));
                    },
                    resize: function (event, ui) {
                        that._trigger("resize", event, filteredUi(ui));
                    },
                    stop: function (event, ui) {
                        var offset = that.uiDialog.offset(),
                            left = offset.left - that.document.scrollLeft(),
                            top = offset.top - that.document.scrollTop();

                        options.height = that.uiDialog.height();
                        options.width = that.uiDialog.width();
                        options.position = {
                            my: "left top",
                            at:
                                "left" +
                                (left >= 0 ? "+" : "") +
                                left +
                                " " +
                                "top" +
                                (top >= 0 ? "+" : "") +
                                top,
                            of: that.window,
                        };
                        that._removeClass($(this), "ui-dialog-resizing");
                        that._unblockFrames();
                        that._trigger("resizeStop", event, filteredUi(ui));
                    },
                })
                .css("position", position);
        },

        _trackFocus: function () {
            this._on(this.widget(), {
                focusin: function (event) {
                    this._makeFocusTarget();
                    this._focusedElement = $(event.target);
                },
            });
        },

        _makeFocusTarget: function () {
            this._untrackInstance();
            this._trackingInstances().unshift(this);
        },

        _untrackInstance: function () {
            var instances = this._trackingInstances(),
                exists = $.inArray(this, instances);
            if (exists !== -1) {
                instances.splice(exists, 1);
            }
        },

        _trackingInstances: function () {
            var instances = this.document.data("ui-dialog-instances");
            if (!instances) {
                instances = [];
                this.document.data("ui-dialog-instances", instances);
            }
            return instances;
        },

        _minHeight: function () {
            var options = this.options;

            return options.height === "auto"
                ? options.minHeight
                : Math.min(options.minHeight, options.height);
        },

        _position: function () {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },

        _setOptions: function (options) {
            var that = this,
                resize = false,
                resizableOptions = {};

            $.each(options, function (key, value) {
                that._setOption(key, value);

                if (key in that.sizeRelatedOptions) {
                    resize = true;
                }
                if (key in that.resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });

            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },

        _setOption: function (key, value) {
            var isDraggable,
                isResizable,
                uiDialog = this.uiDialog;

            if (key === "disabled") {
                return;
            }

            this._super(key, value);

            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }

            if (key === "buttons") {
                this._createButtons();
            }

            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({
                    // Ensure that we always pass a string
                    label: $("<a>")
                        .text("" + this.options.closeText)
                        .html(),
                });
            }

            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }

                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }

            if (key === "position") {
                this._position();
            }

            if (key === "resizable") {
                // currently resizable, becoming non-resizable
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }

                // Currently resizable, changing handles
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }

                // Currently non-resizable, becoming resizable
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }

            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },

        _size: function () {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight,
                minContentHeight,
                maxContentHeight,
                options = this.options;

            // Reset content sizing
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0,
            });

            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }

            // Reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog
                .css({
                    height: "auto",
                    width: options.width,
                })
                .outerHeight();
            minContentHeight = Math.max(
                0,
                options.minHeight - nonContentHeight
            );
            maxContentHeight =
                typeof options.maxHeight === "number"
                    ? Math.max(0, options.maxHeight - nonContentHeight)
                    : "none";

            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto",
                });
            } else {
                this.element.height(
                    Math.max(0, options.height - nonContentHeight)
                );
            }

            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable(
                    "option",
                    "minHeight",
                    this._minHeight()
                );
            }
        },

        _blockFrames: function () {
            this.iframeBlocks = this.document.find("iframe").map(function () {
                var iframe = $(this);

                return $("<div>")
                    .css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight(),
                    })
                    .appendTo(iframe.parent())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function () {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _allowInteraction: function (event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }

            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$(event.target).closest(".ui-datepicker").length;
        },

        _createOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            var jqMinor = $.fn.jquery.substring(0, 4);

            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true;
            this._delay(function () {
                isOpening = false;
            });

            if (!this.document.data("ui-dialog-overlays")) {
                // Prevent use of anchors and inputs
                // This doesn't use `_on()` because it is a shared event handler
                // across all open modal dialogs.
                this.document.on(
                    "focusin.ui-dialog",
                    function (event) {
                        if (isOpening) {
                            return;
                        }

                        var instance = this._trackingInstances()[0];
                        if (!instance._allowInteraction(event)) {
                            event.preventDefault();
                            instance._focusTabbable();

                            // Support: jQuery >=3.4 <3.6 only
                            // Focus re-triggering in jQuery 3.4/3.5 makes the original element
                            // have its focus event propagated last, breaking the re-targeting.
                            // Trigger focus in a delay in addition if needed to avoid the issue
                            // See https://github.com/jquery/jquery/issues/4382
                            if (jqMinor === "3.4." || jqMinor === "3.5.") {
                                instance._delay(instance._restoreTabbableFocus);
                            }
                        }
                    }.bind(this)
                );
            }

            this.overlay = $("<div>").appendTo(this._appendTo());

            this._addClass(this.overlay, null, "ui-widget-overlay ui-front");
            this._on(this.overlay, {
                mousedown: "_keepFocus",
            });
            this.document.data(
                "ui-dialog-overlays",
                (this.document.data("ui-dialog-overlays") || 0) + 1
            );
        },

        _destroyOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            if (this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;

                if (!overlays) {
                    this.document.off("focusin.ui-dialog");
                    this.document.removeData("ui-dialog-overlays");
                } else {
                    this.document.data("ui-dialog-overlays", overlays);
                }

                this.overlay.remove();
                this.overlay = null;
            }
        },
    });

    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {
        // Backcompat for dialogClass option
        $.widget("ui.dialog", $.ui.dialog, {
            options: {
                dialogClass: "",
            },
            _createWrapper: function () {
                this._super();
                this.uiDialog.addClass(this.options.dialogClass);
            },
            _setOption: function (key, value) {
                if (key === "dialogClass") {
                    this.uiDialog
                        .removeClass(this.options.dialogClass)
                        .addClass(value);
                }
                this._superApply(arguments);
            },
        });
    }

    var widgetsDialog = $.ui.dialog;

    /*!
     * jQuery UI Droppable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Droppable
    //>>group: Interactions
    //>>description: Enables drop targets for draggable elements.
    //>>docs: http://api.jqueryui.com/droppable/
    //>>demos: http://jqueryui.com/droppable/

    $.widget("ui.droppable", {
        version: "1.13.2",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            addClasses: true,
            greedy: false,
            scope: "default",
            tolerance: "intersect",

            // Callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null,
        },
        _create: function () {
            var proportions,
                o = this.options,
                accept = o.accept;

            this.isover = false;
            this.isout = true;

            this.accept =
                typeof accept === "function"
                    ? accept
                    : function (d) {
                          return d.is(accept);
                      };

            this.proportions = function (/* valueToWrite */) {
                if (arguments.length) {
                    // Store the droppable's proportions
                    proportions = arguments[0];
                } else {
                    // Retrieve or derive the droppable's proportions
                    return proportions
                        ? proportions
                        : (proportions = {
                              width: this.element[0].offsetWidth,
                              height: this.element[0].offsetHeight,
                          });
                }
            };

            this._addToManager(o.scope);

            if (o.addClasses) {
                this._addClass("ui-droppable");
            }
        },

        _addToManager: function (scope) {
            // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[scope] =
                $.ui.ddmanager.droppables[scope] || [];
            $.ui.ddmanager.droppables[scope].push(this);
        },

        _splice: function (drop) {
            var i = 0;
            for (; i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }
        },

        _destroy: function () {
            var drop = $.ui.ddmanager.droppables[this.options.scope];

            this._splice(drop);
        },

        _setOption: function (key, value) {
            if (key === "accept") {
                this.accept =
                    typeof value === "function"
                        ? value
                        : function (d) {
                              return d.is(value);
                          };
            } else if (key === "scope") {
                var drop = $.ui.ddmanager.droppables[this.options.scope];

                this._splice(drop);
                this._addToManager(value);
            }

            this._super(key, value);
        },

        _activate: function (event) {
            var draggable = $.ui.ddmanager.current;

            this._addActiveClass();
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },

        _deactivate: function (event) {
            var draggable = $.ui.ddmanager.current;

            this._removeActiveClass();
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },

        _over: function (event) {
            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (
                !draggable ||
                (draggable.currentItem || draggable.element)[0] ===
                    this.element[0]
            ) {
                return;
            }

            if (
                this.accept.call(
                    this.element[0],
                    draggable.currentItem || draggable.element
                )
            ) {
                this._addHoverClass();
                this._trigger("over", event, this.ui(draggable));
            }
        },

        _out: function (event) {
            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (
                !draggable ||
                (draggable.currentItem || draggable.element)[0] ===
                    this.element[0]
            ) {
                return;
            }

            if (
                this.accept.call(
                    this.element[0],
                    draggable.currentItem || draggable.element
                )
            ) {
                this._removeHoverClass();
                this._trigger("out", event, this.ui(draggable));
            }
        },

        _drop: function (event, custom) {
            var draggable = custom || $.ui.ddmanager.current,
                childrenIntersection = false;

            // Bail if draggable and droppable are same element
            if (
                !draggable ||
                (draggable.currentItem || draggable.element)[0] ===
                    this.element[0]
            ) {
                return false;
            }

            this.element
                .find(":data(ui-droppable)")
                .not(".ui-draggable-dragging")
                .each(function () {
                    var inst = $(this).droppable("instance");
                    if (
                        inst.options.greedy &&
                        !inst.options.disabled &&
                        inst.options.scope === draggable.options.scope &&
                        inst.accept.call(
                            inst.element[0],
                            draggable.currentItem || draggable.element
                        ) &&
                        $.ui.intersect(
                            draggable,
                            $.extend(inst, { offset: inst.element.offset() }),
                            inst.options.tolerance,
                            event
                        )
                    ) {
                        childrenIntersection = true;
                        return false;
                    }
                });
            if (childrenIntersection) {
                return false;
            }

            if (
                this.accept.call(
                    this.element[0],
                    draggable.currentItem || draggable.element
                )
            ) {
                this._removeActiveClass();
                this._removeHoverClass();

                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }

            return false;
        },

        ui: function (c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs,
            };
        },

        // Extension points just to make backcompat sane and avoid duplicating logic
        // TODO: Remove in 1.14 along with call to it below
        _addHoverClass: function () {
            this._addClass("ui-droppable-hover");
        },

        _removeHoverClass: function () {
            this._removeClass("ui-droppable-hover");
        },

        _addActiveClass: function () {
            this._addClass("ui-droppable-active");
        },

        _removeActiveClass: function () {
            this._removeClass("ui-droppable-active");
        },
    });

    $.ui.intersect = (function () {
        function isOverAxis(x, reference, size) {
            return x >= reference && x < reference + size;
        }

        return function (draggable, droppable, toleranceMode, event) {
            if (!droppable.offset) {
                return false;
            }

            var x1 =
                    (draggable.positionAbs || draggable.position.absolute)
                        .left + draggable.margins.left,
                y1 =
                    (draggable.positionAbs || draggable.position.absolute).top +
                    draggable.margins.top,
                x2 = x1 + draggable.helperProportions.width,
                y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left,
                t = droppable.offset.top,
                r = l + droppable.proportions().width,
                b = t + droppable.proportions().height;

            switch (toleranceMode) {
                case "fit":
                    return l <= x1 && x2 <= r && t <= y1 && y2 <= b;
                case "intersect":
                    return (
                        l < x1 + draggable.helperProportions.width / 2 && // Right Half
                        x2 - draggable.helperProportions.width / 2 < r && // Left Half
                        t < y1 + draggable.helperProportions.height / 2 && // Bottom Half
                        y2 - draggable.helperProportions.height / 2 < b
                    ); // Top Half
                case "pointer":
                    return (
                        isOverAxis(
                            event.pageY,
                            t,
                            droppable.proportions().height
                        ) &&
                        isOverAxis(
                            event.pageX,
                            l,
                            droppable.proportions().width
                        )
                    );
                case "touch":
                    return (
                        ((y1 >= t && y1 <= b) || // Top edge touching
                            (y2 >= t && y2 <= b) || // Bottom edge touching
                            (y1 < t && y2 > b)) && // Surrounded vertically
                        ((x1 >= l && x1 <= r) || // Left edge touching
                            (x2 >= l && x2 <= r) || // Right edge touching
                            (x1 < l && x2 > r)) // Surrounded horizontally
                    );
                default:
                    return false;
            }
        };
    })();

    /*
	This manager tracks offsets of draggables and droppables
*/
    $.ui.ddmanager = {
        current: null,
        droppables: { default: [] },
        prepareOffsets: function (t, event) {
            var i,
                j,
                m = $.ui.ddmanager.droppables[t.options.scope] || [],
                type = event ? event.type : null, // workaround for #2317
                list = (t.currentItem || t.element)
                    .find(":data(ui-droppable)")
                    .addBack();

            droppablesLoop: for (i = 0; i < m.length; i++) {
                // No disabled and non-accepted
                if (
                    m[i].options.disabled ||
                    (t &&
                        !m[i].accept.call(
                            m[i].element[0],
                            t.currentItem || t.element
                        ))
                ) {
                    continue;
                }

                // Filter out elements in the current dragged item
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions().height = 0;
                        continue droppablesLoop;
                    }
                }

                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }

                // Activate the droppable if used directly from draggables
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }

                m[i].offset = m[i].element.offset();
                m[i].proportions({
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight,
                });
            }
        },
        drop: function (draggable, event) {
            var dropped = false;

            // Create a copy of the droppables in case the list changes during the drop (#9116)
            $.each(
                (
                    $.ui.ddmanager.droppables[draggable.options.scope] || []
                ).slice(),
                function () {
                    if (!this.options) {
                        return;
                    }
                    if (
                        !this.options.disabled &&
                        this.visible &&
                        $.ui.intersect(
                            draggable,
                            this,
                            this.options.tolerance,
                            event
                        )
                    ) {
                        dropped = this._drop.call(this, event) || dropped;
                    }

                    if (
                        !this.options.disabled &&
                        this.visible &&
                        this.accept.call(
                            this.element[0],
                            draggable.currentItem || draggable.element
                        )
                    ) {
                        this.isout = true;
                        this.isover = false;
                        this._deactivate.call(this, event);
                    }
                }
            );
            return dropped;
        },
        dragStart: function (draggable, event) {
            // Listen for scrolling so that if the dragging causes scrolling the position of the
            // droppables can be recalculated (see #5003)
            draggable.element
                .parentsUntil("body")
                .on("scroll.droppable", function () {
                    if (!draggable.options.refreshPositions) {
                        $.ui.ddmanager.prepareOffsets(draggable, event);
                    }
                });
        },
        drag: function (draggable, event) {
            // If you have a highly dynamic page, you might try this option. It renders positions
            // every time you move the mouse.
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }

            // Run through all droppables and check their positions based on specific tolerance options
            $.each(
                $.ui.ddmanager.droppables[draggable.options.scope] || [],
                function () {
                    if (
                        this.options.disabled ||
                        this.greedyChild ||
                        !this.visible
                    ) {
                        return;
                    }

                    var parentInstance,
                        scope,
                        parent,
                        intersects = $.ui.intersect(
                            draggable,
                            this,
                            this.options.tolerance,
                            event
                        ),
                        c =
                            !intersects && this.isover
                                ? "isout"
                                : intersects && !this.isover
                                ? "isover"
                                : null;
                    if (!c) {
                        return;
                    }

                    if (this.options.greedy) {
                        // find droppable parents with same scope
                        scope = this.options.scope;
                        parent = this.element
                            .parents(":data(ui-droppable)")
                            .filter(function () {
                                return (
                                    $(this).droppable("instance").options
                                        .scope === scope
                                );
                            });

                        if (parent.length) {
                            parentInstance = $(parent[0]).droppable("instance");
                            parentInstance.greedyChild = c === "isover";
                        }
                    }

                    // We just moved into a greedy child
                    if (parentInstance && c === "isover") {
                        parentInstance.isover = false;
                        parentInstance.isout = true;
                        parentInstance._out.call(parentInstance, event);
                    }

                    this[c] = true;
                    this[c === "isout" ? "isover" : "isout"] = false;
                    this[c === "isover" ? "_over" : "_out"].call(this, event);

                    // We just moved out of a greedy child
                    if (parentInstance && c === "isout") {
                        parentInstance.isout = false;
                        parentInstance.isover = true;
                        parentInstance._over.call(parentInstance, event);
                    }
                }
            );
        },
        dragStop: function (draggable, event) {
            draggable.element.parentsUntil("body").off("scroll.droppable");

            // Call prepareOffsets one final time since IE does not fire return scroll events when
            // overflow was caused by drag (see #5003)
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        },
    };

    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {
        // Backcompat for activeClass and hoverClass options
        $.widget("ui.droppable", $.ui.droppable, {
            options: {
                hoverClass: false,
                activeClass: false,
            },
            _addActiveClass: function () {
                this._super();
                if (this.options.activeClass) {
                    this.element.addClass(this.options.activeClass);
                }
            },
            _removeActiveClass: function () {
                this._super();
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
            },
            _addHoverClass: function () {
                this._super();
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
            },
            _removeHoverClass: function () {
                this._super();
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
            },
        });
    }

    var widgetsDroppable = $.ui.droppable;

    /*!
     * jQuery UI Progressbar 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Progressbar
    //>>group: Widgets
    /* eslint-disable max-len */
    //>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
    /* eslint-enable max-len */
    //>>docs: http://api.jqueryui.com/progressbar/
    //>>demos: http://jqueryui.com/progressbar/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/progressbar.css
    //>>css.theme: ../../themes/base/theme.css

    var widgetsProgressbar = $.widget("ui.progressbar", {
        version: "1.13.2",
        options: {
            classes: {
                "ui-progressbar": "ui-corner-all",
                "ui-progressbar-value": "ui-corner-left",
                "ui-progressbar-complete": "ui-corner-right",
            },
            max: 100,
            value: 0,

            change: null,
            complete: null,
        },

        min: 0,

        _create: function () {
            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue();

            this.element.attr({
                // Only set static values; aria-valuenow and aria-valuemax are
                // set inside _refreshValue()
                role: "progressbar",
                "aria-valuemin": this.min,
            });
            this._addClass("ui-progressbar", "ui-widget ui-widget-content");

            this.valueDiv = $("<div>").appendTo(this.element);
            this._addClass(
                this.valueDiv,
                "ui-progressbar-value",
                "ui-widget-header"
            );
            this._refreshValue();
        },

        _destroy: function () {
            this.element.removeAttr(
                "role aria-valuemin aria-valuemax aria-valuenow"
            );

            this.valueDiv.remove();
        },

        value: function (newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }

            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },

        _constrainedValue: function (newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }

            this.indeterminate = newValue === false;

            // Sanitize value
            if (typeof newValue !== "number") {
                newValue = 0;
            }

            return this.indeterminate
                ? false
                : Math.min(this.options.max, Math.max(this.min, newValue));
        },

        _setOptions: function (options) {
            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value;

            this._super(options);

            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },

        _setOption: function (key, value) {
            if (key === "max") {
                // Don't allow a max less than min
                value = Math.max(this.min, value);
            }
            this._super(key, value);
        },

        _setOptionDisabled: function (value) {
            this._super(value);

            this.element.attr("aria-disabled", value);
            this._toggleClass(null, "ui-state-disabled", !!value);
        },

        _percentage: function () {
            return this.indeterminate
                ? 100
                : (100 * (this.options.value - this.min)) /
                      (this.options.max - this.min);
        },

        _refreshValue: function () {
            var value = this.options.value,
                percentage = this._percentage();

            this.valueDiv
                .toggle(this.indeterminate || value > this.min)
                .width(percentage.toFixed(0) + "%");

            this._toggleClass(
                this.valueDiv,
                "ui-progressbar-complete",
                null,
                value === this.options.max
            )._toggleClass(
                "ui-progressbar-indeterminate",
                null,
                this.indeterminate
            );

            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div>").appendTo(this.valueDiv);
                    this._addClass(this.overlayDiv, "ui-progressbar-overlay");
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value,
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        },
    });

    /*!
     * jQuery UI Selectable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Selectable
    //>>group: Interactions
    //>>description: Allows groups of elements to be selected with the mouse.
    //>>docs: http://api.jqueryui.com/selectable/
    //>>demos: http://jqueryui.com/selectable/
    //>>css.structure: ../../themes/base/selectable.css

    var widgetsSelectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.13.2",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",

            // Callbacks
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null,
        },
        _create: function () {
            var that = this;

            this._addClass("ui-selectable");

            this.dragged = false;

            // Cache selectee children based on filter
            this.refresh = function () {
                that.elementPos = $(that.element[0]).offset();
                that.selectees = $(that.options.filter, that.element[0]);
                that._addClass(that.selectees, "ui-selectee");
                that.selectees.each(function () {
                    var $this = $(this),
                        selecteeOffset = $this.offset(),
                        pos = {
                            left: selecteeOffset.left - that.elementPos.left,
                            top: selecteeOffset.top - that.elementPos.top,
                        };
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting"),
                    });
                });
            };
            this.refresh();

            this._mouseInit();

            this.helper = $("<div>");
            this._addClass(this.helper, "ui-selectable-helper");
        },

        _destroy: function () {
            this.selectees.removeData("selectable-item");
            this._mouseDestroy();
        },

        _mouseStart: function (event) {
            var that = this,
                options = this.options;

            this.opos = [event.pageX, event.pageY];
            this.elementPos = $(this.element[0]).offset();

            if (this.options.disabled) {
                return;
            }

            this.selectees = $(options.filter, this.element[0]);

            this._trigger("start", event);

            $(options.appendTo).append(this.helper);

            // position helper (lasso)
            this.helper.css({
                left: event.pageX,
                top: event.pageY,
                width: 0,
                height: 0,
            });

            if (options.autoRefresh) {
                this.refresh();
            }

            this.selectees.filter(".ui-selected").each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    that._removeClass(selectee.$element, "ui-selected");
                    selectee.selected = false;
                    that._addClass(selectee.$element, "ui-unselecting");
                    selectee.unselecting = true;

                    // selectable UNSELECTING callback
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element,
                    });
                }
            });

            $(event.target)
                .parents()
                .addBack()
                .each(function () {
                    var doSelect,
                        selectee = $.data(this, "selectable-item");
                    if (selectee) {
                        doSelect =
                            (!event.metaKey && !event.ctrlKey) ||
                            !selectee.$element.hasClass("ui-selected");
                        that._removeClass(
                            selectee.$element,
                            doSelect ? "ui-unselecting" : "ui-selected"
                        )._addClass(
                            selectee.$element,
                            doSelect ? "ui-selecting" : "ui-unselecting"
                        );
                        selectee.unselecting = !doSelect;
                        selectee.selecting = doSelect;
                        selectee.selected = doSelect;

                        // selectable (UN)SELECTING callback
                        if (doSelect) {
                            that._trigger("selecting", event, {
                                selecting: selectee.element,
                            });
                        } else {
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element,
                            });
                        }
                        return false;
                    }
                });
        },

        _mouseDrag: function (event) {
            this.dragged = true;

            if (this.options.disabled) {
                return;
            }

            var tmp,
                that = this,
                options = this.options,
                x1 = this.opos[0],
                y1 = this.opos[1],
                x2 = event.pageX,
                y2 = event.pageY;

            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({
                left: x1,
                top: y1,
                width: x2 - x1,
                height: y2 - y1,
            });

            this.selectees.each(function () {
                var selectee = $.data(this, "selectable-item"),
                    hit = false,
                    offset = {};

                //prevent helper from being selected if appendTo: selectable
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }

                offset.left = selectee.left + that.elementPos.left;
                offset.right = selectee.right + that.elementPos.left;
                offset.top = selectee.top + that.elementPos.top;
                offset.bottom = selectee.bottom + that.elementPos.top;

                if (options.tolerance === "touch") {
                    hit = !(
                        offset.left > x2 ||
                        offset.right < x1 ||
                        offset.top > y2 ||
                        offset.bottom < y1
                    );
                } else if (options.tolerance === "fit") {
                    hit =
                        offset.left > x1 &&
                        offset.right < x2 &&
                        offset.top > y1 &&
                        offset.bottom < y2;
                }

                if (hit) {
                    // SELECT
                    if (selectee.selected) {
                        that._removeClass(selectee.$element, "ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        that._removeClass(selectee.$element, "ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        that._addClass(selectee.$element, "ui-selecting");
                        selectee.selecting = true;

                        // selectable SELECTING callback
                        that._trigger("selecting", event, {
                            selecting: selectee.element,
                        });
                    }
                } else {
                    // UNSELECT
                    if (selectee.selecting) {
                        if (
                            (event.metaKey || event.ctrlKey) &&
                            selectee.startselected
                        ) {
                            that._removeClass(
                                selectee.$element,
                                "ui-selecting"
                            );
                            selectee.selecting = false;
                            that._addClass(selectee.$element, "ui-selected");
                            selectee.selected = true;
                        } else {
                            that._removeClass(
                                selectee.$element,
                                "ui-selecting"
                            );
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                that._addClass(
                                    selectee.$element,
                                    "ui-unselecting"
                                );
                                selectee.unselecting = true;
                            }

                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element,
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (
                            !event.metaKey &&
                            !event.ctrlKey &&
                            !selectee.startselected
                        ) {
                            that._removeClass(selectee.$element, "ui-selected");
                            selectee.selected = false;

                            that._addClass(selectee.$element, "ui-unselecting");
                            selectee.unselecting = true;

                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element,
                            });
                        }
                    }
                }
            });

            return false;
        },

        _mouseStop: function (event) {
            var that = this;

            this.dragged = false;

            $(".ui-unselecting", this.element[0]).each(function () {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element,
                });
            });
            $(".ui-selecting", this.element[0]).each(function () {
                var selectee = $.data(this, "selectable-item");
                that._removeClass(selectee.$element, "ui-selecting")._addClass(
                    selectee.$element,
                    "ui-selected"
                );
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element,
                });
            });
            this._trigger("stop", event);

            this.helper.remove();

            return false;
        },
    });

    /*!
     * jQuery UI Selectmenu 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Selectmenu
    //>>group: Widgets
    /* eslint-disable max-len */
    //>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
    /* eslint-enable max-len */
    //>>docs: http://api.jqueryui.com/selectmenu/
    //>>demos: http://jqueryui.com/selectmenu/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
    //>>css.theme: ../../themes/base/theme.css

    var widgetsSelectmenu = $.widget("ui.selectmenu", [
        $.ui.formResetMixin,
        {
            version: "1.13.2",
            defaultElement: "<select>",
            options: {
                appendTo: null,
                classes: {
                    "ui-selectmenu-button-open": "ui-corner-top",
                    "ui-selectmenu-button-closed": "ui-corner-all",
                },
                disabled: null,
                icons: {
                    button: "ui-icon-triangle-1-s",
                },
                position: {
                    my: "left top",
                    at: "left bottom",
                    collision: "none",
                },
                width: false,

                // Callbacks
                change: null,
                close: null,
                focus: null,
                open: null,
                select: null,
            },

            _create: function () {
                var selectmenuId = this.element.uniqueId().attr("id");
                this.ids = {
                    element: selectmenuId,
                    button: selectmenuId + "-button",
                    menu: selectmenuId + "-menu",
                };

                this._drawButton();
                this._drawMenu();
                this._bindFormResetHandler();

                this._rendered = false;
                this.menuItems = $();
            },

            _drawButton: function () {
                var icon,
                    that = this,
                    item = this._parseOption(
                        this.element.find("option:selected"),
                        this.element[0].selectedIndex
                    );

                // Associate existing label with the new button
                this.labels = this.element
                    .labels()
                    .attr("for", this.ids.button);
                this._on(this.labels, {
                    click: function (event) {
                        this.button.trigger("focus");
                        event.preventDefault();
                    },
                });

                // Hide original select element
                this.element.hide();

                // Create button
                this.button = $("<span>", {
                    tabindex: this.options.disabled ? -1 : 0,
                    id: this.ids.button,
                    role: "combobox",
                    "aria-expanded": "false",
                    "aria-autocomplete": "list",
                    "aria-owns": this.ids.menu,
                    "aria-haspopup": "true",
                    title: this.element.attr("title"),
                }).insertAfter(this.element);

                this._addClass(
                    this.button,
                    "ui-selectmenu-button ui-selectmenu-button-closed",
                    "ui-button ui-widget"
                );

                icon = $("<span>").appendTo(this.button);
                this._addClass(
                    icon,
                    "ui-selectmenu-icon",
                    "ui-icon " + this.options.icons.button
                );
                this.buttonItem = this._renderButtonItem(item).appendTo(
                    this.button
                );

                if (this.options.width !== false) {
                    this._resizeButton();
                }

                this._on(this.button, this._buttonEvents);
                this.button.one("focusin", function () {
                    // Delay rendering the menu items until the button receives focus.
                    // The menu may have already been rendered via a programmatic open.
                    if (!that._rendered) {
                        that._refreshMenu();
                    }
                });
            },

            _drawMenu: function () {
                var that = this;

                // Create menu
                this.menu = $("<ul>", {
                    "aria-hidden": "true",
                    "aria-labelledby": this.ids.button,
                    id: this.ids.menu,
                });

                // Wrap menu
                this.menuWrap = $("<div>").append(this.menu);
                this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front");
                this.menuWrap.appendTo(this._appendTo());

                // Initialize menu widget
                this.menuInstance = this.menu
                    .menu({
                        classes: {
                            "ui-menu": "ui-corner-bottom",
                        },
                        role: "listbox",
                        select: function (event, ui) {
                            event.preventDefault();

                            // Support: IE8
                            // If the item was selected via a click, the text selection
                            // will be destroyed in IE
                            that._setSelection();

                            that._select(
                                ui.item.data("ui-selectmenu-item"),
                                event
                            );
                        },
                        focus: function (event, ui) {
                            var item = ui.item.data("ui-selectmenu-item");

                            // Prevent inital focus from firing and check if its a newly focused item
                            if (
                                that.focusIndex != null &&
                                item.index !== that.focusIndex
                            ) {
                                that._trigger("focus", event, { item: item });
                                if (!that.isOpen) {
                                    that._select(item, event);
                                }
                            }
                            that.focusIndex = item.index;

                            that.button.attr(
                                "aria-activedescendant",
                                that.menuItems.eq(item.index).attr("id")
                            );
                        },
                    })
                    .menu("instance");

                // Don't close the menu on mouseleave
                this.menuInstance._off(this.menu, "mouseleave");

                // Cancel the menu's collapseAll on document click
                this.menuInstance._closeOnDocumentClick = function () {
                    return false;
                };

                // Selects often contain empty items, but never contain dividers
                this.menuInstance._isDivider = function () {
                    return false;
                };
            },

            refresh: function () {
                this._refreshMenu();
                this.buttonItem.replaceWith(
                    (this.buttonItem = this._renderButtonItem(
                        // Fall back to an empty object in case there are no options
                        this._getSelectedItem().data("ui-selectmenu-item") || {}
                    ))
                );
                if (this.options.width === null) {
                    this._resizeButton();
                }
            },

            _refreshMenu: function () {
                var item,
                    options = this.element.find("option");

                this.menu.empty();

                this._parseOptions(options);
                this._renderMenu(this.menu, this.items);

                this.menuInstance.refresh();
                this.menuItems = this.menu
                    .find("li")
                    .not(".ui-selectmenu-optgroup")
                    .find(".ui-menu-item-wrapper");

                this._rendered = true;

                if (!options.length) {
                    return;
                }

                item = this._getSelectedItem();

                // Update the menu to have the correct item focused
                this.menuInstance.focus(null, item);
                this._setAria(item.data("ui-selectmenu-item"));

                // Set disabled state
                this._setOption("disabled", this.element.prop("disabled"));
            },

            open: function (event) {
                if (this.options.disabled) {
                    return;
                }

                // If this is the first time the menu is being opened, render the items
                if (!this._rendered) {
                    this._refreshMenu();
                } else {
                    // Menu clears focus on close, reset focus to selected item
                    this._removeClass(
                        this.menu.find(".ui-state-active"),
                        null,
                        "ui-state-active"
                    );
                    this.menuInstance.focus(null, this._getSelectedItem());
                }

                // If there are no options, don't open the menu
                if (!this.menuItems.length) {
                    return;
                }

                this.isOpen = true;
                this._toggleAttr();
                this._resizeMenu();
                this._position();

                this._on(this.document, this._documentClick);

                this._trigger("open", event);
            },

            _position: function () {
                this.menuWrap.position(
                    $.extend({ of: this.button }, this.options.position)
                );
            },

            close: function (event) {
                if (!this.isOpen) {
                    return;
                }

                this.isOpen = false;
                this._toggleAttr();

                this.range = null;
                this._off(this.document);

                this._trigger("close", event);
            },

            widget: function () {
                return this.button;
            },

            menuWidget: function () {
                return this.menu;
            },

            _renderButtonItem: function (item) {
                var buttonItem = $("<span>");

                this._setText(buttonItem, item.label);
                this._addClass(buttonItem, "ui-selectmenu-text");

                return buttonItem;
            },

            _renderMenu: function (ul, items) {
                var that = this,
                    currentOptgroup = "";

                $.each(items, function (index, item) {
                    var li;

                    if (item.optgroup !== currentOptgroup) {
                        li = $("<li>", {
                            text: item.optgroup,
                        });
                        that._addClass(
                            li,
                            "ui-selectmenu-optgroup",
                            "ui-menu-divider" +
                                (item.element
                                    .parent("optgroup")
                                    .prop("disabled")
                                    ? " ui-state-disabled"
                                    : "")
                        );

                        li.appendTo(ul);

                        currentOptgroup = item.optgroup;
                    }

                    that._renderItemData(ul, item);
                });
            },

            _renderItemData: function (ul, item) {
                return this._renderItem(ul, item).data(
                    "ui-selectmenu-item",
                    item
                );
            },

            _renderItem: function (ul, item) {
                var li = $("<li>"),
                    wrapper = $("<div>", {
                        title: item.element.attr("title"),
                    });

                if (item.disabled) {
                    this._addClass(li, null, "ui-state-disabled");
                }
                this._setText(wrapper, item.label);

                return li.append(wrapper).appendTo(ul);
            },

            _setText: function (element, value) {
                if (value) {
                    element.text(value);
                } else {
                    element.html("&#160;");
                }
            },

            _move: function (direction, event) {
                var item,
                    next,
                    filter = ".ui-menu-item";

                if (this.isOpen) {
                    item = this.menuItems.eq(this.focusIndex).parent("li");
                } else {
                    item = this.menuItems
                        .eq(this.element[0].selectedIndex)
                        .parent("li");
                    filter += ":not(.ui-state-disabled)";
                }

                if (direction === "first" || direction === "last") {
                    next =
                        item[direction === "first" ? "prevAll" : "nextAll"](
                            filter
                        ).eq(-1);
                } else {
                    next = item[direction + "All"](filter).eq(0);
                }

                if (next.length) {
                    this.menuInstance.focus(event, next);
                }
            },

            _getSelectedItem: function () {
                return this.menuItems
                    .eq(this.element[0].selectedIndex)
                    .parent("li");
            },

            _toggle: function (event) {
                this[this.isOpen ? "close" : "open"](event);
            },

            _setSelection: function () {
                var selection;

                if (!this.range) {
                    return;
                }

                if (window.getSelection) {
                    selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(this.range);

                    // Support: IE8
                } else {
                    this.range.select();
                }

                // Support: IE
                // Setting the text selection kills the button focus in IE, but
                // restoring the focus doesn't kill the selection.
                this.button.trigger("focus");
            },

            _documentClick: {
                mousedown: function (event) {
                    if (!this.isOpen) {
                        return;
                    }

                    if (
                        !$(event.target).closest(
                            ".ui-selectmenu-menu, #" +
                                $.escapeSelector(this.ids.button)
                        ).length
                    ) {
                        this.close(event);
                    }
                },
            },

            _buttonEvents: {
                // Prevent text selection from being reset when interacting with the selectmenu (#10144)
                mousedown: function () {
                    var selection;

                    if (window.getSelection) {
                        selection = window.getSelection();
                        if (selection.rangeCount) {
                            this.range = selection.getRangeAt(0);
                        }

                        // Support: IE8
                    } else {
                        this.range = document.selection.createRange();
                    }
                },

                click: function (event) {
                    this._setSelection();
                    this._toggle(event);
                },

                keydown: function (event) {
                    var preventDefault = true;
                    switch (event.keyCode) {
                        case $.ui.keyCode.TAB:
                        case $.ui.keyCode.ESCAPE:
                            this.close(event);
                            preventDefault = false;
                            break;
                        case $.ui.keyCode.ENTER:
                            if (this.isOpen) {
                                this._selectFocusedItem(event);
                            }
                            break;
                        case $.ui.keyCode.UP:
                            if (event.altKey) {
                                this._toggle(event);
                            } else {
                                this._move("prev", event);
                            }
                            break;
                        case $.ui.keyCode.DOWN:
                            if (event.altKey) {
                                this._toggle(event);
                            } else {
                                this._move("next", event);
                            }
                            break;
                        case $.ui.keyCode.SPACE:
                            if (this.isOpen) {
                                this._selectFocusedItem(event);
                            } else {
                                this._toggle(event);
                            }
                            break;
                        case $.ui.keyCode.LEFT:
                            this._move("prev", event);
                            break;
                        case $.ui.keyCode.RIGHT:
                            this._move("next", event);
                            break;
                        case $.ui.keyCode.HOME:
                        case $.ui.keyCode.PAGE_UP:
                            this._move("first", event);
                            break;
                        case $.ui.keyCode.END:
                        case $.ui.keyCode.PAGE_DOWN:
                            this._move("last", event);
                            break;
                        default:
                            this.menu.trigger(event);
                            preventDefault = false;
                    }

                    if (preventDefault) {
                        event.preventDefault();
                    }
                },
            },

            _selectFocusedItem: function (event) {
                var item = this.menuItems.eq(this.focusIndex).parent("li");
                if (!item.hasClass("ui-state-disabled")) {
                    this._select(item.data("ui-selectmenu-item"), event);
                }
            },

            _select: function (item, event) {
                var oldIndex = this.element[0].selectedIndex;

                // Change native select element
                this.element[0].selectedIndex = item.index;
                this.buttonItem.replaceWith(
                    (this.buttonItem = this._renderButtonItem(item))
                );
                this._setAria(item);
                this._trigger("select", event, { item: item });

                if (item.index !== oldIndex) {
                    this._trigger("change", event, { item: item });
                }

                this.close(event);
            },

            _setAria: function (item) {
                var id = this.menuItems.eq(item.index).attr("id");

                this.button.attr({
                    "aria-labelledby": id,
                    "aria-activedescendant": id,
                });
                this.menu.attr("aria-activedescendant", id);
            },

            _setOption: function (key, value) {
                if (key === "icons") {
                    var icon = this.button.find("span.ui-icon");
                    this._removeClass(
                        icon,
                        null,
                        this.options.icons.button
                    )._addClass(icon, null, value.button);
                }

                this._super(key, value);

                if (key === "appendTo") {
                    this.menuWrap.appendTo(this._appendTo());
                }

                if (key === "width") {
                    this._resizeButton();
                }
            },

            _setOptionDisabled: function (value) {
                this._super(value);

                this.menuInstance.option("disabled", value);
                this.button.attr("aria-disabled", value);
                this._toggleClass(
                    this.button,
                    null,
                    "ui-state-disabled",
                    value
                );

                this.element.prop("disabled", value);
                if (value) {
                    this.button.attr("tabindex", -1);
                    this.close();
                } else {
                    this.button.attr("tabindex", 0);
                }
            },

            _appendTo: function () {
                var element = this.options.appendTo;

                if (element) {
                    element =
                        element.jquery || element.nodeType
                            ? $(element)
                            : this.document.find(element).eq(0);
                }

                if (!element || !element[0]) {
                    element = this.element.closest(".ui-front, dialog");
                }

                if (!element.length) {
                    element = this.document[0].body;
                }

                return element;
            },

            _toggleAttr: function () {
                this.button.attr("aria-expanded", this.isOpen);

                // We can't use two _toggleClass() calls here, because we need to make sure
                // we always remove classes first and add them second, otherwise if both classes have the
                // same theme class, it will be removed after we add it.
                this._removeClass(
                    this.button,
                    "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open")
                )
                    ._addClass(
                        this.button,
                        "ui-selectmenu-button-" +
                            (this.isOpen ? "open" : "closed")
                    )
                    ._toggleClass(
                        this.menuWrap,
                        "ui-selectmenu-open",
                        null,
                        this.isOpen
                    );

                this.menu.attr("aria-hidden", !this.isOpen);
            },

            _resizeButton: function () {
                var width = this.options.width;

                // For `width: false`, just remove inline style and stop
                if (width === false) {
                    this.button.css("width", "");
                    return;
                }

                // For `width: null`, match the width of the original element
                if (width === null) {
                    width = this.element.show().outerWidth();
                    this.element.hide();
                }

                this.button.outerWidth(width);
            },

            _resizeMenu: function () {
                this.menu.outerWidth(
                    Math.max(
                        this.button.outerWidth(),

                        // Support: IE10
                        // IE10 wraps long text (possibly a rounding bug)
                        // so we add 1px to avoid the wrapping
                        this.menu.width("").outerWidth() + 1
                    )
                );
            },

            _getCreateOptions: function () {
                var options = this._super();

                options.disabled = this.element.prop("disabled");

                return options;
            },

            _parseOptions: function (options) {
                var that = this,
                    data = [];
                options.each(function (index, item) {
                    if (item.hidden) {
                        return;
                    }

                    data.push(that._parseOption($(item), index));
                });
                this.items = data;
            },

            _parseOption: function (option, index) {
                var optgroup = option.parent("optgroup");

                return {
                    element: option,
                    index: index,
                    value: option.val(),
                    label: option.text(),
                    optgroup: optgroup.attr("label") || "",
                    disabled:
                        optgroup.prop("disabled") || option.prop("disabled"),
                };
            },

            _destroy: function () {
                this._unbindFormResetHandler();
                this.menuWrap.remove();
                this.button.remove();
                this.element.show();
                this.element.removeUniqueId();
                this.labels.attr("for", this.ids.element);
            },
        },
    ]);

    /*!
     * jQuery UI Slider 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Slider
    //>>group: Widgets
    //>>description: Displays a flexible slider with ranges and accessibility via keyboard.
    //>>docs: http://api.jqueryui.com/slider/
    //>>demos: http://jqueryui.com/slider/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/slider.css
    //>>css.theme: ../../themes/base/theme.css

    var widgetsSlider = $.widget("ui.slider", $.ui.mouse, {
        version: "1.13.2",
        widgetEventPrefix: "slide",

        options: {
            animate: false,
            classes: {
                "ui-slider": "ui-corner-all",
                "ui-slider-handle": "ui-corner-all",

                // Note: ui-widget-header isn't the most fittingly semantic framework class for this
                // element, but worked best visually with a variety of themes
                "ui-slider-range": "ui-corner-all ui-widget-header",
            },
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,

            // Callbacks
            change: null,
            slide: null,
            start: null,
            stop: null,
        },

        // Number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,

        _create: function () {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();

            this._addClass(
                "ui-slider ui-slider-" + this.orientation,
                "ui-widget ui-widget-content"
            );

            this._refresh();

            this._animateOff = false;
        },

        _refresh: function () {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function () {
            var i,
                handleCount,
                options = this.options,
                existingHandles = this.element.find(".ui-slider-handle"),
                handle = "<span tabindex='0'></span>",
                handles = [];

            handleCount = (options.values && options.values.length) || 1;

            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add(
                $(handles.join("")).appendTo(this.element)
            );

            this._addClass(
                this.handles,
                "ui-slider-handle",
                "ui-state-default"
            );

            this.handle = this.handles.eq(0);

            this.handles.each(function (i) {
                $(this).data("ui-slider-handle-index", i).attr("tabIndex", 0);
            });
        },

        _createRange: function () {
            var options = this.options;

            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [this._valueMin(), this._valueMin()];
                    } else if (
                        options.values.length &&
                        options.values.length !== 2
                    ) {
                        options.values = [options.values[0], options.values[0]];
                    } else if (Array.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }

                if (!this.range || !this.range.length) {
                    this.range = $("<div>").appendTo(this.element);

                    this._addClass(this.range, "ui-slider-range");
                } else {
                    this._removeClass(
                        this.range,
                        "ui-slider-range-min ui-slider-range-max"
                    );

                    // Handle range switching from true to min/max
                    this.range.css({
                        left: "",
                        bottom: "",
                    });
                }
                if (options.range === "min" || options.range === "max") {
                    this._addClass(
                        this.range,
                        "ui-slider-range-" + options.range
                    );
                }
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },

        _setupEvents: function () {
            this._off(this.handles);
            this._on(this.handles, this._handleEvents);
            this._hoverable(this.handles);
            this._focusable(this.handles);
        },

        _destroy: function () {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }

            this._mouseDestroy();
        },

        _mouseCapture: function (event) {
            var position,
                normValue,
                distance,
                closestHandle,
                index,
                allowed,
                offset,
                mouseOverHandle,
                that = this,
                o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
            };
            this.elementOffset = this.element.offset();

            position = { x: event.pageX, y: event.pageY };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function (i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if (
                    distance > thisDistance ||
                    (distance === thisDistance &&
                        (i === that._lastChangedValue ||
                            that.values(i) === o.min))
                ) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            this._addClass(closestHandle, null, "ui-state-active");
            closestHandle.trigger("focus");

            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target)
                .parents()
                .addBack()
                .is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle
                ? { left: 0, top: 0 }
                : {
                      left:
                          event.pageX - offset.left - closestHandle.width() / 2,
                      top:
                          event.pageY -
                          offset.top -
                          closestHandle.height() / 2 -
                          (parseInt(closestHandle.css("borderTopWidth"), 10) ||
                              0) -
                          (parseInt(
                              closestHandle.css("borderBottomWidth"),
                              10
                          ) || 0) +
                          (parseInt(closestHandle.css("marginTop"), 10) || 0),
                  };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function () {
            return true;
        },

        _mouseDrag: function (event) {
            var position = { x: event.pageX, y: event.pageY },
                normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function (event) {
            this._removeClass(this.handles, null, "ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function () {
            this.orientation =
                this.options.orientation === "vertical"
                    ? "vertical"
                    : "horizontal";
        },

        _normValueFromMouse: function (position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;

            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse =
                    position.x -
                    this.elementOffset.left -
                    (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse =
                    position.y -
                    this.elementOffset.top -
                    (this._clickOffset ? this._clickOffset.top : 0);
            }

            percentMouse = pixelMouse / pixelTotal;
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _uiHash: function (index, value, values) {
            var uiHash = {
                handle: this.handles[index],
                handleIndex: index,
                value: value !== undefined ? value : this.value(),
            };

            if (this._hasMultipleValues()) {
                uiHash.value = value !== undefined ? value : this.values(index);
                uiHash.values = values || this.values();
            }

            return uiHash;
        },

        _hasMultipleValues: function () {
            return this.options.values && this.options.values.length;
        },

        _start: function (event, index) {
            return this._trigger("start", event, this._uiHash(index));
        },

        _slide: function (event, index, newVal) {
            var allowed,
                otherVal,
                currentValue = this.value(),
                newValues = this.values();

            if (this._hasMultipleValues()) {
                otherVal = this.values(index ? 0 : 1);
                currentValue = this.values(index);

                if (
                    this.options.values.length === 2 &&
                    this.options.range === true
                ) {
                    newVal =
                        index === 0
                            ? Math.min(otherVal, newVal)
                            : Math.max(otherVal, newVal);
                }

                newValues[index] = newVal;
            }

            if (newVal === currentValue) {
                return;
            }

            allowed = this._trigger(
                "slide",
                event,
                this._uiHash(index, newVal, newValues)
            );

            // A slide can be canceled by returning false from the slide callback
            if (allowed === false) {
                return;
            }

            if (this._hasMultipleValues()) {
                this.values(index, newVal);
            } else {
                this.value(newVal);
            }
        },

        _stop: function (event, index) {
            this._trigger("stop", event, this._uiHash(index));
        },

        _change: function (event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;
                this._trigger("change", event, this._uiHash(index));
            }
        },

        value: function (newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },

        values: function (index, newValue) {
            var vals, newValues, i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if (Array.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this._hasMultipleValues()) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function (key, value) {
            var i,
                valsLength = 0;

            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(
                        this.options.values.length - 1
                    );
                    this.options.values = null;
                }
            }

            if (Array.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            this._super(key, value);

            switch (key) {
                case "orientation":
                    this._detectOrientation();
                    this._removeClass(
                        "ui-slider-horizontal ui-slider-vertical"
                    )._addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    if (this.options.range) {
                        this._refreshRange(value);
                    }

                    // Reset positioning from previous orientation
                    this.handles.css(
                        value === "horizontal" ? "bottom" : "left",
                        ""
                    );
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();

                    // Start from the last handle to prevent unreachable handles (#9046)
                    for (i = valsLength - 1; i >= 0; i--) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = true;
                    this._calculateNewMax();
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        _setOptionDisabled: function (value) {
            this._super(value);

            this._toggleClass(null, "ui-state-disabled", !!value);
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function () {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function (index) {
            var val, vals, i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else if (this._hasMultipleValues()) {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            } else {
                return [];
            }
        },

        // Returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function (val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = this.options.step > 0 ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += valModStep > 0 ? step : -step;
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _calculateNewMax: function () {
            var max = this.options.max,
                min = this._valueMin(),
                step = this.options.step,
                aboveMin = Math.round((max - min) / step) * step;
            max = aboveMin + min;
            if (max > this.options.max) {
                //If max is not divisible by step, rounding off may increase its value
                max -= step;
            }
            this.max = parseFloat(max.toFixed(this._precision()));
        },

        _precision: function () {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(
                    precision,
                    this._precisionOf(this.options.min)
                );
            }
            return precision;
        },

        _precisionOf: function (num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _valueMin: function () {
            return this.options.min;
        },

        _valueMax: function () {
            return this.max;
        },

        _refreshRange: function (orientation) {
            if (orientation === "vertical") {
                this.range.css({ width: "", left: "" });
            }
            if (orientation === "horizontal") {
                this.range.css({ height: "", bottom: "" });
            }
        },

        _refreshValue: function () {
            var lastValPercent,
                valPercent,
                value,
                valueMin,
                valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = !this._animateOff ? o.animate : false,
                _set = {};

            if (this._hasMultipleValues()) {
                this.handles.each(function (i) {
                    valPercent =
                        ((that.values(i) - that._valueMin()) /
                            (that._valueMax() - that._valueMin())) *
                        100;
                    _set[
                        that.orientation === "horizontal" ? "left" : "bottom"
                    ] = valPercent + "%";
                    $(this)
                        .stop(1, 1)
                        [animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range
                                    .stop(1, 1)
                                    [animate ? "animate" : "css"](
                                        {
                                            left: valPercent + "%",
                                        },
                                        o.animate
                                    );
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"](
                                    {
                                        width:
                                            valPercent - lastValPercent + "%",
                                    },
                                    {
                                        queue: false,
                                        duration: o.animate,
                                    }
                                );
                            }
                        } else {
                            if (i === 0) {
                                that.range
                                    .stop(1, 1)
                                    [animate ? "animate" : "css"](
                                        {
                                            bottom: valPercent + "%",
                                        },
                                        o.animate
                                    );
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"](
                                    {
                                        height:
                                            valPercent - lastValPercent + "%",
                                    },
                                    {
                                        queue: false,
                                        duration: o.animate,
                                    }
                                );
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent =
                    valueMax !== valueMin
                        ? ((value - valueMin) / (valueMax - valueMin)) * 100
                        : 0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] =
                    valPercent + "%";
                this.handle
                    .stop(1, 1)
                    [animate ? "animate" : "css"](_set, o.animate);

                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"](
                        {
                            width: valPercent + "%",
                        },
                        o.animate
                    );
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"](
                        {
                            width: 100 - valPercent + "%",
                        },
                        o.animate
                    );
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"](
                        {
                            height: valPercent + "%",
                        },
                        o.animate
                    );
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"](
                        {
                            height: 100 - valPercent + "%",
                        },
                        o.animate
                    );
                }
            }
        },

        _handleEvents: {
            keydown: function (event) {
                var allowed,
                    curVal,
                    newVal,
                    step,
                    index = $(event.target).data("ui-slider-handle-index");

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            this._addClass(
                                $(event.target),
                                null,
                                "ui-state-active"
                            );
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if (this._hasMultipleValues()) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(
                            curVal +
                                (this._valueMax() - this._valueMin()) /
                                    this.numPages
                        );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(
                            curVal -
                                (this._valueMax() - this._valueMin()) /
                                    this.numPages
                        );
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                }

                this._slide(event, index, newVal);
            },
            keyup: function (event) {
                var index = $(event.target).data("ui-slider-handle-index");

                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    this._removeClass($(event.target), null, "ui-state-active");
                }
            },
        },
    });

    /*!
     * jQuery UI Sortable 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Sortable
    //>>group: Interactions
    //>>description: Enables items in a list to be sorted using the mouse.
    //>>docs: http://api.jqueryui.com/sortable/
    //>>demos: http://jqueryui.com/sortable/
    //>>css.structure: ../../themes/base/sortable.css

    var widgetsSortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.13.2",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1000,

            // Callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null,
        },

        _isOverAxis: function (x, reference, size) {
            return x >= reference && x < reference + size;
        },

        _isFloating: function (item) {
            return (
                /left|right/.test(item.css("float")) ||
                /inline|table-cell/.test(item.css("display"))
            );
        },

        _create: function () {
            this.containerCache = {};
            this._addClass("ui-sortable");

            //Get the items
            this.refresh();

            //Let's determine the parent's offset
            this.offset = this.element.offset();

            //Initialize mouse events for interaction
            this._mouseInit();

            this._setHandleClassName();

            //We're ready to go
            this.ready = true;
        },

        _setOption: function (key, value) {
            this._super(key, value);

            if (key === "handle") {
                this._setHandleClassName();
            }
        },

        _setHandleClassName: function () {
            var that = this;
            this._removeClass(
                this.element.find(".ui-sortable-handle"),
                "ui-sortable-handle"
            );
            $.each(this.items, function () {
                that._addClass(
                    this.instance.options.handle
                        ? this.item.find(this.instance.options.handle)
                        : this.item,
                    "ui-sortable-handle"
                );
            });
        },

        _destroy: function () {
            this._mouseDestroy();

            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }

            return this;
        },

        _mouseCapture: function (event, overrideHandle) {
            var currentItem = null,
                validHandle = false,
                that = this;

            if (this.reverting) {
                return false;
            }

            if (this.options.disabled || this.options.type === "static") {
                return false;
            }

            //We have to refresh the items data once first
            this._refreshItems(event);

            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            $(event.target)
                .parents()
                .each(function () {
                    if ($.data(this, that.widgetName + "-item") === that) {
                        currentItem = $(this);
                        return false;
                    }
                });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }

            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem)
                    .find("*")
                    .addBack()
                    .each(function () {
                        if (this === event.target) {
                            validHandle = true;
                        }
                    });
                if (!validHandle) {
                    return false;
                }
            }

            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;
        },

        _mouseStart: function (event, overrideHandle, noActivation) {
            var i,
                body,
                o = this.options;

            this.currentContainer = this;

            //We only need to call refreshPositions, because the refreshItems call has been moved to
            // mouseCapture
            this.refreshPositions();

            //Prepare the dragged items parent
            this.appendTo = $(
                o.appendTo !== "parent" ? o.appendTo : this.currentItem.parent()
            );

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            //Cache the helper size
            this._cacheHelperProportions();

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left,
            };

            $.extend(this.offset, {
                click: {
                    //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top,
                },

                // This is a relative to absolute position minus the actual position calculation -
                // only used for relative positioned helper
                relative: this._getRelativeOffset(),
            });

            // After we get the helper offset, but before we get the parent offset we can
            // change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            if (o.cursorAt) {
                this._adjustOffsetFromHelper(o.cursorAt);
            }

            //Cache the former DOM position
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0],
            };

            // If the helper is not the original, hide the original so it's not playing any role during
            // the drag, won't cause anything bad this way
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }

            //Create the placeholder
            this._createPlaceholder();

            //Get the next scrolling parent
            this.scrollParent = this.placeholder.scrollParent();

            $.extend(this.offset, {
                parent: this._getParentOffset(),
            });

            //Set a containment if given in the options
            if (o.containment) {
                this._setContainment();
            }

            if (o.cursor && o.cursor !== "auto") {
                // cursor option
                body = this.document.find("body");

                // Support: IE
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);

                this.storedStylesheet = $(
                    "<style>*{ cursor: " + o.cursor + " !important; }</style>"
                ).appendTo(body);
            }

            // We need to make sure to grab the zIndex before setting the
            // opacity, because setting the opacity to anything lower than 1
            // causes the zIndex to change from "auto" to 0.
            if (o.zIndex) {
                // zIndex option
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }

            if (o.opacity) {
                // opacity option
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }

            //Prepare scrolling
            if (
                this.scrollParent[0] !== this.document[0] &&
                this.scrollParent[0].tagName !== "HTML"
            ) {
                this.overflowOffset = this.scrollParent.offset();
            }

            //Call callbacks
            this._trigger("start", event, this._uiHash());

            //Recache the helper size
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }

            //Post "activate" events to possible containers
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger(
                        "activate",
                        event,
                        this._uiHash(this)
                    );
                }
            }

            //Prepare possible droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            this.dragging = true;

            this._addClass(this.helper, "ui-sortable-helper");

            //Move the helper, if needed
            if (!this.helper.parent().is(this.appendTo)) {
                this.helper.detach().appendTo(this.appendTo);

                //Update position
                this.offset.parent = this._getParentOffset();
            }

            //Generate the original position
            this.position = this.originalPosition =
                this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            this.lastPositionAbs = this.positionAbs =
                this._convertPositionTo("absolute");

            this._mouseDrag(event);

            return true;
        },

        _scroll: function (event) {
            var o = this.options,
                scrolled = false;

            if (
                this.scrollParent[0] !== this.document[0] &&
                this.scrollParent[0].tagName !== "HTML"
            ) {
                if (
                    this.overflowOffset.top +
                        this.scrollParent[0].offsetHeight -
                        event.pageY <
                    o.scrollSensitivity
                ) {
                    this.scrollParent[0].scrollTop = scrolled =
                        this.scrollParent[0].scrollTop + o.scrollSpeed;
                } else if (
                    event.pageY - this.overflowOffset.top <
                    o.scrollSensitivity
                ) {
                    this.scrollParent[0].scrollTop = scrolled =
                        this.scrollParent[0].scrollTop - o.scrollSpeed;
                }

                if (
                    this.overflowOffset.left +
                        this.scrollParent[0].offsetWidth -
                        event.pageX <
                    o.scrollSensitivity
                ) {
                    this.scrollParent[0].scrollLeft = scrolled =
                        this.scrollParent[0].scrollLeft + o.scrollSpeed;
                } else if (
                    event.pageX - this.overflowOffset.left <
                    o.scrollSensitivity
                ) {
                    this.scrollParent[0].scrollLeft = scrolled =
                        this.scrollParent[0].scrollLeft - o.scrollSpeed;
                }
            } else {
                if (
                    event.pageY - this.document.scrollTop() <
                    o.scrollSensitivity
                ) {
                    scrolled = this.document.scrollTop(
                        this.document.scrollTop() - o.scrollSpeed
                    );
                } else if (
                    this.window.height() -
                        (event.pageY - this.document.scrollTop()) <
                    o.scrollSensitivity
                ) {
                    scrolled = this.document.scrollTop(
                        this.document.scrollTop() + o.scrollSpeed
                    );
                }

                if (
                    event.pageX - this.document.scrollLeft() <
                    o.scrollSensitivity
                ) {
                    scrolled = this.document.scrollLeft(
                        this.document.scrollLeft() - o.scrollSpeed
                    );
                } else if (
                    this.window.width() -
                        (event.pageX - this.document.scrollLeft()) <
                    o.scrollSensitivity
                ) {
                    scrolled = this.document.scrollLeft(
                        this.document.scrollLeft() + o.scrollSpeed
                    );
                }
            }

            return scrolled;
        },

        _mouseDrag: function (event) {
            var i,
                item,
                itemElement,
                intersection,
                o = this.options;

            //Compute the helpers position
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");

            //Set the helper position
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }

            //Do scrolling
            if (o.scroll) {
                if (this._scroll(event) !== false) {
                    //Update item positions used in position checks
                    this._refreshItemPositions(true);

                    if ($.ui.ddmanager && !o.dropBehaviour) {
                        $.ui.ddmanager.prepareOffsets(this, event);
                    }
                }
            }

            this.dragDirection = {
                vertical: this._getDragVerticalDirection(),
                horizontal: this._getDragHorizontalDirection(),
            };

            //Rearrange
            for (i = this.items.length - 1; i >= 0; i--) {
                //Cache variables and intersection, continue if no intersection
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }

                // Only put the placeholder inside the current Container, skip all
                // items from other containers. This works because when moving
                // an item from one container to another the
                // currentContainer is switched before the placeholder is moved.
                //
                // Without this, moving items in "sub-sortables" can cause
                // the placeholder to jitter between the outer and inner container.
                if (item.instance !== this.currentContainer) {
                    continue;
                }

                // Cannot intersect with itself
                // no useless actions that have been done before
                // no action if the item moved is the parent of the item checked
                if (
                    itemElement !== this.currentItem[0] &&
                    this.placeholder[
                        intersection === 1 ? "next" : "prev"
                    ]()[0] !== itemElement &&
                    !$.contains(this.placeholder[0], itemElement) &&
                    (this.options.type === "semi-dynamic"
                        ? !$.contains(this.element[0], itemElement)
                        : true)
                ) {
                    this.direction = intersection === 1 ? "down" : "up";

                    if (
                        this.options.tolerance === "pointer" ||
                        this._intersectsWithSides(item)
                    ) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }

                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }

            //Post events to containers
            this._contactContainers(event);

            //Interconnect with droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            //Call callbacks
            this._trigger("sort", event, this._uiHash());

            this.lastPositionAbs = this.positionAbs;
            return false;
        },

        _mouseStop: function (event, noPropagation) {
            if (!event) {
                return;
            }

            //If we are using droppables, inform the manager about the drop
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }

            if (this.options.revert) {
                var that = this,
                    cur = this.placeholder.offset(),
                    axis = this.options.axis,
                    animation = {};

                if (!axis || axis === "x") {
                    animation.left =
                        cur.left -
                        this.offset.parent.left -
                        this.margins.left +
                        (this.offsetParent[0] === this.document[0].body
                            ? 0
                            : this.offsetParent[0].scrollLeft);
                }
                if (!axis || axis === "y") {
                    animation.top =
                        cur.top -
                        this.offset.parent.top -
                        this.margins.top +
                        (this.offsetParent[0] === this.document[0].body
                            ? 0
                            : this.offsetParent[0].scrollTop);
                }
                this.reverting = true;
                $(this.helper).animate(
                    animation,
                    parseInt(this.options.revert, 10) || 500,
                    function () {
                        that._clear(event);
                    }
                );
            } else {
                this._clear(event, noPropagation);
            }

            return false;
        },

        cancel: function () {
            if (this.dragging) {
                this._mouseUp(new $.Event("mouseup", { target: null }));

                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS);
                    this._removeClass(this.currentItem, "ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }

                //Post deactivating events to containers
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger(
                        "deactivate",
                        null,
                        this._uiHash(this)
                    );
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger(
                            "out",
                            null,
                            this._uiHash(this)
                        );
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }

            if (this.placeholder) {
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
                // it unbinds ALL events from the original node!
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(
                        this.placeholder[0]
                    );
                }
                if (
                    this.options.helper !== "original" &&
                    this.helper &&
                    this.helper[0].parentNode
                ) {
                    this.helper.remove();
                }

                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null,
                });

                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }

            return this;
        },

        serialize: function (o) {
            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            o = o || {};

            $(items).each(function () {
                var res = (
                    $(o.item || this).attr(o.attribute || "id") || ""
                ).match(o.expression || /(.+)[\-=_](.+)/);
                if (res) {
                    str.push(
                        (o.key || res[1] + "[]") +
                            "=" +
                            (o.key && o.expression ? res[1] : res[2])
                    );
                }
            });

            if (!str.length && o.key) {
                str.push(o.key + "=");
            }

            return str.join("&");
        },

        toArray: function (o) {
            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];

            o = o || {};

            items.each(function () {
                ret.push($(o.item || this).attr(o.attribute || "id") || "");
            });
            return ret;
        },

        /* Be careful with the following core functions */
        _intersectsWith: function (item) {
            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElementHeight =
                    this.options.axis === "x" ||
                    (y1 + dyClick > t && y1 + dyClick < b),
                isOverElementWidth =
                    this.options.axis === "y" ||
                    (x1 + dxClick > l && x1 + dxClick < r),
                isOverElement = isOverElementHeight && isOverElementWidth;

            if (
                this.options.tolerance === "pointer" ||
                this.options.forcePointerForContainers ||
                (this.options.tolerance !== "pointer" &&
                    this.helperProportions[this.floating ? "width" : "height"] >
                        item[this.floating ? "width" : "height"])
            ) {
                return isOverElement;
            } else {
                return (
                    l < x1 + this.helperProportions.width / 2 && // Right Half
                    x2 - this.helperProportions.width / 2 < r && // Left Half
                    t < y1 + this.helperProportions.height / 2 && // Bottom Half
                    y2 - this.helperProportions.height / 2 < b
                ); // Top Half
            }
        },

        _intersectsWithPointer: function (item) {
            var verticalDirection,
                horizontalDirection,
                isOverElementHeight =
                    this.options.axis === "x" ||
                    this._isOverAxis(
                        this.positionAbs.top + this.offset.click.top,
                        item.top,
                        item.height
                    ),
                isOverElementWidth =
                    this.options.axis === "y" ||
                    this._isOverAxis(
                        this.positionAbs.left + this.offset.click.left,
                        item.left,
                        item.width
                    ),
                isOverElement = isOverElementHeight && isOverElementWidth;

            if (!isOverElement) {
                return false;
            }

            verticalDirection = this.dragDirection.vertical;
            horizontalDirection = this.dragDirection.horizontal;

            return this.floating
                ? horizontalDirection === "right" ||
                  verticalDirection === "down"
                    ? 2
                    : 1
                : verticalDirection && (verticalDirection === "down" ? 2 : 1);
        },

        _intersectsWithSides: function (item) {
            var isOverBottomHalf = this._isOverAxis(
                    this.positionAbs.top + this.offset.click.top,
                    item.top + item.height / 2,
                    item.height
                ),
                isOverRightHalf = this._isOverAxis(
                    this.positionAbs.left + this.offset.click.left,
                    item.left + item.width / 2,
                    item.width
                ),
                verticalDirection = this.dragDirection.vertical,
                horizontalDirection = this.dragDirection.horizontal;

            if (this.floating && horizontalDirection) {
                return (
                    (horizontalDirection === "right" && isOverRightHalf) ||
                    (horizontalDirection === "left" && !isOverRightHalf)
                );
            } else {
                return (
                    verticalDirection &&
                    ((verticalDirection === "down" && isOverBottomHalf) ||
                        (verticalDirection === "up" && !isOverBottomHalf))
                );
            }
        },

        _getDragVerticalDirection: function () {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },

        _getDragHorizontalDirection: function () {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },

        refresh: function (event) {
            this._refreshItems(event);
            this._setHandleClassName();
            this.refreshPositions();
            return this;
        },

        _connectWith: function () {
            var options = this.options;
            return options.connectWith.constructor === String
                ? [options.connectWith]
                : options.connectWith;
        },

        _getItemsAsjQuery: function (connected) {
            var i,
                j,
                cur,
                inst,
                items = [],
                queries = [],
                connectWith = this._connectWith();

            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([
                                typeof inst.options.items === "function"
                                    ? inst.options.items.call(inst.element)
                                    : $(inst.options.items, inst.element)
                                          .not(".ui-sortable-helper")
                                          .not(".ui-sortable-placeholder"),
                                inst,
                            ]);
                        }
                    }
                }
            }

            queries.push([
                typeof this.options.items === "function"
                    ? this.options.items.call(this.element, null, {
                          options: this.options,
                          item: this.currentItem,
                      })
                    : $(this.options.items, this.element)
                          .not(".ui-sortable-helper")
                          .not(".ui-sortable-placeholder"),
                this,
            ]);

            function addItems() {
                items.push(this);
            }

            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(addItems);
            }

            return $(items);
        },

        _removeCurrentsFromItems: function () {
            var list = this.currentItem.find(
                ":data(" + this.widgetName + "-item)"
            );

            this.items = $.grep(this.items, function (item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });
        },

        _refreshItems: function (event) {
            this.items = [];
            this.containers = [this];

            var i,
                j,
                cur,
                inst,
                targetData,
                _queries,
                item,
                queriesLength,
                items = this.items,
                queries = [
                    [
                        typeof this.options.items === "function"
                            ? this.options.items.call(this.element[0], event, {
                                  item: this.currentItem,
                              })
                            : $(this.options.items, this.element),
                        this,
                    ],
                ],
                connectWith = this._connectWith();

            //Shouldn't be run the first time through due to massive slow-down
            if (connectWith && this.ready) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([
                                typeof inst.options.items === "function"
                                    ? inst.options.items.call(
                                          inst.element[0],
                                          event,
                                          { item: this.currentItem }
                                      )
                                    : $(inst.options.items, inst.element),
                                inst,
                            ]);
                            this.containers.push(inst);
                        }
                    }
                }
            }

            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];

                for (
                    j = 0, queriesLength = _queries.length;
                    j < queriesLength;
                    j++
                ) {
                    item = $(_queries[j]);

                    // Data for target checking (mouse manager)
                    item.data(this.widgetName + "-item", targetData);

                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0,
                    });
                }
            }
        },

        _refreshItemPositions: function (fast) {
            var i, item, t, p;

            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];

                //We ignore calculating positions of all connected containers when we're not over them
                if (
                    this.currentContainer &&
                    item.instance !== this.currentContainer &&
                    item.item[0] !== this.currentItem[0]
                ) {
                    continue;
                }

                t = this.options.toleranceElement
                    ? $(this.options.toleranceElement, item.item)
                    : item.item;

                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }

                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }
        },

        refreshPositions: function (fast) {
            // Determine whether items are being displayed horizontally
            this.floating = this.items.length
                ? this.options.axis === "x" ||
                  this._isFloating(this.items[0].item)
                : false;

            // This has to be redone because due to the item being moved out/into the offsetParent,
            // the offsetParent's position will change
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }

            this._refreshItemPositions(fast);

            var i, p;

            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width =
                        this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height =
                        this.containers[i].element.outerHeight();
                }
            }

            return this;
        },

        _createPlaceholder: function (that) {
            that = that || this;
            var className,
                nodeName,
                o = that.options;

            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                nodeName = that.currentItem[0].nodeName.toLowerCase();
                o.placeholder = {
                    element: function () {
                        var element = $("<" + nodeName + ">", that.document[0]);

                        that._addClass(
                            element,
                            "ui-sortable-placeholder",
                            className || that.currentItem[0].className
                        )._removeClass(element, "ui-sortable-helper");

                        if (nodeName === "tbody") {
                            that._createTrPlaceholder(
                                that.currentItem.find("tr").eq(0),
                                $("<tr>", that.document[0]).appendTo(element)
                            );
                        } else if (nodeName === "tr") {
                            that._createTrPlaceholder(
                                that.currentItem,
                                element
                            );
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }

                        if (!className) {
                            element.css("visibility", "hidden");
                        }

                        return element;
                    },
                    update: function (container, p) {
                        // 1. If a className is set as 'placeholder option, we don't force sizes -
                        // the class is responsible for that
                        // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
                        // class name is specified
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }

                        // If the element doesn't have a actual height or width by itself (without
                        // styles coming from a stylesheet), it receives the inline height and width
                        // from the dragged item. Or, if it's a tbody or tr, it's going to have a height
                        // anyway since we're populating them with <td>s above, but they're unlikely to
                        // be the correct height on their own if the row heights are dynamic, so we'll
                        // always assign the height of the dragged item given forcePlaceholderSize
                        // is true.
                        if (
                            !p.height() ||
                            (o.forcePlaceholderSize &&
                                (nodeName === "tbody" || nodeName === "tr"))
                        ) {
                            p.height(
                                that.currentItem.innerHeight() -
                                    parseInt(
                                        that.currentItem.css("paddingTop") || 0,
                                        10
                                    ) -
                                    parseInt(
                                        that.currentItem.css("paddingBottom") ||
                                            0,
                                        10
                                    )
                            );
                        }
                        if (!p.width()) {
                            p.width(
                                that.currentItem.innerWidth() -
                                    parseInt(
                                        that.currentItem.css("paddingLeft") ||
                                            0,
                                        10
                                    ) -
                                    parseInt(
                                        that.currentItem.css("paddingRight") ||
                                            0,
                                        10
                                    )
                            );
                        }
                    },
                };
            }

            //Create the placeholder
            that.placeholder = $(
                o.placeholder.element.call(that.element, that.currentItem)
            );

            //Append it after the actual current item
            that.currentItem.after(that.placeholder);

            //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update(that, that.placeholder);
        },

        _createTrPlaceholder: function (sourceTr, targetTr) {
            var that = this;

            sourceTr.children().each(function () {
                $("<td>&#160;</td>", that.document[0])
                    .attr("colspan", $(this).attr("colspan") || 1)
                    .appendTo(targetTr);
            });
        },

        _contactContainers: function (event) {
            var i,
                j,
                dist,
                itemWithLeastDistance,
                posProperty,
                sizeProperty,
                cur,
                nearBottom,
                floating,
                axis,
                innermostContainer = null,
                innermostIndex = null;

            // Get innermost container that intersects with item
            for (i = this.containers.length - 1; i >= 0; i--) {
                // Never consider a container that's located within the item itself
                if (
                    $.contains(
                        this.currentItem[0],
                        this.containers[i].element[0]
                    )
                ) {
                    continue;
                }

                if (this._intersectsWith(this.containers[i].containerCache)) {
                    // If we've already found a container and it's more "inner" than this, then continue
                    if (
                        innermostContainer &&
                        $.contains(
                            this.containers[i].element[0],
                            innermostContainer.element[0]
                        )
                    ) {
                        continue;
                    }

                    innermostContainer = this.containers[i];
                    innermostIndex = i;
                } else {
                    // container doesn't intersect. trigger "out" event if necessary
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger(
                            "out",
                            event,
                            this._uiHash(this)
                        );
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }

            // If no intersecting containers found, return
            if (!innermostContainer) {
                return;
            }

            // Move the item into the container if it's not there already
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger(
                        "over",
                        event,
                        this._uiHash(this)
                    );
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {
                // When entering a new container, we will find the item with the least distance and
                // append our item near it
                dist = 10000;
                itemWithLeastDistance = null;
                floating =
                    innermostContainer.floating ||
                    this._isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "pageX" : "pageY";

                for (j = this.items.length - 1; j >= 0; j--) {
                    if (
                        !$.contains(
                            this.containers[innermostIndex].element[0],
                            this.items[j].item[0]
                        )
                    ) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }

                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                        nearBottom = true;
                    }

                    if (Math.abs(event[axis] - cur) < dist) {
                        dist = Math.abs(event[axis] - cur);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }

                //Check if dropOnEmpty is enabled
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }

                if (this.currentContainer === this.containers[innermostIndex]) {
                    if (!this.currentContainer.containerCache.over) {
                        this.containers[innermostIndex]._trigger(
                            "over",
                            event,
                            this._uiHash()
                        );
                        this.currentContainer.containerCache.over = 1;
                    }
                    return;
                }

                if (itemWithLeastDistance) {
                    this._rearrange(event, itemWithLeastDistance, null, true);
                } else {
                    this._rearrange(
                        event,
                        null,
                        this.containers[innermostIndex].element,
                        true
                    );
                }
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger(
                    "change",
                    event,
                    this._uiHash(this)
                );
                this.currentContainer = this.containers[innermostIndex];

                //Update the placeholder
                this.options.placeholder.update(
                    this.currentContainer,
                    this.placeholder
                );

                //Update scrollParent
                this.scrollParent = this.placeholder.scrollParent();

                //Update overflowOffset
                if (
                    this.scrollParent[0] !== this.document[0] &&
                    this.scrollParent[0].tagName !== "HTML"
                ) {
                    this.overflowOffset = this.scrollParent.offset();
                }

                this.containers[innermostIndex]._trigger(
                    "over",
                    event,
                    this._uiHash(this)
                );
                this.containers[innermostIndex].containerCache.over = 1;
            }
        },

        _createHelper: function (event) {
            var o = this.options,
                helper =
                    typeof o.helper === "function"
                        ? $(
                              o.helper.apply(this.element[0], [
                                  event,
                                  this.currentItem,
                              ])
                          )
                        : o.helper === "clone"
                        ? this.currentItem.clone()
                        : this.currentItem;

            //Add the helper to the DOM if that didn't happen already
            if (!helper.parents("body").length) {
                this.appendTo[0].appendChild(helper[0]);
            }

            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left"),
                };
            }

            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }

            return helper;
        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if (Array.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left =
                    this.helperProportions.width -
                    obj.right +
                    this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top =
                    this.helperProportions.height -
                    obj.bottom +
                    this.margins.top;
            }
        },

        _getParentOffset: function () {
            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();

            // This is a special case where we need to modify a offset calculated on start, since the
            // following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the
            // next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
            // the document, which means that the scroll is included in the initial calculation of the
            // offset of the parent, and never recalculated upon drag
            if (
                this.cssPosition === "absolute" &&
                this.scrollParent[0] !== this.document[0] &&
                $.contains(this.scrollParent[0], this.offsetParent[0])
            ) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            // This needs to be actually done for all browsers, since pageX/pageY includes this
            // information with an ugly IE fix
            if (
                this.offsetParent[0] === this.document[0].body ||
                (this.offsetParent[0].tagName &&
                    this.offsetParent[0].tagName.toLowerCase() === "html" &&
                    $.ui.ie)
            ) {
                po = { top: 0, left: 0 };
            }

            return {
                top:
                    po.top +
                    (parseInt(this.offsetParent.css("borderTopWidth"), 10) ||
                        0),
                left:
                    po.left +
                    (parseInt(this.offsetParent.css("borderLeftWidth"), 10) ||
                        0),
            };
        },

        _getRelativeOffset: function () {
            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top:
                        p.top -
                        (parseInt(this.helper.css("top"), 10) || 0) +
                        this.scrollParent.scrollTop(),
                    left:
                        p.left -
                        (parseInt(this.helper.css("left"), 10) || 0) +
                        this.scrollParent.scrollLeft(),
                };
            } else {
                return { top: 0, left: 0 };
            }
        },

        _cacheMargins: function () {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0,
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight(),
            };
        },

        _setContainment: function () {
            var ce,
                co,
                over,
                o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [
                    0 - this.offset.relative.left - this.offset.parent.left,
                    0 - this.offset.relative.top - this.offset.parent.top,
                    o.containment === "document"
                        ? this.document.width()
                        : this.window.width() -
                          this.helperProportions.width -
                          this.margins.left,
                    (o.containment === "document"
                        ? this.document.height() ||
                          document.body.parentNode.scrollHeight
                        : this.window.height() ||
                          this.document[0].body.parentNode.scrollHeight) -
                        this.helperProportions.height -
                        this.margins.top,
                ];
            }

            if (!/^(document|window|parent)$/.test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = $(ce).css("overflow") !== "hidden";

                this.containment = [
                    co.left +
                        (parseInt($(ce).css("borderLeftWidth"), 10) || 0) +
                        (parseInt($(ce).css("paddingLeft"), 10) || 0) -
                        this.margins.left,
                    co.top +
                        (parseInt($(ce).css("borderTopWidth"), 10) || 0) +
                        (parseInt($(ce).css("paddingTop"), 10) || 0) -
                        this.margins.top,
                    co.left +
                        (over
                            ? Math.max(ce.scrollWidth, ce.offsetWidth)
                            : ce.offsetWidth) -
                        (parseInt($(ce).css("borderLeftWidth"), 10) || 0) -
                        (parseInt($(ce).css("paddingRight"), 10) || 0) -
                        this.helperProportions.width -
                        this.margins.left,
                    co.top +
                        (over
                            ? Math.max(ce.scrollHeight, ce.offsetHeight)
                            : ce.offsetHeight) -
                        (parseInt($(ce).css("borderTopWidth"), 10) || 0) -
                        (parseInt($(ce).css("paddingBottom"), 10) || 0) -
                        this.helperProportions.height -
                        this.margins.top,
                ];
            }
        },

        _convertPositionTo: function (d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1,
                scroll =
                    this.cssPosition === "absolute" &&
                    !(
                        this.scrollParent[0] !== this.document[0] &&
                        $.contains(this.scrollParent[0], this.offsetParent[0])
                    )
                        ? this.offsetParent
                        : this.scrollParent,
                scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

            return {
                top:
                    // The absolute mouse position
                    pos.top +
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top * mod +
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top * mod -
                    (this.cssPosition === "fixed"
                        ? -this.scrollParent.scrollTop()
                        : scrollIsRootNode
                        ? 0
                        : scroll.scrollTop()) *
                        mod,
                left:
                    // The absolute mouse position
                    pos.left +
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left * mod +
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left * mod -
                    (this.cssPosition === "fixed"
                        ? -this.scrollParent.scrollLeft()
                        : scrollIsRootNode
                        ? 0
                        : scroll.scrollLeft()) *
                        mod,
            };
        },

        _generatePosition: function (event) {
            var top,
                left,
                o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll =
                    this.cssPosition === "absolute" &&
                    !(
                        this.scrollParent[0] !== this.document[0] &&
                        $.contains(this.scrollParent[0], this.offsetParent[0])
                    )
                        ? this.offsetParent
                        : this.scrollParent,
                scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);

            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            if (
                this.cssPosition === "relative" &&
                !(
                    this.scrollParent[0] !== this.document[0] &&
                    this.scrollParent[0] !== this.offsetParent[0]
                )
            ) {
                this.offset.relative = this._getRelativeOffset();
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            if (this.originalPosition) {
                //If we are not dragging yet, we won't check for options

                if (this.containment) {
                    if (
                        event.pageX - this.offset.click.left <
                        this.containment[0]
                    ) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (
                        event.pageY - this.offset.click.top <
                        this.containment[1]
                    ) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (
                        event.pageX - this.offset.click.left >
                        this.containment[2]
                    ) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (
                        event.pageY - this.offset.click.top >
                        this.containment[3]
                    ) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    top =
                        this.originalPageY +
                        Math.round((pageY - this.originalPageY) / o.grid[1]) *
                            o.grid[1];
                    pageY = this.containment
                        ? top - this.offset.click.top >= this.containment[1] &&
                          top - this.offset.click.top <= this.containment[3]
                            ? top
                            : top - this.offset.click.top >= this.containment[1]
                            ? top - o.grid[1]
                            : top + o.grid[1]
                        : top;

                    left =
                        this.originalPageX +
                        Math.round((pageX - this.originalPageX) / o.grid[0]) *
                            o.grid[0];
                    pageX = this.containment
                        ? left - this.offset.click.left >=
                              this.containment[0] &&
                          left - this.offset.click.left <= this.containment[2]
                            ? left
                            : left - this.offset.click.left >=
                              this.containment[0]
                            ? left - o.grid[0]
                            : left + o.grid[0]
                        : left;
                }
            }

            return {
                top:
                    // The absolute mouse position
                    pageY -
                    // Click offset (relative to the element)
                    this.offset.click.top -
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.top -
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.top +
                    (this.cssPosition === "fixed"
                        ? -this.scrollParent.scrollTop()
                        : scrollIsRootNode
                        ? 0
                        : scroll.scrollTop()),
                left:
                    // The absolute mouse position
                    pageX -
                    // Click offset (relative to the element)
                    this.offset.click.left -
                    // Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.relative.left -
                    // The offsetParent's offset without borders (offset + border)
                    this.offset.parent.left +
                    (this.cssPosition === "fixed"
                        ? -this.scrollParent.scrollLeft()
                        : scrollIsRootNode
                        ? 0
                        : scroll.scrollLeft()),
            };
        },

        _rearrange: function (event, i, a, hardRefresh) {
            if (a) {
                a[0].appendChild(this.placeholder[0]);
            } else {
                i.item[0].parentNode.insertBefore(
                    this.placeholder[0],
                    this.direction === "down"
                        ? i.item[0]
                        : i.item[0].nextSibling
                );
            }

            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout,
            // if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;

            this._delay(function () {
                if (counter === this.counter) {
                    //Precompute after each DOM insertion, NOT on mousemove
                    this.refreshPositions(!hardRefresh);
                }
            });
        },

        _clear: function (event, noPropagation) {
            this.reverting = false;

            // We delay all events that have to be triggered to after the point where the placeholder
            // has been removed and everything else normalized again
            var i,
                delayedTriggers = [];

            // We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets
            // reappended (see #4088)
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;

            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (
                        this._storedCSS[i] === "auto" ||
                        this._storedCSS[i] === "static"
                    ) {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS);
                this._removeClass(this.currentItem, "ui-sortable-helper");
            } else {
                this.currentItem.show();
            }

            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function (event) {
                    this._trigger(
                        "receive",
                        event,
                        this._uiHash(this.fromOutside)
                    );
                });
            }
            if (
                (this.fromOutside ||
                    this.domPosition.prev !==
                        this.currentItem.prev().not(".ui-sortable-helper")[0] ||
                    this.domPosition.parent !== this.currentItem.parent()[0]) &&
                !noPropagation
            ) {
                // Trigger update callback if the DOM position has changed
                delayedTriggers.push(function (event) {
                    this._trigger("update", event, this._uiHash());
                });
            }

            // Check if the items Container has Changed and trigger appropriate
            // events.
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function (event) {
                        this._trigger("remove", event, this._uiHash());
                    });
                    delayedTriggers.push(
                        function (c) {
                            return function (event) {
                                c._trigger(
                                    "receive",
                                    event,
                                    this._uiHash(this)
                                );
                            };
                        }.call(this, this.currentContainer)
                    );
                    delayedTriggers.push(
                        function (c) {
                            return function (event) {
                                c._trigger("update", event, this._uiHash(this));
                            };
                        }.call(this, this.currentContainer)
                    );
                }
            }

            //Post events to containers
            function delayEvent(type, instance, container) {
                return function (event) {
                    container._trigger(type, event, instance._uiHash(instance));
                };
            }

            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push(
                        delayEvent("deactivate", this, this.containers[i])
                    );
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(
                        delayEvent("out", this, this.containers[i])
                    );
                    this.containers[i].containerCache.over = 0;
                }
            }

            //Do what was originally in plugins
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css(
                    "zIndex",
                    this._storedZIndex === "auto" ? "" : this._storedZIndex
                );
            }

            this.dragging = false;

            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }

            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
            // it unbinds ALL events from the original node!
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

            if (!this.cancelHelperRemoval) {
                if (this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
            }

            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    // Trigger all delayed events
                    delayedTriggers[i].call(this, event);
                }
                this._trigger("stop", event, this._uiHash());
            }

            this.fromOutside = false;
            return !this.cancelHelperRemoval;
        },

        _trigger: function () {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },

        _uiHash: function (_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null,
            };
        },
    });

    /*!
     * jQuery UI Spinner 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Spinner
    //>>group: Widgets
    //>>description: Displays buttons to easily input numbers via the keyboard or mouse.
    //>>docs: http://api.jqueryui.com/spinner/
    //>>demos: http://jqueryui.com/spinner/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/spinner.css
    //>>css.theme: ../../themes/base/theme.css

    function spinnerModifier(fn) {
        return function () {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }

    $.widget("ui.spinner", {
        version: "1.13.2",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            classes: {
                "ui-spinner": "ui-corner-all",
                "ui-spinner-down": "ui-corner-br",
                "ui-spinner-up": "ui-corner-tr",
            },
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n",
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,

            change: null,
            spin: null,
            start: null,
            stop: null,
        },

        _create: function () {
            // handle string values that need to be parsed
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);

            // Only format if there is a value, prevents the field from being marked
            // as invalid in Firefox, see #9573.
            if (this.value() !== "") {
                // Format the value, but don't constrain.
                this._value(this.element.val(), true);
            }

            this._draw();
            this._on(this._events);
            this._refresh();

            // Turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                },
            });
        },

        _getCreateOptions: function () {
            var options = this._super();
            var element = this.element;

            $.each(["min", "max", "step"], function (i, option) {
                var value = element.attr(option);
                if (value != null && value.length) {
                    options[option] = value;
                }
            });

            return options;
        },

        _events: {
            keydown: function (event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function () {
                this.previous = this.element.val();
            },
            blur: function (event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }

                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function (event, delta) {
                var activeElement = $.ui.safeActiveElement(this.document[0]);
                var isActive = this.element[0] === activeElement;

                if (!isActive || !delta) {
                    return;
                }

                if (!this.spinning && !this._start(event)) {
                    return false;
                }

                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function () {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function (event) {
                var previous;

                // We never want the buttons to have focus; whenever the user is
                // interacting with the spinner, the focus should be on the input.
                // If the input is focused then this.previous is properly set from
                // when the input first received focus. If the input is not focused
                // then we need to set this.previous based on the value before spinning.
                previous =
                    this.element[0] === $.ui.safeActiveElement(this.document[0])
                        ? this.previous
                        : this.element.val();

                function checkFocus() {
                    var isActive =
                        this.element[0] ===
                        $.ui.safeActiveElement(this.document[0]);
                    if (!isActive) {
                        this.element.trigger("focus");
                        this.previous = previous;

                        // support: IE
                        // IE sets focus asynchronously, so we need to check if focus
                        // moved off of the input because the user clicked on the button.
                        this._delay(function () {
                            this.previous = previous;
                        });
                    }
                }

                // Ensure focus is on (or stays on) the text field
                event.preventDefault();
                checkFocus.call(this);

                // Support: IE
                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                // and check (again) if focus moved off of the input.
                this.cancelBlur = true;
                this._delay(function () {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });

                if (this._start(event) === false) {
                    return;
                }

                this._repeat(
                    null,
                    $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1,
                    event
                );
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function (event) {
                // button will add ui-state-active if mouse was down while mouseleave and kept down
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }

                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(
                    null,
                    $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1,
                    event
                );
            },

            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .ui-spinner-button": "_stop",
        },

        // Support mobile enhanced option and make backcompat more sane
        _enhance: function () {
            this.uiSpinner = this.element
                .attr("autocomplete", "off")
                .wrap("<span>")
                .parent()

                // Add buttons
                .append("<a></a><a></a>");
        },

        _draw: function () {
            this._enhance();

            this._addClass(
                this.uiSpinner,
                "ui-spinner",
                "ui-widget ui-widget-content"
            );
            this._addClass("ui-spinner-input");

            this.element.attr("role", "spinbutton");

            // Button bindings
            this.buttons = this.uiSpinner
                .children("a")
                .attr("tabIndex", -1)
                .attr("aria-hidden", true)
                .button({
                    classes: {
                        "ui-button": "",
                    },
                });

            // TODO: Right now button does not support classes this is already updated in button PR
            this._removeClass(this.buttons, "ui-corner-all");

            this._addClass(
                this.buttons.first(),
                "ui-spinner-button ui-spinner-up"
            );
            this._addClass(
                this.buttons.last(),
                "ui-spinner-button ui-spinner-down"
            );
            this.buttons.first().button({
                icon: this.options.icons.up,
                showLabel: false,
            });
            this.buttons.last().button({
                icon: this.options.icons.down,
                showLabel: false,
            });

            // IE 6 doesn't understand height: 50% for the buttons
            // unless the wrapper has an explicit height
            if (
                this.buttons.height() >
                    Math.ceil(this.uiSpinner.height() * 0.5) &&
                this.uiSpinner.height() > 0
            ) {
                this.uiSpinner.height(this.uiSpinner.height());
            }
        },

        _keydown: function (event) {
            var options = this.options,
                keyCode = $.ui.keyCode;

            switch (event.keyCode) {
                case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;
                case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;
                case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;
                case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
            }

            return false;
        },

        _start: function (event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }

            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },

        _repeat: function (i, steps, event) {
            i = i || 500;

            clearTimeout(this.timer);
            this.timer = this._delay(function () {
                this._repeat(40, steps, event);
            }, i);

            this._spin(steps * this.options.step, event);
        },

        _spin: function (step, event) {
            var value = this.value() || 0;

            if (!this.counter) {
                this.counter = 1;
            }

            value = this._adjustValue(
                value + step * this._increment(this.counter)
            );

            if (
                !this.spinning ||
                this._trigger("spin", event, { value: value }) !== false
            ) {
                this._value(value);
                this.counter++;
            }
        },

        _increment: function (i) {
            var incremental = this.options.incremental;

            if (incremental) {
                return typeof incremental === "function"
                    ? incremental(i)
                    : Math.floor(
                          (i * i * i) / 50000 -
                              (i * i) / 500 +
                              (17 * i) / 200 +
                              1
                      );
            }

            return 1;
        },

        _precision: function () {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(
                    precision,
                    this._precisionOf(this.options.min)
                );
            }
            return precision;
        },

        _precisionOf: function (num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _adjustValue: function (value) {
            var base,
                aboveMin,
                options = this.options;

            // Make sure we're at a valid step
            // - find out where we are relative to the base (min or 0)
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;

            // - round to the nearest step
            aboveMin = Math.round(aboveMin / options.step) * options.step;

            // - rounding is based on 0, so adjust back to our base
            value = base + aboveMin;

            // Fix precision from bad JS floating point math
            value = parseFloat(value.toFixed(this._precision()));

            // Clamp the value
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }

            return value;
        },

        _stop: function (event) {
            if (!this.spinning) {
                return;
            }

            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },

        _setOption: function (key, value) {
            var prevValue, first, last;

            if (key === "culture" || key === "numberFormat") {
                prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }

            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                first = this.buttons.first().find(".ui-icon");
                this._removeClass(first, null, this.options.icons.up);
                this._addClass(first, null, value.up);
                last = this.buttons.last().find(".ui-icon");
                this._removeClass(last, null, this.options.icons.down);
                this._addClass(last, null, value.down);
            }

            this._super(key, value);
        },

        _setOptionDisabled: function (value) {
            this._super(value);

            this._toggleClass(
                this.uiSpinner,
                null,
                "ui-state-disabled",
                !!value
            );
            this.element.prop("disabled", !!value);
            this.buttons.button(value ? "disable" : "enable");
        },

        _setOptions: spinnerModifier(function (options) {
            this._super(options);
        }),

        _parse: function (val) {
            if (typeof val === "string" && val !== "") {
                val =
                    window.Globalize && this.options.numberFormat
                        ? Globalize.parseFloat(val, 10, this.options.culture)
                        : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },

        _format: function (value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat
                ? Globalize.format(
                      value,
                      this.options.numberFormat,
                      this.options.culture
                  )
                : value;
        },

        _refresh: function () {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,

                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse(this.element.val()),
            });
        },

        isValid: function () {
            var value = this.value();

            // Null is invalid
            if (value === null) {
                return false;
            }

            // If value gets adjusted, it's invalid
            return value === this._adjustValue(value);
        },

        // Update the value without triggering change
        _value: function (value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },

        _destroy: function () {
            this.element
                .prop("disabled", false)
                .removeAttr(
                    "autocomplete role aria-valuemin aria-valuemax aria-valuenow"
                );

            this.uiSpinner.replaceWith(this.element);
        },

        stepUp: spinnerModifier(function (steps) {
            this._stepUp(steps);
        }),
        _stepUp: function (steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },

        stepDown: spinnerModifier(function (steps) {
            this._stepDown(steps);
        }),
        _stepDown: function (steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },

        pageUp: spinnerModifier(function (pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),

        pageDown: spinnerModifier(function (pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),

        value: function (newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            spinnerModifier(this._value).call(this, newVal);
        },

        widget: function () {
            return this.uiSpinner;
        },
    });

    // DEPRECATED
    // TODO: switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {
        // Backcompat for spinner html extension points
        $.widget("ui.spinner", $.ui.spinner, {
            _enhance: function () {
                this.uiSpinner = this.element
                    .attr("autocomplete", "off")
                    .wrap(this._uiSpinnerHtml())
                    .parent()

                    // Add buttons
                    .append(this._buttonHtml());
            },
            _uiSpinnerHtml: function () {
                return "<span>";
            },

            _buttonHtml: function () {
                return "<a></a><a></a>";
            },
        });
    }

    var widgetsSpinner = $.ui.spinner;

    /*!
     * jQuery UI Tabs 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Tabs
    //>>group: Widgets
    //>>description: Transforms a set of container elements into a tab structure.
    //>>docs: http://api.jqueryui.com/tabs/
    //>>demos: http://jqueryui.com/tabs/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/tabs.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.tabs", {
        version: "1.13.2",
        delay: 300,
        options: {
            active: null,
            classes: {
                "ui-tabs": "ui-corner-all",
                "ui-tabs-nav": "ui-corner-all",
                "ui-tabs-panel": "ui-corner-bottom",
                "ui-tabs-tab": "ui-corner-top",
            },
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,

            // Callbacks
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null,
        },

        _isLocal: (function () {
            var rhash = /#.*$/;

            return function (anchor) {
                var anchorUrl, locationUrl;

                anchorUrl = anchor.href.replace(rhash, "");
                locationUrl = location.href.replace(rhash, "");

                // Decoding may throw an error if the URL isn't UTF-8 (#9518)
                try {
                    anchorUrl = decodeURIComponent(anchorUrl);
                } catch (error) {}
                try {
                    locationUrl = decodeURIComponent(locationUrl);
                } catch (error) {}

                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        })(),

        _create: function () {
            var that = this,
                options = this.options;

            this.running = false;

            this._addClass("ui-tabs", "ui-widget ui-widget-content");
            this._toggleClass("ui-tabs-collapsible", null, options.collapsible);

            this._processTabs();
            options.active = this._initialActive();

            // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            if (Array.isArray(options.disabled)) {
                options.disabled = $.uniqueSort(
                    options.disabled.concat(
                        $.map(
                            this.tabs.filter(".ui-state-disabled"),
                            function (li) {
                                return that.tabs.index(li);
                            }
                        )
                    )
                ).sort();
            }

            // Check for length avoids error when initializing empty list
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }

            this._refresh();

            if (this.active.length) {
                this.load(options.active);
            }
        },

        _initialActive: function () {
            var active = this.options.active,
                collapsible = this.options.collapsible,
                locationHash = location.hash.substring(1);

            if (active === null) {
                // check the fragment identifier in the URL
                if (locationHash) {
                    this.tabs.each(function (i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }

                // Check for a tab marked active via a class
                if (active === null) {
                    active = this.tabs.index(
                        this.tabs.filter(".ui-tabs-active")
                    );
                }

                // No active tab, set to false
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }

            // Handle numbers: negative, out of range
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }

            // Don't allow collapsible: false and active: false
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }

            return active;
        },

        _getCreateEventData: function () {
            return {
                tab: this.active,
                panel: !this.active.length
                    ? $()
                    : this._getPanelForTab(this.active),
            };
        },

        _tabKeydown: function (event) {
            var focusedTab = $(
                    $.ui.safeActiveElement(this.document[0])
                ).closest("li"),
                selectedIndex = this.tabs.index(focusedTab),
                goingForward = true;

            if (this._handlePageNav(event)) {
                return;
            }

            switch (event.keyCode) {
                case $.ui.keyCode.RIGHT:
                case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;
                case $.ui.keyCode.UP:
                case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;
                case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;
                case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;
                case $.ui.keyCode.SPACE:
                    // Activate only, no collapsing
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;
                case $.ui.keyCode.ENTER:
                    // Toggle (cancel delayed activation, allow collapsing)
                    event.preventDefault();
                    clearTimeout(this.activating);

                    // Determine if we should collapse or activate
                    this._activate(
                        selectedIndex === this.options.active
                            ? false
                            : selectedIndex
                    );
                    return;
                default:
                    return;
            }

            // Focus the appropriate tab, based on which key was pressed
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);

            // Navigating with control/command key will prevent automatic activation
            if (!event.ctrlKey && !event.metaKey) {
                // Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");

                this.activating = this._delay(function () {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },

        _panelKeydown: function (event) {
            if (this._handlePageNav(event)) {
                return;
            }

            // Ctrl+up moves focus to the current tab
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.trigger("focus");
            }
        },

        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function (event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(
                    this._focusNextTab(this.options.active - 1, false)
                );
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(
                    this._focusNextTab(this.options.active + 1, true)
                );
                return true;
            }
        },

        _findNextTab: function (index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;

            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }

            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }

            return index;
        },

        _focusNextTab: function (index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).trigger("focus");
            return index;
        },

        _setOption: function (key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            this._super(key, value);

            if (key === "collapsible") {
                this._toggleClass("ui-tabs-collapsible", null, value);

                // Setting collapsible: false while collapsed; open first panel
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }

            if (key === "event") {
                this._setupEvents(value);
            }

            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },

        _sanitizeSelector: function (hash) {
            return hash
                ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&")
                : "";
        },

        refresh: function () {
            var options = this.options,
                lis = this.tablist.children(":has(a[href])");

            // Get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map(
                lis.filter(".ui-state-disabled"),
                function (tab) {
                    return lis.index(tab);
                }
            );

            this._processTabs();

            // Was collapsed or no tabs
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();

                // was active, but active tab is gone
            } else if (
                this.active.length &&
                !$.contains(this.tablist[0], this.active[0])
            ) {
                // all remaining tabs are disabled
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();

                    // activate previous tab
                } else {
                    this._activate(
                        this._findNextTab(
                            Math.max(0, options.active - 1),
                            false
                        )
                    );
                }

                // was active, active tab still exists
            } else {
                // make sure active index is correct
                options.active = this.tabs.index(this.active);
            }

            this._refresh();
        },

        _refresh: function () {
            this._setOptionDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);

            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1,
            });
            this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-hidden": "true",
            });

            // Make sure one tab is in the tab order
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0,
                });
                this._addClass(
                    this.active,
                    "ui-tabs-active",
                    "ui-state-active"
                );
                this._getPanelForTab(this.active).show().attr({
                    "aria-hidden": "false",
                });
            }
        },

        _processTabs: function () {
            var that = this,
                prevTabs = this.tabs,
                prevAnchors = this.anchors,
                prevPanels = this.panels;

            this.tablist = this._getList().attr("role", "tablist");
            this._addClass(
                this.tablist,
                "ui-tabs-nav",
                "ui-helper-reset ui-helper-clearfix ui-widget-header"
            );

            // Prevent users from focusing disabled tabs via click
            this.tablist
                .on(
                    "mousedown" + this.eventNamespace,
                    "> li",
                    function (event) {
                        if ($(this).is(".ui-state-disabled")) {
                            event.preventDefault();
                        }
                    }
                )

                // Support: IE <9
                // Preventing the default action in mousedown doesn't prevent IE
                // from focusing the element, so if the anchor gets focused, blur.
                // We don't have to worry about focusing the previously focused
                // element since clicking on a non-focusable element should focus
                // the body anyway.
                .on(
                    "focus" + this.eventNamespace,
                    ".ui-tabs-anchor",
                    function () {
                        if ($(this).closest("li").is(".ui-state-disabled")) {
                            this.blur();
                        }
                    }
                );

            this.tabs = this.tablist.find("> li:has(a[href])").attr({
                role: "tab",
                tabIndex: -1,
            });
            this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default");

            this.anchors = this.tabs
                .map(function () {
                    return $("a", this)[0];
                })
                .attr({
                    tabIndex: -1,
                });
            this._addClass(this.anchors, "ui-tabs-anchor");

            this.panels = $();

            this.anchors.each(function (i, anchor) {
                var selector,
                    panel,
                    panelId,
                    anchorId = $(anchor).uniqueId().attr("id"),
                    tab = $(anchor).closest("li"),
                    originalAriaControls = tab.attr("aria-controls");

                // Inline tab
                if (that._isLocal(anchor)) {
                    selector = anchor.hash;
                    panelId = selector.substring(1);
                    panel = that.element.find(that._sanitizeSelector(selector));

                    // remote tab
                } else {
                    // If the tab doesn't already have aria-controls,
                    // generate an id by using a throw-away element
                    panelId =
                        tab.attr("aria-controls") || $({}).uniqueId()[0].id;
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }

                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId,
                });
                panel.attr("aria-labelledby", anchorId);
            });

            this.panels.attr("role", "tabpanel");
            this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content");

            // Avoid memory leaks (#10056)
            if (prevTabs) {
                this._off(prevTabs.not(this.tabs));
                this._off(prevAnchors.not(this.anchors));
                this._off(prevPanels.not(this.panels));
            }
        },

        // Allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function () {
            return this.tablist || this.element.find("ol, ul").eq(0);
        },

        _createPanel: function (id) {
            return $("<div>").attr("id", id).data("ui-tabs-destroy", true);
        },

        _setOptionDisabled: function (disabled) {
            var currentItem, li, i;

            if (Array.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }

            // Disable tabs
            for (i = 0; (li = this.tabs[i]); i++) {
                currentItem = $(li);
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    currentItem.attr("aria-disabled", "true");
                    this._addClass(currentItem, null, "ui-state-disabled");
                } else {
                    currentItem.removeAttr("aria-disabled");
                    this._removeClass(currentItem, null, "ui-state-disabled");
                }
            }

            this.options.disabled = disabled;

            this._toggleClass(
                this.widget(),
                this.widgetFullName + "-disabled",
                null,
                disabled === true
            );
        },

        _setupEvents: function (event) {
            var events = {};
            if (event) {
                $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.anchors.add(this.tabs).add(this.panels));

            // Always prevent the default action, even when disabled
            this._on(true, this.anchors, {
                click: function (event) {
                    event.preventDefault();
                },
            });
            this._on(this.anchors, events);
            this._on(this.tabs, { keydown: "_tabKeydown" });
            this._on(this.panels, { keydown: "_panelKeydown" });

            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },

        _setupHeightStyle: function (heightStyle) {
            var maxHeight,
                parent = this.element.parent();

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();

                this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.element
                    .children()
                    .not(this.panels)
                    .each(function () {
                        maxHeight -= $(this).outerHeight(true);
                    });

                this.panels
                    .each(function () {
                        $(this).height(
                            Math.max(
                                0,
                                maxHeight -
                                    $(this).innerHeight() +
                                    $(this).height()
                            )
                        );
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels
                    .each(function () {
                        maxHeight = Math.max(
                            maxHeight,
                            $(this).height("").height()
                        );
                    })
                    .height(maxHeight);
            }
        },

        _eventHandler: function (event) {
            var options = this.options,
                active = this.active,
                anchor = $(event.currentTarget),
                tab = anchor.closest("li"),
                clickedIsActive = tab[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : this._getPanelForTab(tab),
                toHide = !active.length ? $() : this._getPanelForTab(active),
                eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow,
                };

            event.preventDefault();

            if (
                tab.hasClass("ui-state-disabled") ||
                // tab is already loading
                tab.hasClass("ui-tabs-loading") ||
                // can't switch durning an animation
                this.running ||
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                this._trigger("beforeActivate", event, eventData) === false
            ) {
                return;
            }

            options.active = collapsing ? false : this.tabs.index(tab);

            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }

            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }

            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },

        // Handles show/hide for selecting tabs
        _toggle: function (event, eventData) {
            var that = this,
                toShow = eventData.newPanel,
                toHide = eventData.oldPanel;

            this.running = true;

            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }

            function show() {
                that._addClass(
                    eventData.newTab.closest("li"),
                    "ui-tabs-active",
                    "ui-state-active"
                );

                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }

            // Start out by hiding, then showing, then completing
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function () {
                    that._removeClass(
                        eventData.oldTab.closest("li"),
                        "ui-tabs-active",
                        "ui-state-active"
                    );
                    show();
                });
            } else {
                this._removeClass(
                    eventData.oldTab.closest("li"),
                    "ui-tabs-active",
                    "ui-state-active"
                );
                toHide.hide();
                show();
            }

            toHide.attr("aria-hidden", "true");
            eventData.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false",
            });

            // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs
                    .filter(function () {
                        return $(this).attr("tabIndex") === 0;
                    })
                    .attr("tabIndex", -1);
            }

            toShow.attr("aria-hidden", "false");
            eventData.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0,
            });
        },

        _activate: function (index) {
            var anchor,
                active = this._findActive(index);

            // Trying to activate the already active panel
            if (active[0] === this.active[0]) {
                return;
            }

            // Trying to collapse, simulate a click on the current active header
            if (!active.length) {
                active = this.active;
            }

            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop,
            });
        },

        _findActive: function (index) {
            return index === false ? $() : this.tabs.eq(index);
        },

        _getIndex: function (index) {
            // meta-function to give users option to provide a href string instead of a numerical index.
            if (typeof index === "string") {
                index = this.anchors.index(
                    this.anchors.filter(
                        "[href$='" + $.escapeSelector(index) + "']"
                    )
                );
            }

            return index;
        },

        _destroy: function () {
            if (this.xhr) {
                this.xhr.abort();
            }

            this.tablist.removeAttr("role").off(this.eventNamespace);

            this.anchors.removeAttr("role tabIndex").removeUniqueId();

            this.tabs.add(this.panels).each(function () {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this).removeAttr(
                        "role tabIndex " +
                            "aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded"
                    );
                }
            });

            this.tabs.each(function () {
                var li = $(this),
                    prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li.attr("aria-controls", prev).removeData(
                        "ui-tabs-aria-controls"
                    );
                } else {
                    li.removeAttr("aria-controls");
                }
            });

            this.panels.show();

            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },

        enable: function (index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }

            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if (Array.isArray(disabled)) {
                    disabled = $.map(disabled, function (num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function (li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setOptionDisabled(disabled);
        },

        disable: function (index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }

            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if (Array.isArray(disabled)) {
                    disabled = $.merge([index], disabled).sort();
                } else {
                    disabled = [index];
                }
            }
            this._setOptionDisabled(disabled);
        },

        load: function (index, event) {
            index = this._getIndex(index);
            var that = this,
                tab = this.tabs.eq(index),
                anchor = tab.find(".ui-tabs-anchor"),
                panel = this._getPanelForTab(tab),
                eventData = {
                    tab: tab,
                    panel: panel,
                },
                complete = function (jqXHR, status) {
                    if (status === "abort") {
                        that.panels.stop(false, true);
                    }

                    that._removeClass(tab, "ui-tabs-loading");
                    panel.removeAttr("aria-busy");

                    if (jqXHR === that.xhr) {
                        delete that.xhr;
                    }
                };

            // Not remote
            if (this._isLocal(anchor[0])) {
                return;
            }

            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));

            // Support: jQuery <1.8
            // jQuery <1.8 returns false if the request is canceled in beforeSend,
            // but as of 1.8, $.ajax() always returns a jqXHR object.
            if (this.xhr && this.xhr.statusText !== "canceled") {
                this._addClass(tab, "ui-tabs-loading");
                panel.attr("aria-busy", "true");

                this.xhr
                    .done(function (response, status, jqXHR) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function () {
                            panel.html(response);
                            that._trigger("load", event, eventData);

                            complete(jqXHR, status);
                        }, 1);
                    })
                    .fail(function (jqXHR, status) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function () {
                            complete(jqXHR, status);
                        }, 1);
                    });
            }
        },

        _ajaxSettings: function (anchor, event, eventData) {
            var that = this;
            return {
                // Support: IE <11 only
                // Strip any hash that exists to prevent errors with the Ajax request
                url: anchor.attr("href").replace(/#.*$/, ""),
                beforeSend: function (jqXHR, settings) {
                    return that._trigger(
                        "beforeLoad",
                        event,
                        $.extend(
                            { jqXHR: jqXHR, ajaxSettings: settings },
                            eventData
                        )
                    );
                },
            };
        },

        _getPanelForTab: function (tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        },
    });

    // DEPRECATED
    // TODO: Switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {
        // Backcompat for ui-tab class (now ui-tabs-tab)
        $.widget("ui.tabs", $.ui.tabs, {
            _processTabs: function () {
                this._superApply(arguments);
                this._addClass(this.tabs, "ui-tab");
            },
        });
    }

    var widgetsTabs = $.ui.tabs;

    /*!
     * jQuery UI Tooltip 1.13.2
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     */

    //>>label: Tooltip
    //>>group: Widgets
    //>>description: Shows additional information for any element on hover or focus.
    //>>docs: http://api.jqueryui.com/tooltip/
    //>>demos: http://jqueryui.com/tooltip/
    //>>css.structure: ../../themes/base/core.css
    //>>css.structure: ../../themes/base/tooltip.css
    //>>css.theme: ../../themes/base/theme.css

    $.widget("ui.tooltip", {
        version: "1.13.2",
        options: {
            classes: {
                "ui-tooltip": "ui-corner-all ui-widget-shadow",
            },
            content: function () {
                var title = $(this).attr("title");

                // Escape title, since we're going from an attribute to raw HTML
                return $("<a>").text(title).html();
            },
            hide: true,

            // Disabled elements have inconsistent behavior across browsers (#8661)
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip",
            },
            show: true,
            track: false,

            // Callbacks
            close: null,
            open: null,
        },

        _addDescribedBy: function (elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(
                /\s+/
            );
            describedby.push(id);
            elem.data("ui-tooltip-id", id).attr(
                "aria-describedby",
                String.prototype.trim.call(describedby.join(" "))
            );
        },

        _removeDescribedBy: function (elem) {
            var id = elem.data("ui-tooltip-id"),
                describedby = (elem.attr("aria-describedby") || "").split(
                    /\s+/
                ),
                index = $.inArray(id, describedby);

            if (index !== -1) {
                describedby.splice(index, 1);
            }

            elem.removeData("ui-tooltip-id");
            describedby = String.prototype.trim.call(describedby.join(" "));
            if (describedby) {
                elem.attr("aria-describedby", describedby);
            } else {
                elem.removeAttr("aria-describedby");
            }
        },

        _create: function () {
            this._on({
                mouseover: "open",
                focusin: "open",
            });

            // IDs of generated tooltips, needed for destroy
            this.tooltips = {};

            // IDs of parent tooltips where we removed the title attribute
            this.parents = {};

            // Append the aria-live region so tooltips announce correctly
            this.liveRegion = $("<div>")
                .attr({
                    role: "log",
                    "aria-live": "assertive",
                    "aria-relevant": "additions",
                })
                .appendTo(this.document[0].body);
            this._addClass(
                this.liveRegion,
                null,
                "ui-helper-hidden-accessible"
            );

            this.disabledTitles = $([]);
        },

        _setOption: function (key, value) {
            var that = this;

            this._super(key, value);

            if (key === "content") {
                $.each(this.tooltips, function (id, tooltipData) {
                    that._updateContent(tooltipData.element);
                });
            }
        },

        _setOptionDisabled: function (value) {
            this[value ? "_disable" : "_enable"]();
        },

        _disable: function () {
            var that = this;

            // Close open tooltips
            $.each(this.tooltips, function (id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0];
                that.close(event, true);
            });

            // Remove title attributes to prevent native tooltips
            this.disabledTitles = this.disabledTitles.add(
                this.element
                    .find(this.options.items)
                    .addBack()
                    .filter(function () {
                        var element = $(this);
                        if (element.is("[title]")) {
                            return element
                                .data("ui-tooltip-title", element.attr("title"))
                                .removeAttr("title");
                        }
                    })
            );
        },

        _enable: function () {
            // restore title attributes
            this.disabledTitles.each(function () {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
            this.disabledTitles = $([]);
        },

        open: function (event) {
            var that = this,
                target = $(event ? event.target : this.element)
                    // we need closest here due to mouseover bubbling,
                    // but always pointing at the same event target
                    .closest(this.options.items);

            // No element to show a tooltip for or the tooltip is already open
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }

            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }

            target.data("ui-tooltip-open", true);

            // Kill parent tooltips, custom or native, for hover
            if (event && event.type === "mouseover") {
                target.parents().each(function () {
                    var parent = $(this),
                        blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title"),
                        };
                        parent.attr("title", "");
                    }
                });
            }

            this._registerCloseHandlers(event, target);
            this._updateContent(target, event);
        },

        _updateContent: function (target, event) {
            var content,
                contentOption = this.options.content,
                that = this,
                eventType = event ? event.type : null;

            if (
                typeof contentOption === "string" ||
                contentOption.nodeType ||
                contentOption.jquery
            ) {
                return this._open(event, target, contentOption);
            }

            content = contentOption.call(target[0], function (response) {
                // IE may instantly serve a cached response for ajax requests
                // delay this call to _open so the other call to _open runs first
                that._delay(function () {
                    // Ignore async response if tooltip was closed already
                    if (!target.data("ui-tooltip-open")) {
                        return;
                    }

                    // JQuery creates a special event for focusin when it doesn't
                    // exist natively. To improve performance, the native event
                    // object is reused and the type is changed. Therefore, we can't
                    // rely on the type being correct after the event finished
                    // bubbling, so we set it back to the previous value. (#8740)
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },

        _open: function (event, target, content) {
            var tooltipData,
                tooltip,
                delayedShow,
                a11yContent,
                positionOption = $.extend({}, this.options.position);

            if (!content) {
                return;
            }

            // Content can be updated multiple times. If the tooltip already
            // exists, then just update the content and bail.
            tooltipData = this._find(target);
            if (tooltipData) {
                tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                return;
            }

            // If we have a title, clear it to prevent the native tooltip
            // we have to check first to avoid defining a title if none exists
            // (we don't want to cause an element to start matching [title])
            //
            // We use removeAttr only for key events, to allow IE to export the correct
            // accessible attributes. For mouse events, set to empty string to avoid
            // native tooltip showing up (happens only when removing inside mouseover).
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }

            tooltipData = this._tooltip(target);
            tooltip = tooltipData.tooltip;
            this._addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);

            // Support: Voiceover on OS X, JAWS on IE <= 9
            // JAWS announces deletions even when aria-relevant="additions"
            // Voiceover will sometimes re-read the entire log region's contents from the beginning
            this.liveRegion.children().hide();
            a11yContent = $("<div>").html(
                tooltip.find(".ui-tooltip-content").html()
            );
            a11yContent.removeAttr("name").find("[name]").removeAttr("name");
            a11yContent.removeAttr("id").find("[id]").removeAttr("id");
            a11yContent.appendTo(this.liveRegion);

            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }

            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position,
                });

                // trigger once to override element-relative positioning
                position(event);
            } else {
                tooltip.position(
                    $.extend(
                        {
                            of: target,
                        },
                        this.options.position
                    )
                );
            }

            tooltip.hide();

            this._show(tooltip, this.options.show);

            // Handle tracking tooltips that are shown with a delay (#8644). As soon
            // as the tooltip is visible, position the tooltip using the most recent
            // event.
            // Adds the check to add the timers only when both delay and track options are set (#14682)
            if (
                this.options.track &&
                this.options.show &&
                this.options.show.delay
            ) {
                delayedShow = this.delayedShow = setInterval(function () {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, 13);
            }

            this._trigger("open", event, { tooltip: tooltip });
        },

        _registerCloseHandlers: function (event, target) {
            var events = {
                keyup: function (event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                },
            };

            // Only bind remove handler for delegated targets. Non-delegated
            // tooltips will handle this in destroy.
            if (target[0] !== this.element[0]) {
                events.remove = function () {
                    var targetElement = this._find(target);
                    if (targetElement) {
                        this._removeTooltip(targetElement.tooltip);
                    }
                };
            }

            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },

        close: function (event) {
            var tooltip,
                that = this,
                target = $(event ? event.currentTarget : this.element),
                tooltipData = this._find(target);

            // The tooltip may already be closed
            if (!tooltipData) {
                // We set ui-tooltip-open immediately upon open (in open()), but only set the
                // additional data once there's actually content to show (in _open()). So even if the
                // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
                // the period between open() and _open().
                target.removeData("ui-tooltip-open");
                return;
            }

            tooltip = tooltipData.tooltip;

            // Disabling closes the tooltip, so we need to track when we're closing
            // to avoid an infinite loop in case the tooltip becomes disabled on close
            if (tooltipData.closing) {
                return;
            }

            // Clear the interval for delayed tracking tooltips
            clearInterval(this.delayedShow);

            // Only set title if we had one before (see comment in _open())
            // If the title attribute has changed since open(), don't restore
            if (target.data("ui-tooltip-title") && !target.attr("title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }

            this._removeDescribedBy(target);

            tooltipData.hiding = true;
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function () {
                that._removeTooltip($(this));
            });

            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");

            // Remove 'remove' binding only on delegated targets
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");

            if (event && event.type === "mouseleave") {
                $.each(this.parents, function (id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }

            tooltipData.closing = true;
            this._trigger("close", event, { tooltip: tooltip });
            if (!tooltipData.hiding) {
                tooltipData.closing = false;
            }
        },

        _tooltip: function (element) {
            var tooltip = $("<div>").attr("role", "tooltip"),
                content = $("<div>").appendTo(tooltip),
                id = tooltip.uniqueId().attr("id");

            this._addClass(content, "ui-tooltip-content");
            this._addClass(
                tooltip,
                "ui-tooltip",
                "ui-widget ui-widget-content"
            );

            tooltip.appendTo(this._appendTo(element));

            return (this.tooltips[id] = {
                element: element,
                tooltip: tooltip,
            });
        },

        _find: function (target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null;
        },

        _removeTooltip: function (tooltip) {
            // Clear the interval for delayed tracking tooltips
            clearInterval(this.delayedShow);

            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },

        _appendTo: function (target) {
            var element = target.closest(".ui-front, dialog");

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _destroy: function () {
            var that = this;

            // Close open tooltips
            $.each(this.tooltips, function (id, tooltipData) {
                // Delegate to close method to handle common cleanup
                var event = $.Event("blur"),
                    element = tooltipData.element;
                event.target = event.currentTarget = element[0];
                that.close(event, true);

                // Remove immediately; destroying an open tooltip doesn't use the
                // hide animation
                $("#" + id).remove();

                // Restore the title
                if (element.data("ui-tooltip-title")) {
                    // If the title attribute has changed since open(), don't restore
                    if (!element.attr("title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                    element.removeData("ui-tooltip-title");
                }
            });
            this.liveRegion.remove();
        },
    });

    // DEPRECATED
    // TODO: Switch return back to widget declaration at top of file when this is removed
    if ($.uiBackCompat !== false) {
        // Backcompat for tooltipClass option
        $.widget("ui.tooltip", $.ui.tooltip, {
            options: {
                tooltipClass: null,
            },
            _tooltip: function () {
                var tooltipData = this._superApply(arguments);
                if (this.options.tooltipClass) {
                    tooltipData.tooltip.addClass(this.options.tooltipClass);
                }
                return tooltipData;
            },
        });
    }

    var widgetsTooltip = $.ui.tooltip;
});

// jquery.repeater version 1.2.2
// https://github.com/DubFriend/jquery.repeater
// (MIT) 15-04-2022
// Brian Detering <BDeterin@gmail.com> (http://www.briandetering.net/)

!(function (a) {
    "use strict";
    var b = function (a) {
            return a;
        },
        c = function (b) {
            return a.isArray(b);
        },
        d = function (a) {
            return !c(a) && a instanceof Object;
        },
        e = function (b, c) {
            return a.inArray(c, b);
        },
        f = function (a, b) {
            return -1 !== e(a, b);
        },
        g = function (a, b) {
            for (var c in a) a.hasOwnProperty(c) && b(a[c], c, a);
        },
        h = function (a) {
            return a[a.length - 1];
        },
        i = function (a) {
            return Array.prototype.slice.call(a);
        },
        j = function () {
            var a = {};
            return (
                g(i(arguments), function (b) {
                    g(b, function (b, c) {
                        a[c] = b;
                    });
                }),
                a
            );
        },
        k = function (a, b) {
            var c = [];
            return (
                g(a, function (a, d, e) {
                    c.push(b(a, d, e));
                }),
                c
            );
        },
        l = function (a, b, c) {
            var d = {};
            return (
                g(a, function (a, e, f) {
                    (e = c ? c(e, a) : e), (d[e] = b(a, e, f));
                }),
                d
            );
        },
        m = function (a, b, d) {
            return c(a) ? k(a, b) : l(a, b, d);
        },
        n = function (a, b) {
            return m(a, function (a) {
                return a[b];
            });
        },
        o = function (a, b) {
            var d;
            return (
                c(a)
                    ? ((d = []),
                      g(a, function (a, c, e) {
                          b(a, c, e) && d.push(a);
                      }))
                    : ((d = {}),
                      g(a, function (a, c, e) {
                          b(a, c, e) && (d[c] = a);
                      })),
                d
            );
        },
        p = function (a, b, c) {
            return m(a, function (a, d) {
                return a[b].apply(a, c || []);
            });
        },
        q = function (a) {
            a = a || {};
            var b = {};
            return (
                (a.publish = function (a, c) {
                    g(b[a], function (a) {
                        a(c);
                    });
                }),
                (a.subscribe = function (a, c) {
                    (b[a] = b[a] || []), b[a].push(c);
                }),
                (a.unsubscribe = function (a) {
                    g(b, function (b) {
                        var c = e(b, a);
                        -1 !== c && b.splice(c, 1);
                    });
                }),
                a
            );
        };
    !(function (a) {
        var b = function (a, b) {
                var c = q(),
                    d = a.$;
                return (
                    (c.getType = function () {
                        throw 'implement me (return type. "text", "radio", etc.)';
                    }),
                    (c.$ = function (a) {
                        return a ? d.find(a) : d;
                    }),
                    (c.disable = function () {
                        c.$().prop("disabled", !0), c.publish("isEnabled", !1);
                    }),
                    (c.enable = function () {
                        c.$().prop("disabled", !1), c.publish("isEnabled", !0);
                    }),
                    (b.equalTo = function (a, b) {
                        return a === b;
                    }),
                    (b.publishChange = (function () {
                        var a;
                        return function (d, e) {
                            var f = c.get();
                            b.equalTo(f, a) ||
                                c.publish("change", { e: d, domElement: e }),
                                (a = f);
                        };
                    })()),
                    c
                );
            },
            i = function (a, c) {
                var d = b(a, c);
                return (
                    (d.get = function () {
                        return d.$().val();
                    }),
                    (d.set = function (a) {
                        d.$().val(a);
                    }),
                    (d.clear = function () {
                        d.set("");
                    }),
                    (c.buildSetter = function (a) {
                        return function (b) {
                            a.call(d, b);
                        };
                    }),
                    d
                );
            },
            j = function (a) {
                var b = {},
                    c = i(a, b);
                return (
                    (c.getType = function () {
                        return "text";
                    }),
                    c.$().on("change keyup keydown", function (a) {
                        b.publishChange(a, this);
                    }),
                    c
                );
            },
            k = function (a, b) {
                (a = c(a) ? a : [a]), (b = c(b) ? b : [b]);
                var d = !0;
                return (
                    a.length !== b.length
                        ? (d = !1)
                        : g(a, function (a) {
                              f(b, a) || (d = !1);
                          }),
                    d
                );
            },
            l = function (a) {
                var b = {},
                    c = i(a, b);
                return (
                    (c.getType = function () {
                        return "button";
                    }),
                    c.$().on("change", function (a) {
                        b.publishChange(a, this);
                    }),
                    c
                );
            },
            m = function (b) {
                var d = {},
                    e = i(b, d);
                return (
                    (e.getType = function () {
                        return "checkbox";
                    }),
                    (e.get = function () {
                        var b = [];
                        return (
                            e
                                .$()
                                .filter(":checked")
                                .each(function () {
                                    b.push(a(this).val());
                                }),
                            b
                        );
                    }),
                    (e.set = function (b) {
                        (b = c(b) ? b : [b]),
                            e.$().each(function () {
                                a(this).prop("checked", !1);
                            }),
                            g(b, function (a) {
                                e.$()
                                    .filter('[value="' + a + '"]')
                                    .prop("checked", !0);
                            });
                    }),
                    (d.equalTo = k),
                    e.$().change(function (a) {
                        d.publishChange(a, this);
                    }),
                    e
                );
            },
            n = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "email";
                    }),
                    b
                );
            },
            o = function (c) {
                var d = {},
                    e = b(c, d);
                return (
                    (e.getType = function () {
                        return "file";
                    }),
                    (e.get = function () {
                        return h(e.$().val().split("\\"));
                    }),
                    (e.clear = function () {
                        this.$().each(function () {
                            a(this)
                                .wrap("<form>")
                                .closest("form")
                                .get(0)
                                .reset(),
                                a(this).unwrap();
                        });
                    }),
                    e.$().change(function (a) {
                        d.publishChange(a, this);
                    }),
                    e
                );
            },
            r = function (a) {
                var b = {},
                    c = i(a, b);
                return (
                    (c.getType = function () {
                        return "hidden";
                    }),
                    c.$().change(function (a) {
                        b.publishChange(a, this);
                    }),
                    c
                );
            },
            s = function (c) {
                var d = {},
                    e = b(c, d);
                return (
                    (e.getType = function () {
                        return "file[multiple]";
                    }),
                    (e.get = function () {
                        var a,
                            b = e.$().get(0).files || [],
                            c = [];
                        for (a = 0; a < (b.length || 0); a += 1)
                            c.push(b[a].name);
                        return c;
                    }),
                    (e.clear = function () {
                        this.$().each(function () {
                            a(this)
                                .wrap("<form>")
                                .closest("form")
                                .get(0)
                                .reset(),
                                a(this).unwrap();
                        });
                    }),
                    e.$().change(function (a) {
                        d.publishChange(a, this);
                    }),
                    e
                );
            },
            t = function (a) {
                var b = {},
                    d = i(a, b);
                return (
                    (d.getType = function () {
                        return "select[multiple]";
                    }),
                    (d.get = function () {
                        return d.$().val() || [];
                    }),
                    (d.set = function (a) {
                        d.$().val("" === a ? [] : c(a) ? a : [a]);
                    }),
                    (b.equalTo = k),
                    d.$().change(function (a) {
                        b.publishChange(a, this);
                    }),
                    d
                );
            },
            u = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "password";
                    }),
                    b
                );
            },
            v = function (b) {
                var c = {},
                    d = i(b, c);
                return (
                    (d.getType = function () {
                        return "radio";
                    }),
                    (d.get = function () {
                        return d.$().filter(":checked").val() || null;
                    }),
                    (d.set = function (b) {
                        b
                            ? d
                                  .$()
                                  .filter('[value="' + b + '"]')
                                  .prop("checked", !0)
                            : d.$().each(function () {
                                  a(this).prop("checked", !1);
                              });
                    }),
                    d.$().change(function (a) {
                        c.publishChange(a, this);
                    }),
                    d
                );
            },
            w = function (a) {
                var b = {},
                    c = i(a, b);
                return (
                    (c.getType = function () {
                        return "range";
                    }),
                    c.$().change(function (a) {
                        b.publishChange(a, this);
                    }),
                    c
                );
            },
            x = function (a) {
                var b = {},
                    c = i(a, b);
                return (
                    (c.getType = function () {
                        return "select";
                    }),
                    c.$().change(function (a) {
                        b.publishChange(a, this);
                    }),
                    c
                );
            },
            y = function (a) {
                var b = {},
                    c = i(a, b);
                return (
                    (c.getType = function () {
                        return "textarea";
                    }),
                    c.$().on("change keyup keydown", function (a) {
                        b.publishChange(a, this);
                    }),
                    c
                );
            },
            z = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "url";
                    }),
                    b
                );
            },
            A = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "color";
                    }),
                    b
                );
            },
            B = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "date";
                    }),
                    b
                );
            },
            C = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "datetime-local";
                    }),
                    b
                );
            },
            D = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "month";
                    }),
                    b
                );
            },
            E = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "number";
                    }),
                    b
                );
            },
            F = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "search";
                    }),
                    b
                );
            },
            G = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "tel";
                    }),
                    b
                );
            },
            H = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "time";
                    }),
                    b
                );
            },
            I = function (a) {
                var b = j(a);
                return (
                    (b.getType = function () {
                        return "week";
                    }),
                    b
                );
            },
            J = function (b) {
                var c = {},
                    f = b.$,
                    h = b.constructorOverride || {
                        color: A,
                        date: B,
                        datetimeLocal: C,
                        month: D,
                        number: E,
                        search: F,
                        tel: G,
                        time: H,
                        week: I,
                        button: l,
                        text: j,
                        url: z,
                        email: n,
                        password: u,
                        range: w,
                        textarea: y,
                        select: x,
                        "select[multiple]": t,
                        radio: v,
                        checkbox: m,
                        file: o,
                        "file[multiple]": s,
                        hidden: r,
                    },
                    i = function (b, e) {
                        (d(e) ? e : f.find(e)).each(function () {
                            var d = a(this).attr("name");
                            c[d] = h[b]({ $: a(this) });
                        });
                    },
                    k = function (b, i) {
                        var j = [],
                            k = d(i) ? i : f.find(i);
                        d(i)
                            ? (c[k.attr("name")] = h[b]({ $: k }))
                            : (k.each(function () {
                                  -1 === e(j, a(this).attr("name")) &&
                                      j.push(a(this).attr("name"));
                              }),
                              g(j, function (a) {
                                  c[a] = h[b]({
                                      $: f.find('input[name="' + a + '"]'),
                                  });
                              }));
                    };
                return (
                    f.is("input, select, textarea")
                        ? f.is(
                              'input[type="button"], button, input[type="submit"]'
                          )
                            ? i("button", f)
                            : f.is("textarea")
                            ? i("textarea", f)
                            : f.is('input[type="text"]') ||
                              (f.is("input") && !f.attr("type"))
                            ? i("text", f)
                            : f.is('input[type="password"]')
                            ? i("password", f)
                            : f.is('input[type="email"]')
                            ? i("email", f)
                            : f.is('input[type="url"]')
                            ? i("url", f)
                            : f.is('input[type="color"]')
                            ? i("color", f)
                            : f.is('input[type="date"]')
                            ? i("date", f)
                            : f.is('input[type="datetime-local"]')
                            ? i("datetimeLocal", f)
                            : f.is('input[type="month"]')
                            ? i("month", f)
                            : f.is('input[type="number"]')
                            ? i("number", f)
                            : f.is('input[type="search"]')
                            ? i("search", f)
                            : f.is('input[type="tel"]')
                            ? i("tel", f)
                            : f.is('input[type="time"]')
                            ? i("time", f)
                            : f.is('input[type="week"]')
                            ? i("week", f)
                            : f.is('input[type="range"]')
                            ? i("range", f)
                            : f.is("select")
                            ? f.is("[multiple]")
                                ? i("select[multiple]", f)
                                : i("select", f)
                            : f.is('input[type="file"]')
                            ? f.is("[multiple]")
                                ? i("file[multiple]", f)
                                : i("file", f)
                            : f.is('input[type="hidden"]')
                            ? i("hidden", f)
                            : f.is('input[type="radio"]')
                            ? k("radio", f)
                            : f.is('input[type="checkbox"]')
                            ? k("checkbox", f)
                            : i("text", f)
                        : (i(
                              "button",
                              'input[type="button"], button, input[type="submit"]'
                          ),
                          i("text", 'input[type="text"]'),
                          i("color", 'input[type="color"]'),
                          i("date", 'input[type="date"]'),
                          i("datetimeLocal", 'input[type="datetime-local"]'),
                          i("month", 'input[type="month"]'),
                          i("number", 'input[type="number"]'),
                          i("search", 'input[type="search"]'),
                          i("tel", 'input[type="tel"]'),
                          i("time", 'input[type="time"]'),
                          i("week", 'input[type="week"]'),
                          i("password", 'input[type="password"]'),
                          i("email", 'input[type="email"]'),
                          i("url", 'input[type="url"]'),
                          i("range", 'input[type="range"]'),
                          i("textarea", "textarea"),
                          i("select", "select:not([multiple])"),
                          i("select[multiple]", "select[multiple]"),
                          i("file", 'input[type="file"]:not([multiple])'),
                          i("file[multiple]", 'input[type="file"][multiple]'),
                          i("hidden", 'input[type="hidden"]'),
                          k("radio", 'input[type="radio"]'),
                          k("checkbox", 'input[type="checkbox"]')),
                    c
                );
            };
        (a.fn.inputVal = function (b) {
            var c = a(this),
                d = J({ $: c });
            return c.is("input, textarea, select")
                ? void 0 === b
                    ? d[c.attr("name")].get()
                    : (d[c.attr("name")].set(b), c)
                : void 0 === b
                ? p(d, "get")
                : (g(b, function (a, b) {
                      d[b].set(a);
                  }),
                  c);
        }),
            (a.fn.inputOnChange = function (b) {
                var c = a(this),
                    d = J({ $: c });
                return (
                    g(d, function (a) {
                        a.subscribe("change", function (a) {
                            b.call(a.domElement, a.e);
                        });
                    }),
                    c
                );
            }),
            (a.fn.inputDisable = function () {
                var b = a(this);
                return p(J({ $: b }), "disable"), b;
            }),
            (a.fn.inputEnable = function () {
                var b = a(this);
                return p(J({ $: b }), "enable"), b;
            }),
            (a.fn.inputClear = function () {
                var b = a(this);
                return p(J({ $: b }), "clear"), b;
            });
    })(jQuery),
        (a.fn.repeaterVal = function () {
            var b = function (a) {
                if (
                    1 === a.length &&
                    (0 === a[0].key.length ||
                        (1 === a[0].key.length && !a[0].key[0]))
                )
                    return a[0].val;
                g(a, function (a) {
                    a.head = a.key.shift();
                });
                var c,
                    d = (function () {
                        var b = {};
                        return (
                            g(a, function (a) {
                                b[a.head] || (b[a.head] = []),
                                    b[a.head].push(a);
                            }),
                            b
                        );
                    })();
                return (
                    /^[0-9]+$/.test(a[0].head)
                        ? ((c = []),
                          g(d, function (a) {
                              c.push(b(a));
                          }))
                        : ((c = {}),
                          g(d, function (a, d) {
                              c[d] = b(a);
                          })),
                    c
                );
            };
            return b(
                (function (a) {
                    var b = [];
                    return (
                        g(a, function (a, c) {
                            var d = [];
                            "undefined" !== c &&
                                (d.push(c.match(/^[^\[]*/)[0]),
                                (d = d.concat(
                                    m(c.match(/\[[^\]]*\]/g), function (a) {
                                        return a.replace(/[\[\]]/g, "");
                                    })
                                )),
                                b.push({ val: a, key: d }));
                        }),
                        b
                    );
                })(a(this).inputVal())
            );
        }),
        (a.fn.repeater = function (c) {
            c = c || {};
            var d;
            return (
                a(this).each(function () {
                    var e = a(this),
                        f =
                            c.show ||
                            function () {
                                a(this).show();
                            },
                        i =
                            c.hide ||
                            function (a) {
                                a();
                            },
                        k = e.find("[data-repeater-list]").first(),
                        l = function (b, c) {
                            return b.filter(function () {
                                return (
                                    !c ||
                                    0 ===
                                        a(this).closest(
                                            n(c, "selector").join(",")
                                        ).length
                                );
                            });
                        },
                        p = function () {
                            return l(
                                k.find("[data-repeater-item]"),
                                c.repeaters
                            );
                        },
                        q = k
                            .find("[data-repeater-item]")
                            .first()
                            .clone()
                            .hide(),
                        r = l(
                            l(a(this).find("[data-repeater-item]"), c.repeaters)
                                .first()
                                .find("[data-repeater-delete]"),
                            c.repeaters
                        );
                    c.isFirstItemUndeletable && r && r.remove();
                    var s = function () {
                            var a = k.data("repeater-list");
                            return c.$parent
                                ? c.$parent.data("item-name") + "[" + a + "]"
                                : a;
                        },
                        t = function (b) {
                            c.repeaters &&
                                b.each(function () {
                                    var b = a(this);
                                    g(c.repeaters, function (a) {
                                        b.find(a.selector).repeater(
                                            j(a, { $parent: b })
                                        );
                                    });
                                });
                        },
                        u = function (a, b, c) {
                            a &&
                                g(a, function (a) {
                                    c.call(b.find(a.selector)[0], a);
                                });
                        },
                        v = function (b, c, d) {
                            b.each(function (b) {
                                var e = a(this);
                                e.data("item-name", c + "[" + b + "]"),
                                    l(e.find("[name]"), d).each(function () {
                                        var f = a(this),
                                            g = f
                                                .attr("name")
                                                .match(/\[[^\]]+\]/g),
                                            i = g
                                                ? h(g).replace(/\[|\]/g, "")
                                                : f.attr("name"),
                                            j =
                                                c +
                                                "[" +
                                                b +
                                                "][" +
                                                i +
                                                "]" +
                                                (f.is(":checkbox") ||
                                                f.attr("multiple")
                                                    ? "[]"
                                                    : "");
                                        f.attr("name", j),
                                            u(d, e, function (d) {
                                                var e = a(this);
                                                v(
                                                    l(
                                                        e.find(
                                                            "[data-repeater-item]"
                                                        ),
                                                        d.repeaters || []
                                                    ),
                                                    c +
                                                        "[" +
                                                        b +
                                                        "][" +
                                                        e
                                                            .find(
                                                                "[data-repeater-list]"
                                                            )
                                                            .first()
                                                            .data(
                                                                "repeater-list"
                                                            ) +
                                                        "]",
                                                    d.repeaters
                                                );
                                            });
                                    });
                            }),
                                k
                                    .find("input[name][checked]")
                                    .removeAttr("checked")
                                    .prop("checked", !0);
                        };
                    v(p(), s(), c.repeaters),
                        t(p()),
                        c.initEmpty && p().remove(),
                        c.ready &&
                            c.ready(function () {
                                v(p(), s(), c.repeaters);
                            });
                    var w = (function () {
                            var d = function (e, f, h) {
                                if (f || c.defaultValues) {
                                    var i = {};
                                    l(e.find("[name]"), h).each(function () {
                                        var b = a(this)
                                            .attr("name")
                                            .match(/\[([^\]]*)(\]|\]\[\])$/)[1];
                                        i[b] = a(this).attr("name");
                                    }),
                                        e.inputVal(
                                            m(
                                                o(
                                                    f || c.defaultValues,
                                                    function (a, b) {
                                                        return i[b];
                                                    }
                                                ),
                                                b,
                                                function (a) {
                                                    return i[a];
                                                }
                                            )
                                        );
                                }
                                u(h, e, function (b) {
                                    var c = a(this);
                                    l(
                                        c.find("[data-repeater-item]"),
                                        b.repeaters
                                    ).each(function () {
                                        var e = c
                                            .find("[data-repeater-list]")
                                            .data("repeater-list");
                                        if (f && f[e]) {
                                            var h = a(this).clone();
                                            c
                                                .find("[data-repeater-item]")
                                                .remove(),
                                                g(f[e], function (a) {
                                                    var e = h.clone();
                                                    d(e, a, b.repeaters || []),
                                                        c
                                                            .find(
                                                                "[data-repeater-list]"
                                                            )
                                                            .append(e);
                                                });
                                        } else
                                            d(
                                                a(this),
                                                b.defaultValues,
                                                b.repeaters || []
                                            );
                                    });
                                });
                            };
                            return function (b, e) {
                                k.append(b),
                                    v(p(), s(), c.repeaters),
                                    b.find("[name]").each(function () {
                                        a(this).inputClear();
                                    }),
                                    d(b, e || c.defaultValues, c.repeaters);
                            };
                        })(),
                        x = function (a) {
                            var b = q.clone();
                            w(b, a), c.repeaters && t(b), f.call(b.get(0));
                        };
                    (d = function (a) {
                        p().remove(), g(a, x);
                    }),
                        l(e.find("[data-repeater-create]"), c.repeaters).click(
                            function () {
                                x();
                            }
                        ),
                        k.on("click", "[data-repeater-delete]", function () {
                            var b = a(this)
                                .closest("[data-repeater-item]")
                                .get(0);
                            i.call(b, function () {
                                a(b).remove(), v(p(), s(), c.repeaters);
                            });
                        });
                }),
                (this.setList = d),
                this
            );
        });
})(jQuery);

/*! For license information please see summernote-bs4.min.js.LICENSE.txt */
!(function (t, e) {
    if ("object" == typeof exports && "object" == typeof module)
        module.exports = e(require("jquery"));
    else if ("function" == typeof define && define.amd) define(["jquery"], e);
    else {
        var n = "object" == typeof exports ? e(require("jquery")) : e(t.jQuery);
        for (var o in n) ("object" == typeof exports ? exports : t)[o] = n[o];
    }
})(window, function (t) {
    return (function (t) {
        var e = {};

        function n(o) {
            if (e[o]) return e[o].exports;
            var i = (e[o] = { i: o, l: !1, exports: {} });
            return t[o].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
        }

        return (
            (n.m = t),
            (n.c = e),
            (n.d = function (t, e, o) {
                n.o(t, e) ||
                    Object.defineProperty(t, e, { enumerable: !0, get: o });
            }),
            (n.r = function (t) {
                "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module",
                    }),
                    Object.defineProperty(t, "__esModule", { value: !0 });
            }),
            (n.t = function (t, e) {
                if ((1 & e && (t = n(t)), 8 & e)) return t;
                if (4 & e && "object" == typeof t && t && t.__esModule)
                    return t;
                var o = Object.create(null);
                if (
                    (n.r(o),
                    Object.defineProperty(o, "default", {
                        enumerable: !0,
                        value: t,
                    }),
                    2 & e && "string" != typeof t)
                )
                    for (var i in t)
                        n.d(
                            o,
                            i,
                            function (e) {
                                return t[e];
                            }.bind(null, i)
                        );
                return o;
            }),
            (n.n = function (t) {
                var e =
                    t && t.__esModule
                        ? function () {
                              return t.default;
                          }
                        : function () {
                              return t;
                          };
                return n.d(e, "a", e), e;
            }),
            (n.o = function (t, e) {
                return Object.prototype.hasOwnProperty.call(t, e);
            }),
            (n.p = ""),
            n((n.s = 53))
        );
    })({
        0: function (e, n) {
            e.exports = t;
        },
        1: function (t, e, n) {
            "use strict";
            var o = n(0),
                i = n.n(o);

            function r(t) {
                return (r =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                        ? function (t) {
                              return typeof t;
                          }
                        : function (t) {
                              return t &&
                                  "function" == typeof Symbol &&
                                  t.constructor === Symbol &&
                                  t !== Symbol.prototype
                                  ? "symbol"
                                  : typeof t;
                          })(t);
            }

            function a(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var s = (function () {
                function t(e, n, o, i) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.markup = e),
                        (this.children = n),
                        (this.options = o),
                        (this.callback = i);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "render",
                            value: function (t) {
                                var e = i()(this.markup);
                                if (
                                    (this.options &&
                                        this.options.contents &&
                                        e.html(this.options.contents),
                                    this.options &&
                                        this.options.className &&
                                        e.addClass(this.options.className),
                                    this.options &&
                                        this.options.data &&
                                        i.a.each(
                                            this.options.data,
                                            function (t, n) {
                                                e.attr("data-" + t, n);
                                            }
                                        ),
                                    this.options &&
                                        this.options.click &&
                                        e.on("click", this.options.click),
                                    this.children)
                                ) {
                                    var n = e.find(".note-children-container");
                                    this.children.forEach(function (t) {
                                        t.render(n.length ? n : e);
                                    });
                                }
                                return (
                                    this.callback &&
                                        this.callback(e, this.options),
                                    this.options &&
                                        this.options.callback &&
                                        this.options.callback(e),
                                    t && t.append(e),
                                    e
                                );
                            },
                        },
                    ]) && a(e.prototype, n),
                    o && a(e, o),
                    t
                );
            })();
            e.a = {
                create: function (t, e) {
                    return function () {
                        var n =
                                "object" === r(arguments[1])
                                    ? arguments[1]
                                    : arguments[0],
                            o = Array.isArray(arguments[0]) ? arguments[0] : [];
                        return (
                            n && n.children && (o = n.children),
                            new s(t, o, n, e)
                        );
                    };
                },
            };
        },
        2: function (t, e) {
            (function (e) {
                t.exports = e;
            }).call(this, {});
        },
        3: function (t, e, n) {
            "use strict";
            var o = n(0),
                i = n.n(o);
            (i.a.summernote = i.a.summernote || { lang: {} }),
                i.a.extend(i.a.summernote.lang, {
                    "en-US": {
                        font: {
                            bold: "Bold",
                            italic: "Italic",
                            underline: "Underline",
                            clear: "Remove Font Style",
                            height: "Line Height",
                            name: "Font Family",
                            strikethrough: "Strikethrough",
                            subscript: "Subscript",
                            superscript: "Superscript",
                            size: "Font Size",
                            sizeunit: "Font Size Unit",
                        },
                        image: {
                            image: "Picture",
                            insert: "Insert Image",
                            resizeFull: "Resize full",
                            resizeHalf: "Resize half",
                            resizeQuarter: "Resize quarter",
                            resizeNone: "Original size",
                            floatLeft: "Float Left",
                            floatRight: "Float Right",
                            floatNone: "Remove float",
                            shapeRounded: "Shape: Rounded",
                            shapeCircle: "Shape: Circle",
                            shapeThumbnail: "Shape: Thumbnail",
                            shapeNone: "Shape: None",
                            dragImageHere: "Drag image or text here",
                            dropImage: "Drop image or Text",
                            selectFromFiles: "Select from files",
                            maximumFileSize: "Maximum file size",
                            maximumFileSizeError: "Maximum file size exceeded.",
                            url: "Image URL",
                            remove: "Remove Image",
                            original: "Original",
                        },
                        video: {
                            video: "Video",
                            videoLink: "Video Link",
                            insert: "Insert Video",
                            url: "Video URL",
                            providers:
                                "(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)",
                        },
                        link: {
                            link: "Link",
                            insert: "Insert Link",
                            unlink: "Unlink",
                            edit: "Edit",
                            textToDisplay: "Text to display",
                            url: "To what URL should this link go?",
                            openInNewWindow: "Open in new window",
                            useProtocol: "Use default protocol",
                        },
                        table: {
                            table: "Table",
                            addRowAbove: "Add row above",
                            addRowBelow: "Add row below",
                            addColLeft: "Add column left",
                            addColRight: "Add column right",
                            delRow: "Delete row",
                            delCol: "Delete column",
                            delTable: "Delete table",
                        },
                        hr: { insert: "Insert Horizontal Rule" },
                        style: {
                            style: "Style",
                            p: "Normal",
                            blockquote: "Quote",
                            pre: "Code",
                            h1: "Header 1",
                            h2: "Header 2",
                            h3: "Header 3",
                            h4: "Header 4",
                            h5: "Header 5",
                            h6: "Header 6",
                        },
                        lists: {
                            unordered: "Unordered list",
                            ordered: "Ordered list",
                        },
                        options: {
                            help: "Help",
                            fullscreen: "Full Screen",
                            codeview: "Code View",
                        },
                        paragraph: {
                            paragraph: "Paragraph",
                            outdent: "Outdent",
                            indent: "Indent",
                            left: "Align left",
                            center: "Align center",
                            right: "Align right",
                            justify: "Justify full",
                        },
                        color: {
                            recent: "Recent Color",
                            more: "More Color",
                            background: "Background Color",
                            foreground: "Text Color",
                            transparent: "Transparent",
                            setTransparent: "Set transparent",
                            reset: "Reset",
                            resetToDefault: "Reset to default",
                            cpSelect: "Select",
                        },
                        shortcut: {
                            shortcuts: "Keyboard shortcuts",
                            close: "Close",
                            textFormatting: "Text formatting",
                            action: "Action",
                            paragraphFormatting: "Paragraph formatting",
                            documentStyle: "Document Style",
                            extraKeys: "Extra keys",
                        },
                        help: {
                            escape: "Escape",
                            insertParagraph: "Insert Paragraph",
                            undo: "Undo the last command",
                            redo: "Redo the last command",
                            tab: "Tab",
                            untab: "Untab",
                            bold: "Set a bold style",
                            italic: "Set a italic style",
                            underline: "Set a underline style",
                            strikethrough: "Set a strikethrough style",
                            removeFormat: "Clean a style",
                            justifyLeft: "Set left align",
                            justifyCenter: "Set center align",
                            justifyRight: "Set right align",
                            justifyFull: "Set full align",
                            insertUnorderedList: "Toggle unordered list",
                            insertOrderedList: "Toggle ordered list",
                            outdent: "Outdent on current paragraph",
                            indent: "Indent on current paragraph",
                            formatPara:
                                "Change current block's format as a paragraph(P tag)",
                            formatH1: "Change current block's format as H1",
                            formatH2: "Change current block's format as H2",
                            formatH3: "Change current block's format as H3",
                            formatH4: "Change current block's format as H4",
                            formatH5: "Change current block's format as H5",
                            formatH6: "Change current block's format as H6",
                            insertHorizontalRule: "Insert horizontal rule",
                            "linkDialog.show": "Show Link Dialog",
                        },
                        history: { undo: "Undo", redo: "Redo" },
                        specialChar: {
                            specialChar: "SPECIAL CHARACTERS",
                            select: "Select Special characters",
                        },
                        output: { noSelection: "No Selection Made!" },
                    },
                });
            var r = "function" == typeof define && n(2),
                a = ["sans-serif", "serif", "monospace", "cursive", "fantasy"];

            function s(t) {
                return -1 === i.a.inArray(t.toLowerCase(), a)
                    ? "'".concat(t, "'")
                    : t;
            }

            var l,
                c = navigator.userAgent,
                u = /MSIE|Trident/i.test(c);
            if (u) {
                var d = /MSIE (\d+[.]\d+)/.exec(c);
                d && (l = parseFloat(d[1])),
                    (d = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(c)) &&
                        (l = parseFloat(d[1]));
            }
            var h = /Edge\/\d+/.test(c),
                f =
                    "ontouchstart" in window ||
                    navigator.MaxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0,
                p = u
                    ? "DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted"
                    : "input",
                m = {
                    isMac: navigator.appVersion.indexOf("Mac") > -1,
                    isMSIE: u,
                    isEdge: h,
                    isFF: !h && /firefox/i.test(c),
                    isPhantom: /PhantomJS/i.test(c),
                    isWebkit: !h && /webkit/i.test(c),
                    isChrome: !h && /chrome/i.test(c),
                    isSafari: !h && /safari/i.test(c) && !/chrome/i.test(c),
                    browserVersion: l,
                    jqueryVersion: parseFloat(i.a.fn.jquery),
                    isSupportAmd: r,
                    isSupportTouch: f,
                    isFontInstalled: function (t) {
                        var e =
                                "Comic Sans MS" === t
                                    ? "Courier New"
                                    : "Comic Sans MS",
                            n = document
                                .createElement("canvas")
                                .getContext("2d");
                        n.font = "200px '" + e + "'";
                        var o = n.measureText("mmmmmmmmmmwwwww").width;
                        return (
                            (n.font = "200px " + s(t) + ', "' + e + '"'),
                            o !== n.measureText("mmmmmmmmmmwwwww").width
                        );
                    },
                    isW3CRangeSupport: !!document.createRange,
                    inputEventName: p,
                    genericFontFamilies: a,
                    validFontName: s,
                };
            var v = 0;
            var g = {
                eq: function (t) {
                    return function (e) {
                        return t === e;
                    };
                },
                eq2: function (t, e) {
                    return t === e;
                },
                peq2: function (t) {
                    return function (e, n) {
                        return e[t] === n[t];
                    };
                },
                ok: function () {
                    return !0;
                },
                fail: function () {
                    return !1;
                },
                self: function (t) {
                    return t;
                },
                not: function (t) {
                    return function () {
                        return !t.apply(t, arguments);
                    };
                },
                and: function (t, e) {
                    return function (n) {
                        return t(n) && e(n);
                    };
                },
                invoke: function (t, e) {
                    return function () {
                        return t[e].apply(t, arguments);
                    };
                },
                resetUniqueId: function () {
                    v = 0;
                },
                uniqueId: function (t) {
                    var e = ++v + "";
                    return t ? t + e : e;
                },
                rect2bnd: function (t) {
                    var e = i()(document);
                    return {
                        top: t.top + e.scrollTop(),
                        left: t.left + e.scrollLeft(),
                        width: t.right - t.left,
                        height: t.bottom - t.top,
                    };
                },
                invertObject: function (t) {
                    var e = {};
                    for (var n in t)
                        Object.prototype.hasOwnProperty.call(t, n) &&
                            (e[t[n]] = n);
                    return e;
                },
                namespaceToCamel: function (t, e) {
                    return (
                        (e = e || "") +
                        t
                            .split(".")
                            .map(function (t) {
                                return (
                                    t.substring(0, 1).toUpperCase() +
                                    t.substring(1)
                                );
                            })
                            .join("")
                    );
                },
                debounce: function (t, e, n) {
                    var o;
                    return function () {
                        var i = this,
                            r = arguments,
                            a = function () {
                                (o = null), n || t.apply(i, r);
                            },
                            s = n && !o;
                        clearTimeout(o),
                            (o = setTimeout(a, e)),
                            s && t.apply(i, r);
                    };
                },
                isValidUrl: function (t) {
                    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi.test(
                        t
                    );
                },
            };

            function b(t) {
                return t[0];
            }

            function y(t) {
                return t[t.length - 1];
            }

            function k(t) {
                return t.slice(1);
            }

            function w(t, e) {
                if (t && t.length && e) {
                    if (t.indexOf) return -1 !== t.indexOf(e);
                    if (t.contains) return t.contains(e);
                }
                return !1;
            }

            var C = {
                    head: b,
                    last: y,
                    initial: function (t) {
                        return t.slice(0, t.length - 1);
                    },
                    tail: k,
                    prev: function (t, e) {
                        if (t && t.length && e) {
                            var n = t.indexOf(e);
                            return -1 === n ? null : t[n - 1];
                        }
                        return null;
                    },
                    next: function (t, e) {
                        if (t && t.length && e) {
                            var n = t.indexOf(e);
                            return -1 === n ? null : t[n + 1];
                        }
                        return null;
                    },
                    find: function (t, e) {
                        for (var n = 0, o = t.length; n < o; n++) {
                            var i = t[n];
                            if (e(i)) return i;
                        }
                    },
                    contains: w,
                    all: function (t, e) {
                        for (var n = 0, o = t.length; n < o; n++)
                            if (!e(t[n])) return !1;
                        return !0;
                    },
                    sum: function (t, e) {
                        return (
                            (e = e || g.self),
                            t.reduce(function (t, n) {
                                return t + e(n);
                            }, 0)
                        );
                    },
                    from: function (t) {
                        for (var e = [], n = t.length, o = -1; ++o < n; )
                            e[o] = t[o];
                        return e;
                    },
                    isEmpty: function (t) {
                        return !t || !t.length;
                    },
                    clusterBy: function (t, e) {
                        return t.length
                            ? k(t).reduce(
                                  function (t, n) {
                                      var o = y(t);
                                      return (
                                          e(y(o), n)
                                              ? (o[o.length] = n)
                                              : (t[t.length] = [n]),
                                          t
                                      );
                                  },
                                  [[b(t)]]
                              )
                            : [];
                    },
                    compact: function (t) {
                        for (var e = [], n = 0, o = t.length; n < o; n++)
                            t[n] && e.push(t[n]);
                        return e;
                    },
                    unique: function (t) {
                        for (var e = [], n = 0, o = t.length; n < o; n++)
                            w(e, t[n]) || e.push(t[n]);
                        return e;
                    },
                },
                x = String.fromCharCode(160);

            function S(t) {
                return t && i()(t).hasClass("note-editable");
            }

            function T(t) {
                return (
                    (t = t.toUpperCase()),
                    function (e) {
                        return e && e.nodeName.toUpperCase() === t;
                    }
                );
            }

            function E(t) {
                return t && 3 === t.nodeType;
            }

            function I(t) {
                return (
                    t &&
                    /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT|^AUDIO|^VIDEO|^EMBED/.test(
                        t.nodeName.toUpperCase()
                    )
                );
            }

            function $(t) {
                return (
                    !S(t) &&
                    t &&
                    /^DIV|^P|^LI|^H[1-7]/.test(t.nodeName.toUpperCase())
                );
            }

            var N = T("PRE"),
                P = T("LI");
            var R = T("TABLE"),
                L = T("DATA");

            function A(t) {
                return !(B(t) || F(t) || D(t) || $(t) || R(t) || z(t) || L(t));
            }

            function F(t) {
                return t && /^UL|^OL/.test(t.nodeName.toUpperCase());
            }

            var D = T("HR");

            function H(t) {
                return t && /^TD|^TH/.test(t.nodeName.toUpperCase());
            }

            var z = T("BLOCKQUOTE");

            function B(t) {
                return H(t) || z(t) || S(t);
            }

            var M = T("A");
            var O = T("BODY");
            var j = m.isMSIE && m.browserVersion < 11 ? "&nbsp;" : "<br>";

            function U(t) {
                return E(t) ? t.nodeValue.length : t ? t.childNodes.length : 0;
            }

            function W(t) {
                var e = U(t);
                return (
                    0 === e ||
                    (!E(t) && 1 === e && t.innerHTML === j) ||
                    !(!C.all(t.childNodes, E) || "" !== t.innerHTML)
                );
            }

            function K(t) {
                I(t) || U(t) || (t.innerHTML = j);
            }

            function q(t, e) {
                for (; t; ) {
                    if (e(t)) return t;
                    if (S(t)) break;
                    t = t.parentNode;
                }
                return null;
            }

            function V(t, e) {
                e = e || g.fail;
                var n = [];
                return (
                    q(t, function (t) {
                        return S(t) || n.push(t), e(t);
                    }),
                    n
                );
            }

            function _(t, e) {
                e = e || g.fail;
                for (var n = []; t && !e(t); ) n.push(t), (t = t.nextSibling);
                return n;
            }

            function G(t, e) {
                var n = e.nextSibling,
                    o = e.parentNode;
                return n ? o.insertBefore(t, n) : o.appendChild(t), t;
            }

            function Y(t, e) {
                return (
                    i.a.each(e, function (e, n) {
                        t.appendChild(n);
                    }),
                    t
                );
            }

            function Z(t) {
                return 0 === t.offset;
            }

            function X(t) {
                return t.offset === U(t.node);
            }

            function Q(t) {
                return Z(t) || X(t);
            }

            function J(t, e) {
                for (; t && t !== e; ) {
                    if (0 !== et(t)) return !1;
                    t = t.parentNode;
                }
                return !0;
            }

            function tt(t, e) {
                if (!e) return !1;
                for (; t && t !== e; ) {
                    if (et(t) !== U(t.parentNode) - 1) return !1;
                    t = t.parentNode;
                }
                return !0;
            }

            function et(t) {
                for (var e = 0; (t = t.previousSibling); ) e += 1;
                return e;
            }

            function nt(t) {
                return !!(t && t.childNodes && t.childNodes.length);
            }

            function ot(t, e) {
                var n, o;
                if (0 === t.offset) {
                    if (S(t.node)) return null;
                    (n = t.node.parentNode), (o = et(t.node));
                } else
                    nt(t.node)
                        ? (o = U((n = t.node.childNodes[t.offset - 1])))
                        : ((n = t.node), (o = e ? 0 : t.offset - 1));
                return { node: n, offset: o };
            }

            function it(t, e) {
                var n, o;
                if (U(t.node) === t.offset) {
                    if (S(t.node)) return null;
                    var i = at(t.node);
                    i
                        ? ((n = i), (o = 0))
                        : ((n = t.node.parentNode), (o = et(t.node) + 1));
                } else
                    nt(t.node)
                        ? ((n = t.node.childNodes[t.offset]), (o = 0))
                        : ((n = t.node), (o = e ? U(t.node) : t.offset + 1));
                return { node: n, offset: o };
            }

            function rt(t, e) {
                var n, o;
                if (W(t.node))
                    return { node: (n = t.node.nextSibling), offset: (o = 0) };
                if (U(t.node) === t.offset) {
                    if (S(t.node)) return null;
                    var i = at(t.node);
                    i
                        ? ((n = i), (o = 0))
                        : ((n = t.node.parentNode), (o = et(t.node) + 1)),
                        S(n) && ((n = t.node.nextSibling), (o = 0));
                } else if (nt(t.node)) {
                    if (((o = 0), W((n = t.node.childNodes[t.offset]))))
                        return null;
                } else if (
                    ((n = t.node), (o = e ? U(t.node) : t.offset + 1), W(n))
                )
                    return null;
                return { node: n, offset: o };
            }

            function at(t) {
                if (t.nextSibling && t.parent === t.nextSibling.parent)
                    return E(t.nextSibling) ? t.nextSibling : at(t.nextSibling);
            }

            function st(t, e) {
                return t.node === e.node && t.offset === e.offset;
            }

            function lt(t, e) {
                var n = e && e.isSkipPaddingBlankHTML,
                    o = e && e.isNotSplitEdgePoint,
                    i = e && e.isDiscardEmptySplits;
                if ((i && (n = !0), Q(t) && (E(t.node) || o))) {
                    if (Z(t)) return t.node;
                    if (X(t)) return t.node.nextSibling;
                }
                if (E(t.node)) return t.node.splitText(t.offset);
                var r = t.node.childNodes[t.offset],
                    a = G(t.node.cloneNode(!1), t.node);
                return (
                    Y(a, _(r)),
                    n || (K(t.node), K(a)),
                    i && (W(t.node) && dt(t.node), W(a))
                        ? (dt(a), t.node.nextSibling)
                        : a
                );
            }

            function ct(t, e, n) {
                var o = V(e.node, g.eq(t));
                return o.length
                    ? 1 === o.length
                        ? lt(e, n)
                        : o.reduce(function (t, o) {
                              return (
                                  t === e.node && (t = lt(e, n)),
                                  lt({ node: o, offset: t ? et(t) : U(o) }, n)
                              );
                          })
                    : null;
            }

            function ut(t) {
                return document.createElement(t);
            }

            function dt(t, e) {
                if (t && t.parentNode) {
                    if (t.removeNode) return t.removeNode(e);
                    var n = t.parentNode;
                    if (!e) {
                        for (
                            var o = [], i = 0, r = t.childNodes.length;
                            i < r;
                            i++
                        )
                            o.push(t.childNodes[i]);
                        for (var a = 0, s = o.length; a < s; a++)
                            n.insertBefore(o[a], t);
                    }
                    n.removeChild(t);
                }
            }

            var ht = T("TEXTAREA");

            function ft(t, e) {
                var n = ht(t[0]) ? t.val() : t.html();
                return e ? n.replace(/[\n\r]/g, "") : n;
            }

            var pt = {
                NBSP_CHAR: x,
                ZERO_WIDTH_NBSP_CHAR: "\ufeff",
                blank: j,
                emptyPara: "<p>".concat(j, "</p>"),
                makePredByNodeName: T,
                isEditable: S,
                isControlSizing: function (t) {
                    return t && i()(t).hasClass("note-control-sizing");
                },
                isText: E,
                isElement: function (t) {
                    return t && 1 === t.nodeType;
                },
                isVoid: I,
                isPara: $,
                isPurePara: function (t) {
                    return $(t) && !P(t);
                },
                isHeading: function (t) {
                    return t && /^H[1-7]/.test(t.nodeName.toUpperCase());
                },
                isInline: A,
                isBlock: g.not(A),
                isBodyInline: function (t) {
                    return A(t) && !q(t, $);
                },
                isBody: O,
                isParaInline: function (t) {
                    return A(t) && !!q(t, $);
                },
                isPre: N,
                isList: F,
                isTable: R,
                isData: L,
                isCell: H,
                isBlockquote: z,
                isBodyContainer: B,
                isAnchor: M,
                isDiv: T("DIV"),
                isLi: P,
                isBR: T("BR"),
                isSpan: T("SPAN"),
                isB: T("B"),
                isU: T("U"),
                isS: T("S"),
                isI: T("I"),
                isImg: T("IMG"),
                isTextarea: ht,
                deepestChildIsEmpty: function (t) {
                    do {
                        if (
                            null === t.firstElementChild ||
                            "" === t.firstElementChild.innerHTML
                        )
                            break;
                    } while ((t = t.firstElementChild));
                    return W(t);
                },
                isEmpty: W,
                isEmptyAnchor: g.and(M, W),
                isClosestSibling: function (t, e) {
                    return t.nextSibling === e || t.previousSibling === e;
                },
                withClosestSiblings: function (t, e) {
                    e = e || g.ok;
                    var n = [];
                    return (
                        t.previousSibling &&
                            e(t.previousSibling) &&
                            n.push(t.previousSibling),
                        n.push(t),
                        t.nextSibling &&
                            e(t.nextSibling) &&
                            n.push(t.nextSibling),
                        n
                    );
                },
                nodeLength: U,
                isLeftEdgePoint: Z,
                isRightEdgePoint: X,
                isEdgePoint: Q,
                isLeftEdgeOf: J,
                isRightEdgeOf: tt,
                isLeftEdgePointOf: function (t, e) {
                    return Z(t) && J(t.node, e);
                },
                isRightEdgePointOf: function (t, e) {
                    return X(t) && tt(t.node, e);
                },
                prevPoint: ot,
                nextPoint: it,
                nextPointWithEmptyNode: rt,
                isSamePoint: st,
                isVisiblePoint: function (t) {
                    if (E(t.node) || !nt(t.node) || W(t.node)) return !0;
                    var e = t.node.childNodes[t.offset - 1],
                        n = t.node.childNodes[t.offset];
                    return !((e && !I(e)) || (n && !I(n)));
                },
                prevPointUntil: function (t, e) {
                    for (; t; ) {
                        if (e(t)) return t;
                        t = ot(t);
                    }
                    return null;
                },
                nextPointUntil: function (t, e) {
                    for (; t; ) {
                        if (e(t)) return t;
                        t = it(t);
                    }
                    return null;
                },
                isCharPoint: function (t) {
                    if (!E(t.node)) return !1;
                    var e = t.node.nodeValue.charAt(t.offset - 1);
                    return e && " " !== e && e !== x;
                },
                isSpacePoint: function (t) {
                    if (!E(t.node)) return !1;
                    var e = t.node.nodeValue.charAt(t.offset - 1);
                    return " " === e || e === x;
                },
                walkPoint: function (t, e, n, o) {
                    for (var i = t; i && (n(i), !st(i, e)); ) {
                        i = rt(i, o && t.node !== i.node && e.node !== i.node);
                    }
                },
                ancestor: q,
                singleChildAncestor: function (t, e) {
                    for (t = t.parentNode; t && 1 === U(t); ) {
                        if (e(t)) return t;
                        if (S(t)) break;
                        t = t.parentNode;
                    }
                    return null;
                },
                listAncestor: V,
                lastAncestor: function (t, e) {
                    var n = V(t);
                    return C.last(n.filter(e));
                },
                listNext: _,
                listPrev: function (t, e) {
                    e = e || g.fail;
                    for (var n = []; t && !e(t); )
                        n.push(t), (t = t.previousSibling);
                    return n;
                },
                listDescendant: function (t, e) {
                    var n = [];
                    return (
                        (e = e || g.ok),
                        (function o(i) {
                            t !== i && e(i) && n.push(i);
                            for (var r = 0, a = i.childNodes.length; r < a; r++)
                                o(i.childNodes[r]);
                        })(t),
                        n
                    );
                },
                commonAncestor: function (t, e) {
                    for (var n = V(t), o = e; o; o = o.parentNode)
                        if (n.indexOf(o) > -1) return o;
                    return null;
                },
                wrap: function (t, e) {
                    var n = t.parentNode,
                        o = i()("<" + e + ">")[0];
                    return n.insertBefore(o, t), o.appendChild(t), o;
                },
                insertAfter: G,
                appendChildNodes: Y,
                position: et,
                hasChildren: nt,
                makeOffsetPath: function (t, e) {
                    return V(e, g.eq(t)).map(et).reverse();
                },
                fromOffsetPath: function (t, e) {
                    for (var n = t, o = 0, i = e.length; o < i; o++)
                        n =
                            n.childNodes.length <= e[o]
                                ? n.childNodes[n.childNodes.length - 1]
                                : n.childNodes[e[o]];
                    return n;
                },
                splitTree: ct,
                splitPoint: function (t, e) {
                    var n,
                        o,
                        i = e ? $ : B,
                        r = V(t.node, i),
                        a = C.last(r) || t.node;
                    i(a)
                        ? ((n = r[r.length - 2]), (o = a))
                        : (o = (n = a).parentNode);
                    var s =
                        n &&
                        ct(n, t, {
                            isSkipPaddingBlankHTML: e,
                            isNotSplitEdgePoint: e,
                        });
                    return (
                        s || o !== t.node || (s = t.node.childNodes[t.offset]),
                        { rightNode: s, container: o }
                    );
                },
                create: ut,
                createText: function (t) {
                    return document.createTextNode(t);
                },
                remove: dt,
                removeWhile: function (t, e) {
                    for (; t && !S(t) && e(t); ) {
                        var n = t.parentNode;
                        dt(t), (t = n);
                    }
                },
                replace: function (t, e) {
                    if (t.nodeName.toUpperCase() === e.toUpperCase()) return t;
                    var n = ut(e);
                    return (
                        t.style.cssText && (n.style.cssText = t.style.cssText),
                        Y(n, C.from(t.childNodes)),
                        G(n, t),
                        dt(t),
                        n
                    );
                },
                html: function (t, e) {
                    var n = ft(t);
                    if (e) {
                        n = (n = n.replace(
                            /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g,
                            function (t, e, n) {
                                n = n.toUpperCase();
                                var o =
                                        /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(n) &&
                                        !!e,
                                    i =
                                        /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(
                                            n
                                        );
                                return t + (o || i ? "\n" : "");
                            }
                        )).trim();
                    }
                    return n;
                },
                value: ft,
                posFromPlaceholder: function (t) {
                    var e = i()(t),
                        n = e.offset(),
                        o = e.outerHeight(!0);
                    return { left: n.left, top: n.top + o };
                },
                attachEvents: function (t, e) {
                    Object.keys(e).forEach(function (n) {
                        t.on(n, e[n]);
                    });
                },
                detachEvents: function (t, e) {
                    Object.keys(e).forEach(function (n) {
                        t.off(n, e[n]);
                    });
                },
                isCustomStyleTag: function (t) {
                    return (
                        t && !E(t) && C.contains(t.classList, "note-styletag")
                    );
                },
            };

            function mt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var vt = (function () {
                function t(e, n) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.$note = e),
                        (this.memos = {}),
                        (this.modules = {}),
                        (this.layoutInfo = {}),
                        (this.options = i.a.extend(!0, {}, n)),
                        (i.a.summernote.ui = i.a.summernote.ui_template(
                            this.options
                        )),
                        (this.ui = i.a.summernote.ui),
                        this.initialize();
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                return (
                                    (this.layoutInfo = this.ui.createLayout(
                                        this.$note
                                    )),
                                    this._initialize(),
                                    this.$note.hide(),
                                    this
                                );
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this._destroy(),
                                    this.$note.removeData("summernote"),
                                    this.ui.removeLayout(
                                        this.$note,
                                        this.layoutInfo
                                    );
                            },
                        },
                        {
                            key: "reset",
                            value: function () {
                                var t = this.isDisabled();
                                this.code(pt.emptyPara),
                                    this._destroy(),
                                    this._initialize(),
                                    t && this.disable();
                            },
                        },
                        {
                            key: "_initialize",
                            value: function () {
                                var t = this;
                                (this.options.id = g.uniqueId(i.a.now())),
                                    (this.options.container =
                                        this.options.container ||
                                        this.layoutInfo.editor);
                                var e = i.a.extend({}, this.options.buttons);
                                Object.keys(e).forEach(function (n) {
                                    t.memo("button." + n, e[n]);
                                });
                                var n = i.a.extend(
                                    {},
                                    this.options.modules,
                                    i.a.summernote.plugins || {}
                                );
                                Object.keys(n).forEach(function (e) {
                                    t.module(e, n[e], !0);
                                }),
                                    Object.keys(this.modules).forEach(function (
                                        e
                                    ) {
                                        t.initializeModule(e);
                                    });
                            },
                        },
                        {
                            key: "_destroy",
                            value: function () {
                                var t = this;
                                Object.keys(this.modules)
                                    .reverse()
                                    .forEach(function (e) {
                                        t.removeModule(e);
                                    }),
                                    Object.keys(this.memos).forEach(function (
                                        e
                                    ) {
                                        t.removeMemo(e);
                                    }),
                                    this.triggerEvent("destroy", this);
                            },
                        },
                        {
                            key: "code",
                            value: function (t) {
                                var e = this.invoke("codeview.isActivated");
                                if (void 0 === t)
                                    return (
                                        this.invoke("codeview.sync"),
                                        e
                                            ? this.layoutInfo.codable.val()
                                            : this.layoutInfo.editable.html()
                                    );
                                e
                                    ? this.invoke("codeview.sync", t)
                                    : this.layoutInfo.editable.html(t),
                                    this.$note.val(t),
                                    this.triggerEvent(
                                        "change",
                                        t,
                                        this.layoutInfo.editable
                                    );
                            },
                        },
                        {
                            key: "isDisabled",
                            value: function () {
                                return (
                                    "false" ===
                                    this.layoutInfo.editable.attr(
                                        "contenteditable"
                                    )
                                );
                            },
                        },
                        {
                            key: "enable",
                            value: function () {
                                this.layoutInfo.editable.attr(
                                    "contenteditable",
                                    !0
                                ),
                                    this.invoke("toolbar.activate", !0),
                                    this.triggerEvent("disable", !1),
                                    (this.options.editing = !0);
                            },
                        },
                        {
                            key: "disable",
                            value: function () {
                                this.invoke("codeview.isActivated") &&
                                    this.invoke("codeview.deactivate"),
                                    this.layoutInfo.editable.attr(
                                        "contenteditable",
                                        !1
                                    ),
                                    (this.options.editing = !1),
                                    this.invoke("toolbar.deactivate", !0),
                                    this.triggerEvent("disable", !0);
                            },
                        },
                        {
                            key: "triggerEvent",
                            value: function () {
                                var t = C.head(arguments),
                                    e = C.tail(C.from(arguments)),
                                    n =
                                        this.options.callbacks[
                                            g.namespaceToCamel(t, "on")
                                        ];
                                n && n.apply(this.$note[0], e),
                                    this.$note.trigger("summernote." + t, e);
                            },
                        },
                        {
                            key: "initializeModule",
                            value: function (t) {
                                var e = this.modules[t];
                                (e.shouldInitialize =
                                    e.shouldInitialize || g.ok),
                                    e.shouldInitialize() &&
                                        (e.initialize && e.initialize(),
                                        e.events &&
                                            pt.attachEvents(
                                                this.$note,
                                                e.events
                                            ));
                            },
                        },
                        {
                            key: "module",
                            value: function (t, e, n) {
                                if (1 === arguments.length)
                                    return this.modules[t];
                                (this.modules[t] = new e(this)),
                                    n || this.initializeModule(t);
                            },
                        },
                        {
                            key: "removeModule",
                            value: function (t) {
                                var e = this.modules[t];
                                e.shouldInitialize() &&
                                    (e.events &&
                                        pt.detachEvents(this.$note, e.events),
                                    e.destroy && e.destroy()),
                                    delete this.modules[t];
                            },
                        },
                        {
                            key: "memo",
                            value: function (t, e) {
                                if (1 === arguments.length)
                                    return this.memos[t];
                                this.memos[t] = e;
                            },
                        },
                        {
                            key: "removeMemo",
                            value: function (t) {
                                this.memos[t] &&
                                    this.memos[t].destroy &&
                                    this.memos[t].destroy(),
                                    delete this.memos[t];
                            },
                        },
                        {
                            key: "createInvokeHandlerAndUpdateState",
                            value: function (t, e) {
                                var n = this;
                                return function (o) {
                                    n.createInvokeHandler(t, e)(o),
                                        n.invoke("buttons.updateCurrentStyle");
                                };
                            },
                        },
                        {
                            key: "createInvokeHandler",
                            value: function (t, e) {
                                var n = this;
                                return function (o) {
                                    o.preventDefault();
                                    var r = i()(o.target);
                                    n.invoke(
                                        t,
                                        e ||
                                            r
                                                .closest("[data-value]")
                                                .data("value"),
                                        r
                                    );
                                };
                            },
                        },
                        {
                            key: "invoke",
                            value: function () {
                                var t = C.head(arguments),
                                    e = C.tail(C.from(arguments)),
                                    n = t.split("."),
                                    o = n.length > 1,
                                    i = o && C.head(n),
                                    r = o ? C.last(n) : C.head(n),
                                    a = this.modules[i || "editor"];
                                return !i && this[r]
                                    ? this[r].apply(this, e)
                                    : a && a[r] && a.shouldInitialize()
                                    ? a[r].apply(a, e)
                                    : void 0;
                            },
                        },
                    ]) && mt(e.prototype, n),
                    o && mt(e, o),
                    t
                );
            })();

            function gt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            function bt(t, e) {
                var n,
                    o,
                    i = t.parentElement(),
                    r = document.body.createTextRange(),
                    a = C.from(i.childNodes);
                for (n = 0; n < a.length; n++)
                    if (!pt.isText(a[n])) {
                        if (
                            (r.moveToElementText(a[n]),
                            r.compareEndPoints("StartToStart", t) >= 0)
                        )
                            break;
                        o = a[n];
                    }
                if (0 !== n && pt.isText(a[n - 1])) {
                    var s = document.body.createTextRange(),
                        l = null;
                    s.moveToElementText(o || i),
                        s.collapse(!o),
                        (l = o ? o.nextSibling : i.firstChild);
                    var c = t.duplicate();
                    c.setEndPoint("StartToStart", s);
                    for (
                        var u = c.text.replace(/[\r\n]/g, "").length;
                        u > l.nodeValue.length && l.nextSibling;

                    )
                        (u -= l.nodeValue.length), (l = l.nextSibling);
                    l.nodeValue;
                    e &&
                        l.nextSibling &&
                        pt.isText(l.nextSibling) &&
                        u === l.nodeValue.length &&
                        ((u -= l.nodeValue.length), (l = l.nextSibling)),
                        (i = l),
                        (n = u);
                }
                return { cont: i, offset: n };
            }

            function yt(t) {
                var e = document.body.createTextRange(),
                    n = (function t(e, n) {
                        var o, i;
                        if (pt.isText(e)) {
                            var r = pt.listPrev(e, g.not(pt.isText)),
                                a = C.last(r).previousSibling;
                            (o = a || e.parentNode),
                                (n += C.sum(C.tail(r), pt.nodeLength)),
                                (i = !a);
                        } else {
                            if (((o = e.childNodes[n] || e), pt.isText(o)))
                                return t(o, 0);
                            (n = 0), (i = !1);
                        }
                        return { node: o, collapseToStart: i, offset: n };
                    })(t.node, t.offset);
                return (
                    e.moveToElementText(n.node),
                    e.collapse(n.collapseToStart),
                    e.moveStart("character", n.offset),
                    e
                );
            }

            i.a.fn.extend({
                summernote: function () {
                    var t = i.a.type(C.head(arguments)),
                        e = "string" === t,
                        n = "object" === t,
                        o = i.a.extend(
                            {},
                            i.a.summernote.options,
                            n ? C.head(arguments) : {}
                        );
                    (o.langInfo = i.a.extend(
                        !0,
                        {},
                        i.a.summernote.lang["en-US"],
                        i.a.summernote.lang[o.lang]
                    )),
                        (o.icons = i.a.extend(
                            !0,
                            {},
                            i.a.summernote.options.icons,
                            o.icons
                        )),
                        (o.tooltip =
                            "auto" === o.tooltip
                                ? !m.isSupportTouch
                                : o.tooltip),
                        this.each(function (t, e) {
                            var n = i()(e);
                            if (!n.data("summernote")) {
                                var r = new vt(n, o);
                                n.data("summernote", r),
                                    n
                                        .data("summernote")
                                        .triggerEvent("init", r.layoutInfo);
                            }
                        });
                    var r = this.first();
                    if (r.length) {
                        var a = r.data("summernote");
                        if (e) return a.invoke.apply(a, C.from(arguments));
                        o.focus && a.invoke("editor.focus");
                    }
                    return this;
                },
            });
            var kt = (function () {
                    function t(e, n, o, i) {
                        !(function (t, e) {
                            if (!(t instanceof e))
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                        })(this, t),
                            (this.sc = e),
                            (this.so = n),
                            (this.ec = o),
                            (this.eo = i),
                            (this.isOnEditable = this.makeIsOn(pt.isEditable)),
                            (this.isOnList = this.makeIsOn(pt.isList)),
                            (this.isOnAnchor = this.makeIsOn(pt.isAnchor)),
                            (this.isOnCell = this.makeIsOn(pt.isCell)),
                            (this.isOnData = this.makeIsOn(pt.isData));
                    }

                    var e, n, o;
                    return (
                        (e = t),
                        (n = [
                            {
                                key: "nativeRange",
                                value: function () {
                                    if (m.isW3CRangeSupport) {
                                        var t = document.createRange();
                                        return (
                                            t.setStart(this.sc, this.so),
                                            t.setEnd(this.ec, this.eo),
                                            t
                                        );
                                    }
                                    var e = yt({
                                        node: this.sc,
                                        offset: this.so,
                                    });
                                    return (
                                        e.setEndPoint(
                                            "EndToEnd",
                                            yt({
                                                node: this.ec,
                                                offset: this.eo,
                                            })
                                        ),
                                        e
                                    );
                                },
                            },
                            {
                                key: "getPoints",
                                value: function () {
                                    return {
                                        sc: this.sc,
                                        so: this.so,
                                        ec: this.ec,
                                        eo: this.eo,
                                    };
                                },
                            },
                            {
                                key: "getStartPoint",
                                value: function () {
                                    return { node: this.sc, offset: this.so };
                                },
                            },
                            {
                                key: "getEndPoint",
                                value: function () {
                                    return { node: this.ec, offset: this.eo };
                                },
                            },
                            {
                                key: "select",
                                value: function () {
                                    var t = this.nativeRange();
                                    if (m.isW3CRangeSupport) {
                                        var e = document.getSelection();
                                        e.rangeCount > 0 && e.removeAllRanges(),
                                            e.addRange(t);
                                    } else t.select();
                                    return this;
                                },
                            },
                            {
                                key: "scrollIntoView",
                                value: function (t) {
                                    var e = i()(t).height();
                                    return (
                                        t.scrollTop + e < this.sc.offsetTop &&
                                            (t.scrollTop += Math.abs(
                                                t.scrollTop +
                                                    e -
                                                    this.sc.offsetTop
                                            )),
                                        this
                                    );
                                },
                            },
                            {
                                key: "normalize",
                                value: function () {
                                    var e = function (t, e) {
                                            if (!t) return t;
                                            if (
                                                pt.isVisiblePoint(t) &&
                                                (!pt.isEdgePoint(t) ||
                                                    (pt.isRightEdgePoint(t) &&
                                                        !e) ||
                                                    (pt.isLeftEdgePoint(t) &&
                                                        e) ||
                                                    (pt.isRightEdgePoint(t) &&
                                                        e &&
                                                        pt.isVoid(
                                                            t.node.nextSibling
                                                        )) ||
                                                    (pt.isLeftEdgePoint(t) &&
                                                        !e &&
                                                        pt.isVoid(
                                                            t.node
                                                                .previousSibling
                                                        )) ||
                                                    (pt.isBlock(t.node) &&
                                                        pt.isEmpty(t.node)))
                                            )
                                                return t;
                                            var n = pt.ancestor(
                                                    t.node,
                                                    pt.isBlock
                                                ),
                                                o = !1;
                                            if (!o) {
                                                var i = pt.prevPoint(t) || {
                                                    node: null,
                                                };
                                                o =
                                                    (pt.isLeftEdgePointOf(
                                                        t,
                                                        n
                                                    ) ||
                                                        pt.isVoid(i.node)) &&
                                                    !e;
                                            }
                                            var r = !1;
                                            if (!r) {
                                                var a = pt.nextPoint(t) || {
                                                    node: null,
                                                };
                                                r =
                                                    (pt.isRightEdgePointOf(
                                                        t,
                                                        n
                                                    ) ||
                                                        pt.isVoid(a.node)) &&
                                                    e;
                                            }
                                            if (o || r) {
                                                if (pt.isVisiblePoint(t))
                                                    return t;
                                                e = !e;
                                            }
                                            return (
                                                (e
                                                    ? pt.nextPointUntil(
                                                          pt.nextPoint(t),
                                                          pt.isVisiblePoint
                                                      )
                                                    : pt.prevPointUntil(
                                                          pt.prevPoint(t),
                                                          pt.isVisiblePoint
                                                      )) || t
                                            );
                                        },
                                        n = e(this.getEndPoint(), !1),
                                        o = this.isCollapsed()
                                            ? n
                                            : e(this.getStartPoint(), !0);
                                    return new t(
                                        o.node,
                                        o.offset,
                                        n.node,
                                        n.offset
                                    );
                                },
                            },
                            {
                                key: "nodes",
                                value: function (t, e) {
                                    t = t || g.ok;
                                    var n = e && e.includeAncestor,
                                        o = e && e.fullyContains,
                                        i = this.getStartPoint(),
                                        r = this.getEndPoint(),
                                        a = [],
                                        s = [];
                                    return (
                                        pt.walkPoint(
                                            i,
                                            r,
                                            function (e) {
                                                var i;
                                                pt.isEditable(e.node) ||
                                                    (o
                                                        ? (pt.isLeftEdgePoint(
                                                              e
                                                          ) && s.push(e.node),
                                                          pt.isRightEdgePoint(
                                                              e
                                                          ) &&
                                                              C.contains(
                                                                  s,
                                                                  e.node
                                                              ) &&
                                                              (i = e.node))
                                                        : (i = n
                                                              ? pt.ancestor(
                                                                    e.node,
                                                                    t
                                                                )
                                                              : e.node),
                                                    i && t(i) && a.push(i));
                                            },
                                            !0
                                        ),
                                        C.unique(a)
                                    );
                                },
                            },
                            {
                                key: "commonAncestor",
                                value: function () {
                                    return pt.commonAncestor(this.sc, this.ec);
                                },
                            },
                            {
                                key: "expand",
                                value: function (e) {
                                    var n = pt.ancestor(this.sc, e),
                                        o = pt.ancestor(this.ec, e);
                                    if (!n && !o)
                                        return new t(
                                            this.sc,
                                            this.so,
                                            this.ec,
                                            this.eo
                                        );
                                    var i = this.getPoints();
                                    return (
                                        n && ((i.sc = n), (i.so = 0)),
                                        o &&
                                            ((i.ec = o),
                                            (i.eo = pt.nodeLength(o))),
                                        new t(i.sc, i.so, i.ec, i.eo)
                                    );
                                },
                            },
                            {
                                key: "collapse",
                                value: function (e) {
                                    return e
                                        ? new t(
                                              this.sc,
                                              this.so,
                                              this.sc,
                                              this.so
                                          )
                                        : new t(
                                              this.ec,
                                              this.eo,
                                              this.ec,
                                              this.eo
                                          );
                                },
                            },
                            {
                                key: "splitText",
                                value: function () {
                                    var e = this.sc === this.ec,
                                        n = this.getPoints();
                                    return (
                                        pt.isText(this.ec) &&
                                            !pt.isEdgePoint(
                                                this.getEndPoint()
                                            ) &&
                                            this.ec.splitText(this.eo),
                                        pt.isText(this.sc) &&
                                            !pt.isEdgePoint(
                                                this.getStartPoint()
                                            ) &&
                                            ((n.sc = this.sc.splitText(
                                                this.so
                                            )),
                                            (n.so = 0),
                                            e &&
                                                ((n.ec = n.sc),
                                                (n.eo = this.eo - this.so))),
                                        new t(n.sc, n.so, n.ec, n.eo)
                                    );
                                },
                            },
                            {
                                key: "deleteContents",
                                value: function () {
                                    if (this.isCollapsed()) return this;
                                    var e = this.splitText(),
                                        n = e.nodes(null, {
                                            fullyContains: !0,
                                        }),
                                        o = pt.prevPointUntil(
                                            e.getStartPoint(),
                                            function (t) {
                                                return !C.contains(n, t.node);
                                            }
                                        ),
                                        r = [];
                                    return (
                                        i.a.each(n, function (t, e) {
                                            var n = e.parentNode;
                                            o.node !== n &&
                                                1 === pt.nodeLength(n) &&
                                                r.push(n),
                                                pt.remove(e, !1);
                                        }),
                                        i.a.each(r, function (t, e) {
                                            pt.remove(e, !1);
                                        }),
                                        new t(
                                            o.node,
                                            o.offset,
                                            o.node,
                                            o.offset
                                        ).normalize()
                                    );
                                },
                            },
                            {
                                key: "makeIsOn",
                                value: function (t) {
                                    return function () {
                                        var e = pt.ancestor(this.sc, t);
                                        return (
                                            !!e && e === pt.ancestor(this.ec, t)
                                        );
                                    };
                                },
                            },
                            {
                                key: "isLeftEdgeOf",
                                value: function (t) {
                                    if (
                                        !pt.isLeftEdgePoint(
                                            this.getStartPoint()
                                        )
                                    )
                                        return !1;
                                    var e = pt.ancestor(this.sc, t);
                                    return e && pt.isLeftEdgeOf(this.sc, e);
                                },
                            },
                            {
                                key: "isCollapsed",
                                value: function () {
                                    return (
                                        this.sc === this.ec &&
                                        this.so === this.eo
                                    );
                                },
                            },
                            {
                                key: "wrapBodyInlineWithPara",
                                value: function () {
                                    if (
                                        pt.isBodyContainer(this.sc) &&
                                        pt.isEmpty(this.sc)
                                    )
                                        return (
                                            (this.sc.innerHTML = pt.emptyPara),
                                            new t(
                                                this.sc.firstChild,
                                                0,
                                                this.sc.firstChild,
                                                0
                                            )
                                        );
                                    var e,
                                        n = this.normalize();
                                    if (
                                        pt.isParaInline(this.sc) ||
                                        pt.isPara(this.sc)
                                    )
                                        return n;
                                    if (pt.isInline(n.sc)) {
                                        var o = pt.listAncestor(
                                            n.sc,
                                            g.not(pt.isInline)
                                        );
                                        (e = C.last(o)),
                                            pt.isInline(e) ||
                                                (e =
                                                    o[o.length - 2] ||
                                                    n.sc.childNodes[n.so]);
                                    } else
                                        e =
                                            n.sc.childNodes[
                                                n.so > 0 ? n.so - 1 : 0
                                            ];
                                    if (e) {
                                        var i = pt
                                            .listPrev(e, pt.isParaInline)
                                            .reverse();
                                        if (
                                            (i = i.concat(
                                                pt.listNext(
                                                    e.nextSibling,
                                                    pt.isParaInline
                                                )
                                            )).length
                                        ) {
                                            var r = pt.wrap(C.head(i), "p");
                                            pt.appendChildNodes(r, C.tail(i));
                                        }
                                    }
                                    return this.normalize();
                                },
                            },
                            {
                                key: "insertNode",
                                value: function (t) {
                                    var e = this;
                                    (pt.isText(t) || pt.isInline(t)) &&
                                        (e =
                                            this.wrapBodyInlineWithPara().deleteContents());
                                    var n = pt.splitPoint(
                                        e.getStartPoint(),
                                        pt.isInline(t)
                                    );
                                    return (
                                        n.rightNode
                                            ? (n.rightNode.parentNode.insertBefore(
                                                  t,
                                                  n.rightNode
                                              ),
                                              pt.isEmpty(n.rightNode) &&
                                                  pt.isPara(t) &&
                                                  n.rightNode.parentNode.removeChild(
                                                      n.rightNode
                                                  ))
                                            : n.container.appendChild(t),
                                        t
                                    );
                                },
                            },
                            {
                                key: "pasteHTML",
                                value: function (t) {
                                    t = i.a.trim(t);
                                    var e = i()("<div></div>").html(t)[0],
                                        n = C.from(e.childNodes),
                                        o = this,
                                        r = !1;
                                    return (
                                        o.so >= 0 &&
                                            ((n = n.reverse()), (r = !0)),
                                        (n = n.map(function (t) {
                                            return o.insertNode(t);
                                        })),
                                        r && (n = n.reverse()),
                                        n
                                    );
                                },
                            },
                            {
                                key: "toString",
                                value: function () {
                                    var t = this.nativeRange();
                                    return m.isW3CRangeSupport
                                        ? t.toString()
                                        : t.text;
                                },
                            },
                            {
                                key: "getWordRange",
                                value: function (e) {
                                    var n = this.getEndPoint();
                                    if (!pt.isCharPoint(n)) return this;
                                    var o = pt.prevPointUntil(n, function (t) {
                                        return !pt.isCharPoint(t);
                                    });
                                    return (
                                        e &&
                                            (n = pt.nextPointUntil(
                                                n,
                                                function (t) {
                                                    return !pt.isCharPoint(t);
                                                }
                                            )),
                                        new t(
                                            o.node,
                                            o.offset,
                                            n.node,
                                            n.offset
                                        )
                                    );
                                },
                            },
                            {
                                key: "getWordsRange",
                                value: function (e) {
                                    var n = this.getEndPoint(),
                                        o = function (t) {
                                            return (
                                                !pt.isCharPoint(t) &&
                                                !pt.isSpacePoint(t)
                                            );
                                        };
                                    if (o(n)) return this;
                                    var i = pt.prevPointUntil(n, o);
                                    return (
                                        e && (n = pt.nextPointUntil(n, o)),
                                        new t(
                                            i.node,
                                            i.offset,
                                            n.node,
                                            n.offset
                                        )
                                    );
                                },
                            },
                            {
                                key: "getWordsMatchRange",
                                value: function (e) {
                                    var n = this.getEndPoint(),
                                        o = pt.prevPointUntil(n, function (o) {
                                            if (
                                                !pt.isCharPoint(o) &&
                                                !pt.isSpacePoint(o)
                                            )
                                                return !0;
                                            var i = new t(
                                                    o.node,
                                                    o.offset,
                                                    n.node,
                                                    n.offset
                                                ),
                                                r = e.exec(i.toString());
                                            return r && 0 === r.index;
                                        }),
                                        i = new t(
                                            o.node,
                                            o.offset,
                                            n.node,
                                            n.offset
                                        ),
                                        r = i.toString(),
                                        a = e.exec(r);
                                    return a && a[0].length === r.length
                                        ? i
                                        : null;
                                },
                            },
                            {
                                key: "bookmark",
                                value: function (t) {
                                    return {
                                        s: {
                                            path: pt.makeOffsetPath(t, this.sc),
                                            offset: this.so,
                                        },
                                        e: {
                                            path: pt.makeOffsetPath(t, this.ec),
                                            offset: this.eo,
                                        },
                                    };
                                },
                            },
                            {
                                key: "paraBookmark",
                                value: function (t) {
                                    return {
                                        s: {
                                            path: C.tail(
                                                pt.makeOffsetPath(
                                                    C.head(t),
                                                    this.sc
                                                )
                                            ),
                                            offset: this.so,
                                        },
                                        e: {
                                            path: C.tail(
                                                pt.makeOffsetPath(
                                                    C.last(t),
                                                    this.ec
                                                )
                                            ),
                                            offset: this.eo,
                                        },
                                    };
                                },
                            },
                            {
                                key: "getClientRects",
                                value: function () {
                                    return this.nativeRange().getClientRects();
                                },
                            },
                        ]) && gt(e.prototype, n),
                        o && gt(e, o),
                        t
                    );
                })(),
                wt = {
                    create: function (t, e, n, o) {
                        if (4 === arguments.length) return new kt(t, e, n, o);
                        if (2 === arguments.length)
                            return new kt(t, e, (n = t), (o = e));
                        var i = this.createFromSelection();
                        if (!i && 1 === arguments.length) {
                            var r = arguments[0];
                            return (
                                pt.isEditable(r) && (r = r.lastChild),
                                this.createFromBodyElement(
                                    r,
                                    pt.emptyPara === arguments[0].innerHTML
                                )
                            );
                        }
                        return i;
                    },
                    createFromBodyElement: function (t) {
                        var e =
                                arguments.length > 1 &&
                                void 0 !== arguments[1] &&
                                arguments[1],
                            n = this.createFromNode(t);
                        return n.collapse(e);
                    },
                    createFromSelection: function () {
                        var t, e, n, o;
                        if (m.isW3CRangeSupport) {
                            var i = document.getSelection();
                            if (!i || 0 === i.rangeCount) return null;
                            if (pt.isBody(i.anchorNode)) return null;
                            var r = i.getRangeAt(0);
                            (t = r.startContainer),
                                (e = r.startOffset),
                                (n = r.endContainer),
                                (o = r.endOffset);
                        } else {
                            var a = document.selection.createRange(),
                                s = a.duplicate();
                            s.collapse(!1);
                            var l = a;
                            l.collapse(!0);
                            var c = bt(l, !0),
                                u = bt(s, !1);
                            pt.isText(c.node) &&
                                pt.isLeftEdgePoint(c) &&
                                pt.isTextNode(u.node) &&
                                pt.isRightEdgePoint(u) &&
                                u.node.nextSibling === c.node &&
                                (c = u),
                                (t = c.cont),
                                (e = c.offset),
                                (n = u.cont),
                                (o = u.offset);
                        }
                        return new kt(t, e, n, o);
                    },
                    createFromNode: function (t) {
                        var e = t,
                            n = 0,
                            o = t,
                            i = pt.nodeLength(o);
                        return (
                            pt.isVoid(e) &&
                                ((n = pt.listPrev(e).length - 1),
                                (e = e.parentNode)),
                            pt.isBR(o)
                                ? ((i = pt.listPrev(o).length - 1),
                                  (o = o.parentNode))
                                : pt.isVoid(o) &&
                                  ((i = pt.listPrev(o).length),
                                  (o = o.parentNode)),
                            this.create(e, n, o, i)
                        );
                    },
                    createFromNodeBefore: function (t) {
                        return this.createFromNode(t).collapse(!0);
                    },
                    createFromNodeAfter: function (t) {
                        return this.createFromNode(t).collapse();
                    },
                    createFromBookmark: function (t, e) {
                        var n = pt.fromOffsetPath(t, e.s.path),
                            o = e.s.offset,
                            i = pt.fromOffsetPath(t, e.e.path),
                            r = e.e.offset;
                        return new kt(n, o, i, r);
                    },
                    createFromParaBookmark: function (t, e) {
                        var n = t.s.offset,
                            o = t.e.offset,
                            i = pt.fromOffsetPath(C.head(e), t.s.path),
                            r = pt.fromOffsetPath(C.last(e), t.e.path);
                        return new kt(i, n, r, o);
                    },
                },
                Ct = {
                    BACKSPACE: 8,
                    TAB: 9,
                    ENTER: 13,
                    ESCAPE: 27,
                    SPACE: 32,
                    DELETE: 46,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    NUM0: 48,
                    NUM1: 49,
                    NUM2: 50,
                    NUM3: 51,
                    NUM4: 52,
                    NUM5: 53,
                    NUM6: 54,
                    NUM7: 55,
                    NUM8: 56,
                    B: 66,
                    E: 69,
                    I: 73,
                    J: 74,
                    K: 75,
                    L: 76,
                    R: 82,
                    S: 83,
                    U: 85,
                    V: 86,
                    Y: 89,
                    Z: 90,
                    SLASH: 191,
                    LEFTBRACKET: 219,
                    BACKSLASH: 220,
                    RIGHTBRACKET: 221,
                    HOME: 36,
                    END: 35,
                    PAGEUP: 33,
                    PAGEDOWN: 34,
                },
                xt = {
                    isEdit: function (t) {
                        return C.contains(
                            [
                                Ct.BACKSPACE,
                                Ct.TAB,
                                Ct.ENTER,
                                Ct.SPACE,
                                Ct.DELETE,
                            ],
                            t
                        );
                    },
                    isMove: function (t) {
                        return C.contains(
                            [Ct.LEFT, Ct.UP, Ct.RIGHT, Ct.DOWN],
                            t
                        );
                    },
                    isNavigation: function (t) {
                        return C.contains(
                            [Ct.HOME, Ct.END, Ct.PAGEUP, Ct.PAGEDOWN],
                            t
                        );
                    },
                    nameFromCode: g.invertObject(Ct),
                    code: Ct,
                };

            function St(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Tt = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.stack = []),
                        (this.stackOffset = -1),
                        (this.context = e),
                        (this.$editable = e.layoutInfo.editable),
                        (this.editable = this.$editable[0]);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "makeSnapshot",
                            value: function () {
                                var t = wt.create(this.editable);
                                return {
                                    contents: this.$editable.html(),
                                    bookmark:
                                        t && t.isOnEditable()
                                            ? t.bookmark(this.editable)
                                            : {
                                                  s: { path: [], offset: 0 },
                                                  e: { path: [], offset: 0 },
                                              },
                                };
                            },
                        },
                        {
                            key: "applySnapshot",
                            value: function (t) {
                                null !== t.contents &&
                                    this.$editable.html(t.contents),
                                    null !== t.bookmark &&
                                        wt
                                            .createFromBookmark(
                                                this.editable,
                                                t.bookmark
                                            )
                                            .select();
                            },
                        },
                        {
                            key: "rewind",
                            value: function () {
                                this.$editable.html() !==
                                    this.stack[this.stackOffset].contents &&
                                    this.recordUndo(),
                                    (this.stackOffset = 0),
                                    this.applySnapshot(
                                        this.stack[this.stackOffset]
                                    );
                            },
                        },
                        {
                            key: "commit",
                            value: function () {
                                (this.stack = []),
                                    (this.stackOffset = -1),
                                    this.recordUndo();
                            },
                        },
                        {
                            key: "reset",
                            value: function () {
                                (this.stack = []),
                                    (this.stackOffset = -1),
                                    this.$editable.html(""),
                                    this.recordUndo();
                            },
                        },
                        {
                            key: "undo",
                            value: function () {
                                this.$editable.html() !==
                                    this.stack[this.stackOffset].contents &&
                                    this.recordUndo(),
                                    this.stackOffset > 0 &&
                                        (this.stackOffset--,
                                        this.applySnapshot(
                                            this.stack[this.stackOffset]
                                        ));
                            },
                        },
                        {
                            key: "redo",
                            value: function () {
                                this.stack.length - 1 > this.stackOffset &&
                                    (this.stackOffset++,
                                    this.applySnapshot(
                                        this.stack[this.stackOffset]
                                    ));
                            },
                        },
                        {
                            key: "recordUndo",
                            value: function () {
                                this.stackOffset++,
                                    this.stack.length > this.stackOffset &&
                                        (this.stack = this.stack.slice(
                                            0,
                                            this.stackOffset
                                        )),
                                    this.stack.push(this.makeSnapshot()),
                                    this.stack.length >
                                        this.context.options.historyLimit &&
                                        (this.stack.shift(),
                                        (this.stackOffset -= 1));
                            },
                        },
                    ]) && St(e.prototype, n),
                    o && St(e, o),
                    t
                );
            })();

            function Et(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var It = (function () {
                function t() {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "jQueryCSS",
                            value: function (t, e) {
                                if (m.jqueryVersion < 1.9) {
                                    var n = {};
                                    return (
                                        i.a.each(e, function (e, o) {
                                            n[o] = t.css(o);
                                        }),
                                        n
                                    );
                                }
                                return t.css(e);
                            },
                        },
                        {
                            key: "fromNode",
                            value: function (t) {
                                var e =
                                        this.jQueryCSS(t, [
                                            "font-family",
                                            "font-size",
                                            "text-align",
                                            "list-style-type",
                                            "line-height",
                                        ]) || {},
                                    n = t[0].style.fontSize || e["font-size"];
                                return (
                                    (e["font-size"] = parseInt(n, 10)),
                                    (e["font-size-unit"] = n.match(/[a-z%]+$/)),
                                    e
                                );
                            },
                        },
                        {
                            key: "stylePara",
                            value: function (t, e) {
                                i.a.each(
                                    t.nodes(pt.isPara, { includeAncestor: !0 }),
                                    function (t, n) {
                                        i()(n).css(e);
                                    }
                                );
                            },
                        },
                        {
                            key: "styleNodes",
                            value: function (t, e) {
                                t = t.splitText();
                                var n = (e && e.nodeName) || "SPAN",
                                    o = !(!e || !e.expandClosestSibling),
                                    r = !(!e || !e.onlyPartialContains);
                                if (t.isCollapsed())
                                    return [t.insertNode(pt.create(n))];
                                var a = pt.makePredByNodeName(n),
                                    s = t
                                        .nodes(pt.isText, { fullyContains: !0 })
                                        .map(function (t) {
                                            return (
                                                pt.singleChildAncestor(t, a) ||
                                                pt.wrap(t, n)
                                            );
                                        });
                                if (o) {
                                    if (r) {
                                        var l = t.nodes();
                                        a = g.and(a, function (t) {
                                            return C.contains(l, t);
                                        });
                                    }
                                    return s.map(function (t) {
                                        var e = pt.withClosestSiblings(t, a),
                                            n = C.head(e),
                                            o = C.tail(e);
                                        return (
                                            i.a.each(o, function (t, e) {
                                                pt.appendChildNodes(
                                                    n,
                                                    e.childNodes
                                                ),
                                                    pt.remove(e);
                                            }),
                                            C.head(e)
                                        );
                                    });
                                }
                                return s;
                            },
                        },
                        {
                            key: "current",
                            value: function (t) {
                                var e = i()(
                                        pt.isElement(t.sc)
                                            ? t.sc
                                            : t.sc.parentNode
                                    ),
                                    n = this.fromNode(e);
                                try {
                                    n = i.a.extend(n, {
                                        "font-bold": document.queryCommandState(
                                            "bold"
                                        )
                                            ? "bold"
                                            : "normal",
                                        "font-italic":
                                            document.queryCommandState("italic")
                                                ? "italic"
                                                : "normal",
                                        "font-underline":
                                            document.queryCommandState(
                                                "underline"
                                            )
                                                ? "underline"
                                                : "normal",
                                        "font-subscript":
                                            document.queryCommandState(
                                                "subscript"
                                            )
                                                ? "subscript"
                                                : "normal",
                                        "font-superscript":
                                            document.queryCommandState(
                                                "superscript"
                                            )
                                                ? "superscript"
                                                : "normal",
                                        "font-strikethrough":
                                            document.queryCommandState(
                                                "strikethrough"
                                            )
                                                ? "strikethrough"
                                                : "normal",
                                        "font-family":
                                            document.queryCommandValue(
                                                "fontname"
                                            ) || n["font-family"],
                                    });
                                } catch (t) {}
                                if (t.isOnList()) {
                                    var o =
                                        [
                                            "circle",
                                            "disc",
                                            "disc-leading-zero",
                                            "square",
                                        ].indexOf(n["list-style-type"]) > -1;
                                    n["list-style"] = o
                                        ? "unordered"
                                        : "ordered";
                                } else n["list-style"] = "none";
                                var r = pt.ancestor(t.sc, pt.isPara);
                                if (r && r.style["line-height"])
                                    n["line-height"] = r.style.lineHeight;
                                else {
                                    var a =
                                        parseInt(n["line-height"], 10) /
                                        parseInt(n["font-size"], 10);
                                    n["line-height"] = a.toFixed(1);
                                }
                                return (
                                    (n.anchor =
                                        t.isOnAnchor() &&
                                        pt.ancestor(t.sc, pt.isAnchor)),
                                    (n.ancestors = pt.listAncestor(
                                        t.sc,
                                        pt.isEditable
                                    )),
                                    (n.range = t),
                                    n
                                );
                            },
                        },
                    ]) && Et(e.prototype, n),
                    o && Et(e, o),
                    t
                );
            })();

            function $t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Nt = (function () {
                function t() {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "insertOrderedList",
                            value: function (t) {
                                this.toggleList("OL", t);
                            },
                        },
                        {
                            key: "insertUnorderedList",
                            value: function (t) {
                                this.toggleList("UL", t);
                            },
                        },
                        {
                            key: "indent",
                            value: function (t) {
                                var e = this,
                                    n = wt.create(t).wrapBodyInlineWithPara(),
                                    o = n.nodes(pt.isPara, {
                                        includeAncestor: !0,
                                    }),
                                    r = C.clusterBy(o, g.peq2("parentNode"));
                                i.a.each(r, function (t, n) {
                                    var o = C.head(n);
                                    if (pt.isLi(o)) {
                                        var r = e.findList(o.previousSibling);
                                        r
                                            ? n.map(function (t) {
                                                  return r.appendChild(t);
                                              })
                                            : (e.wrapList(
                                                  n,
                                                  o.parentNode.nodeName
                                              ),
                                              n
                                                  .map(function (t) {
                                                      return t.parentNode;
                                                  })
                                                  .map(function (t) {
                                                      return e.appendToPrevious(
                                                          t
                                                      );
                                                  }));
                                    } else
                                        i.a.each(n, function (t, e) {
                                            i()(e).css(
                                                "marginLeft",
                                                function (t, e) {
                                                    return (
                                                        (parseInt(e, 10) || 0) +
                                                        25
                                                    );
                                                }
                                            );
                                        });
                                }),
                                    n.select();
                            },
                        },
                        {
                            key: "outdent",
                            value: function (t) {
                                var e = this,
                                    n = wt.create(t).wrapBodyInlineWithPara(),
                                    o = n.nodes(pt.isPara, {
                                        includeAncestor: !0,
                                    }),
                                    r = C.clusterBy(o, g.peq2("parentNode"));
                                i.a.each(r, function (t, n) {
                                    var o = C.head(n);
                                    pt.isLi(o)
                                        ? e.releaseList([n])
                                        : i.a.each(n, function (t, e) {
                                              i()(e).css(
                                                  "marginLeft",
                                                  function (t, e) {
                                                      return (e =
                                                          parseInt(e, 10) ||
                                                          0) > 25
                                                          ? e - 25
                                                          : "";
                                                  }
                                              );
                                          });
                                }),
                                    n.select();
                            },
                        },
                        {
                            key: "toggleList",
                            value: function (t, e) {
                                var n = this,
                                    o = wt.create(e).wrapBodyInlineWithPara(),
                                    r = o.nodes(pt.isPara, {
                                        includeAncestor: !0,
                                    }),
                                    a = o.paraBookmark(r),
                                    s = C.clusterBy(r, g.peq2("parentNode"));
                                if (C.find(r, pt.isPurePara)) {
                                    var l = [];
                                    i.a.each(s, function (e, o) {
                                        l = l.concat(n.wrapList(o, t));
                                    }),
                                        (r = l);
                                } else {
                                    var c = o
                                        .nodes(pt.isList, {
                                            includeAncestor: !0,
                                        })
                                        .filter(function (e) {
                                            return !i.a.nodeName(e, t);
                                        });
                                    c.length
                                        ? i.a.each(c, function (e, n) {
                                              pt.replace(n, t);
                                          })
                                        : (r = this.releaseList(s, !0));
                                }
                                wt.createFromParaBookmark(a, r).select();
                            },
                        },
                        {
                            key: "wrapList",
                            value: function (t, e) {
                                var n = C.head(t),
                                    o = C.last(t),
                                    i =
                                        pt.isList(n.previousSibling) &&
                                        n.previousSibling,
                                    r =
                                        pt.isList(o.nextSibling) &&
                                        o.nextSibling,
                                    a =
                                        i ||
                                        pt.insertAfter(pt.create(e || "UL"), o);
                                return (
                                    (t = t.map(function (t) {
                                        return pt.isPurePara(t)
                                            ? pt.replace(t, "LI")
                                            : t;
                                    })),
                                    pt.appendChildNodes(a, t),
                                    r &&
                                        (pt.appendChildNodes(
                                            a,
                                            C.from(r.childNodes)
                                        ),
                                        pt.remove(r)),
                                    t
                                );
                            },
                        },
                        {
                            key: "releaseList",
                            value: function (t, e) {
                                var n = this,
                                    o = [];
                                return (
                                    i.a.each(t, function (t, r) {
                                        var a = C.head(r),
                                            s = C.last(r),
                                            l = e
                                                ? pt.lastAncestor(a, pt.isList)
                                                : a.parentNode,
                                            c = l.parentNode;
                                        if ("LI" === l.parentNode.nodeName)
                                            r.map(function (t) {
                                                var e = n.findNextSiblings(t);
                                                c.nextSibling
                                                    ? c.parentNode.insertBefore(
                                                          t,
                                                          c.nextSibling
                                                      )
                                                    : c.parentNode.appendChild(
                                                          t
                                                      ),
                                                    e.length &&
                                                        (n.wrapList(
                                                            e,
                                                            l.nodeName
                                                        ),
                                                        t.appendChild(
                                                            e[0].parentNode
                                                        ));
                                            }),
                                                0 === l.children.length &&
                                                    c.removeChild(l),
                                                0 === c.childNodes.length &&
                                                    c.parentNode.removeChild(c);
                                        else {
                                            var u =
                                                    l.childNodes.length > 1
                                                        ? pt.splitTree(
                                                              l,
                                                              {
                                                                  node: s.parentNode,
                                                                  offset:
                                                                      pt.position(
                                                                          s
                                                                      ) + 1,
                                                              },
                                                              {
                                                                  isSkipPaddingBlankHTML:
                                                                      !0,
                                                              }
                                                          )
                                                        : null,
                                                d = pt.splitTree(
                                                    l,
                                                    {
                                                        node: a.parentNode,
                                                        offset: pt.position(a),
                                                    },
                                                    {
                                                        isSkipPaddingBlankHTML:
                                                            !0,
                                                    }
                                                );
                                            (r = e
                                                ? pt.listDescendant(d, pt.isLi)
                                                : C.from(d.childNodes).filter(
                                                      pt.isLi
                                                  )),
                                                (!e &&
                                                    pt.isList(l.parentNode)) ||
                                                    (r = r.map(function (t) {
                                                        return pt.replace(
                                                            t,
                                                            "P"
                                                        );
                                                    })),
                                                i.a.each(
                                                    C.from(r).reverse(),
                                                    function (t, e) {
                                                        pt.insertAfter(e, l);
                                                    }
                                                );
                                            var h = C.compact([l, d, u]);
                                            i.a.each(h, function (t, e) {
                                                var n = [e].concat(
                                                    pt.listDescendant(
                                                        e,
                                                        pt.isList
                                                    )
                                                );
                                                i.a.each(
                                                    n.reverse(),
                                                    function (t, e) {
                                                        pt.nodeLength(e) ||
                                                            pt.remove(e, !0);
                                                    }
                                                );
                                            });
                                        }
                                        o = o.concat(r);
                                    }),
                                    o
                                );
                            },
                        },
                        {
                            key: "appendToPrevious",
                            value: function (t) {
                                return t.previousSibling
                                    ? pt.appendChildNodes(t.previousSibling, [
                                          t,
                                      ])
                                    : this.wrapList([t], "LI");
                            },
                        },
                        {
                            key: "findList",
                            value: function (t) {
                                return t
                                    ? C.find(t.children, function (t) {
                                          return (
                                              ["OL", "UL"].indexOf(t.nodeName) >
                                              -1
                                          );
                                      })
                                    : null;
                            },
                        },
                        {
                            key: "findNextSiblings",
                            value: function (t) {
                                for (var e = []; t.nextSibling; )
                                    e.push(t.nextSibling), (t = t.nextSibling);
                                return e;
                            },
                        },
                    ]) && $t(e.prototype, n),
                    o && $t(e, o),
                    t
                );
            })();

            function Pt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Rt = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.bullet = new Nt()),
                        (this.options = e.options);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "insertTab",
                            value: function (t, e) {
                                var n = pt.createText(
                                    new Array(e + 1).join(pt.NBSP_CHAR)
                                );
                                (t = t.deleteContents()).insertNode(n, !0),
                                    (t = wt.create(n, e)).select();
                            },
                        },
                        {
                            key: "insertParagraph",
                            value: function (t, e) {
                                e = (e = (e =
                                    e ||
                                    wt.create(
                                        t
                                    )).deleteContents()).wrapBodyInlineWithPara();
                                var n,
                                    o = pt.ancestor(e.sc, pt.isPara);
                                if (o) {
                                    if (
                                        pt.isLi(o) &&
                                        (pt.isEmpty(o) ||
                                            pt.deepestChildIsEmpty(o))
                                    )
                                        return void this.bullet.toggleList(
                                            o.parentNode.nodeName
                                        );
                                    var r = null;
                                    if (
                                        (1 ===
                                        this.options.blockquoteBreakingLevel
                                            ? (r = pt.ancestor(
                                                  o,
                                                  pt.isBlockquote
                                              ))
                                            : 2 ===
                                                  this.options
                                                      .blockquoteBreakingLevel &&
                                              (r = pt.lastAncestor(
                                                  o,
                                                  pt.isBlockquote
                                              )),
                                        r)
                                    ) {
                                        (n = i()(pt.emptyPara)[0]),
                                            pt.isRightEdgePoint(
                                                e.getStartPoint()
                                            ) &&
                                                pt.isBR(e.sc.nextSibling) &&
                                                i()(e.sc.nextSibling).remove();
                                        var a = pt.splitTree(
                                            r,
                                            e.getStartPoint(),
                                            { isDiscardEmptySplits: !0 }
                                        );
                                        a
                                            ? a.parentNode.insertBefore(n, a)
                                            : pt.insertAfter(n, r);
                                    } else {
                                        n = pt.splitTree(o, e.getStartPoint());
                                        var s = pt.listDescendant(
                                            o,
                                            pt.isEmptyAnchor
                                        );
                                        (s = s.concat(
                                            pt.listDescendant(
                                                n,
                                                pt.isEmptyAnchor
                                            )
                                        )),
                                            i.a.each(s, function (t, e) {
                                                pt.remove(e);
                                            }),
                                            (pt.isHeading(n) ||
                                                pt.isPre(n) ||
                                                pt.isCustomStyleTag(n)) &&
                                                pt.isEmpty(n) &&
                                                (n = pt.replace(n, "p"));
                                    }
                                } else {
                                    var l = e.sc.childNodes[e.so];
                                    (n = i()(pt.emptyPara)[0]),
                                        l
                                            ? e.sc.insertBefore(n, l)
                                            : e.sc.appendChild(n);
                                }
                                wt.create(n, 0)
                                    .normalize()
                                    .select()
                                    .scrollIntoView(t);
                            },
                        },
                    ]) && Pt(e.prototype, n),
                    o && Pt(e, o),
                    t
                );
            })();

            function Lt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var At = function t(e, n, o, i) {
                var r = { colPos: 0, rowPos: 0 },
                    a = [],
                    s = [];

                function l(t, e, n, o, i, r, s) {
                    var l = {
                        baseRow: n,
                        baseCell: o,
                        isRowSpan: i,
                        isColSpan: r,
                        isVirtual: s,
                    };
                    a[t] || (a[t] = []), (a[t][e] = l);
                }

                function c(t, e, n, o) {
                    return {
                        baseCell: t.baseCell,
                        action: e,
                        virtualTable: { rowIndex: n, cellIndex: o },
                    };
                }

                function u(t, e) {
                    if (!a[t]) return e;
                    if (!a[t][e]) return e;
                    for (var n = e; a[t][n]; ) if ((n++, !a[t][n])) return n;
                }

                function d(t, e) {
                    var n = u(t.rowIndex, e.cellIndex),
                        o = e.colSpan > 1,
                        i = e.rowSpan > 1,
                        a = t.rowIndex === r.rowPos && e.cellIndex === r.colPos;
                    l(t.rowIndex, n, t, e, i, o, !1);
                    var s = e.attributes.rowSpan
                        ? parseInt(e.attributes.rowSpan.value, 10)
                        : 0;
                    if (s > 1)
                        for (var c = 1; c < s; c++) {
                            var d = t.rowIndex + c;
                            h(d, n, e, a), l(d, n, t, e, !0, o, !0);
                        }
                    var f = e.attributes.colSpan
                        ? parseInt(e.attributes.colSpan.value, 10)
                        : 0;
                    if (f > 1)
                        for (var p = 1; p < f; p++) {
                            var m = u(t.rowIndex, n + p);
                            h(t.rowIndex, m, e, a),
                                l(t.rowIndex, m, t, e, i, !0, !0);
                        }
                }

                function h(t, e, n, o) {
                    t === r.rowPos &&
                        r.colPos >= n.cellIndex &&
                        n.cellIndex <= e &&
                        !o &&
                        r.colPos++;
                }

                function f(e) {
                    switch (n) {
                        case t.where.Column:
                            if (e.isColSpan)
                                return t.resultAction.SubtractSpanCount;
                            break;
                        case t.where.Row:
                            if (!e.isVirtual && e.isRowSpan)
                                return t.resultAction.AddCell;
                            if (e.isRowSpan)
                                return t.resultAction.SubtractSpanCount;
                    }
                    return t.resultAction.RemoveCell;
                }

                function p(e) {
                    switch (n) {
                        case t.where.Column:
                            if (e.isColSpan) return t.resultAction.SumSpanCount;
                            if (e.isRowSpan && e.isVirtual)
                                return t.resultAction.Ignore;
                            break;
                        case t.where.Row:
                            if (e.isRowSpan) return t.resultAction.SumSpanCount;
                            if (e.isColSpan && e.isVirtual)
                                return t.resultAction.Ignore;
                    }
                    return t.resultAction.AddCell;
                }

                (this.getActionList = function () {
                    for (
                        var e = n === t.where.Row ? r.rowPos : -1,
                            i = n === t.where.Column ? r.colPos : -1,
                            l = 0,
                            u = !0;
                        u;

                    ) {
                        var d = e >= 0 ? e : l,
                            h = i >= 0 ? i : l,
                            m = a[d];
                        if (!m) return (u = !1), s;
                        var v = m[h];
                        if (!v) return (u = !1), s;
                        var g = t.resultAction.Ignore;
                        switch (o) {
                            case t.requestAction.Add:
                                g = p(v);
                                break;
                            case t.requestAction.Delete:
                                g = f(v);
                        }
                        s.push(c(v, g, d, h)), l++;
                    }
                    return s;
                }),
                    e &&
                        e.tagName &&
                        ("td" === e.tagName.toLowerCase() ||
                            "th" === e.tagName.toLowerCase()) &&
                        ((r.colPos = e.cellIndex),
                        e.parentElement &&
                            e.parentElement.tagName &&
                            "tr" === e.parentElement.tagName.toLowerCase() &&
                            (r.rowPos = e.parentElement.rowIndex)),
                    (function () {
                        for (var t = i.rows, e = 0; e < t.length; e++)
                            for (var n = t[e].cells, o = 0; o < n.length; o++)
                                d(t[e], n[o]);
                    })();
            };
            (At.where = { Row: 0, Column: 1 }),
                (At.requestAction = { Add: 0, Delete: 1 }),
                (At.resultAction = {
                    Ignore: 0,
                    SubtractSpanCount: 1,
                    RemoveCell: 2,
                    AddCell: 3,
                    SumSpanCount: 4,
                });
            var Ft = (function () {
                function t() {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "tab",
                            value: function (t, e) {
                                var n = pt.ancestor(
                                        t.commonAncestor(),
                                        pt.isCell
                                    ),
                                    o = pt.ancestor(n, pt.isTable),
                                    i = pt.listDescendant(o, pt.isCell),
                                    r = C[e ? "prev" : "next"](i, n);
                                r && wt.create(r, 0).select();
                            },
                        },
                        {
                            key: "addRow",
                            value: function (t, e) {
                                for (
                                    var n = pt.ancestor(
                                            t.commonAncestor(),
                                            pt.isCell
                                        ),
                                        o = i()(n).closest("tr"),
                                        r = this.recoverAttributes(o),
                                        a = i()("<tr" + r + "></tr>"),
                                        s = new At(
                                            n,
                                            At.where.Row,
                                            At.requestAction.Add,
                                            i()(o).closest("table")[0]
                                        ).getActionList(),
                                        l = 0;
                                    l < s.length;
                                    l++
                                ) {
                                    var c = s[l],
                                        u = this.recoverAttributes(c.baseCell);
                                    switch (c.action) {
                                        case At.resultAction.AddCell:
                                            a.append(
                                                "<td" +
                                                    u +
                                                    ">" +
                                                    pt.blank +
                                                    "</td>"
                                            );
                                            break;
                                        case At.resultAction.SumSpanCount:
                                            if (
                                                "top" === e &&
                                                (c.baseCell.parent
                                                    ? c.baseCell.closest("tr")
                                                          .rowIndex
                                                    : 0) <= o[0].rowIndex
                                            ) {
                                                var d = i()("<div></div>")
                                                    .append(
                                                        i()(
                                                            "<td" +
                                                                u +
                                                                ">" +
                                                                pt.blank +
                                                                "</td>"
                                                        ).removeAttr("rowspan")
                                                    )
                                                    .html();
                                                a.append(d);
                                                break;
                                            }
                                            var h = parseInt(
                                                c.baseCell.rowSpan,
                                                10
                                            );
                                            h++,
                                                c.baseCell.setAttribute(
                                                    "rowSpan",
                                                    h
                                                );
                                    }
                                }
                                if ("top" === e) o.before(a);
                                else {
                                    if (n.rowSpan > 1) {
                                        var f = o[0].rowIndex + (n.rowSpan - 2);
                                        return void i()(
                                            i()(o).parent().find("tr")[f]
                                        ).after(i()(a));
                                    }
                                    o.after(a);
                                }
                            },
                        },
                        {
                            key: "addCol",
                            value: function (t, e) {
                                var n = pt.ancestor(
                                        t.commonAncestor(),
                                        pt.isCell
                                    ),
                                    o = i()(n).closest("tr");
                                i()(o).siblings().push(o);
                                for (
                                    var r = new At(
                                            n,
                                            At.where.Column,
                                            At.requestAction.Add,
                                            i()(o).closest("table")[0]
                                        ).getActionList(),
                                        a = 0;
                                    a < r.length;
                                    a++
                                ) {
                                    var s = r[a],
                                        l = this.recoverAttributes(s.baseCell);
                                    switch (s.action) {
                                        case At.resultAction.AddCell:
                                            "right" === e
                                                ? i()(s.baseCell).after(
                                                      "<td" +
                                                          l +
                                                          ">" +
                                                          pt.blank +
                                                          "</td>"
                                                  )
                                                : i()(s.baseCell).before(
                                                      "<td" +
                                                          l +
                                                          ">" +
                                                          pt.blank +
                                                          "</td>"
                                                  );
                                            break;
                                        case At.resultAction.SumSpanCount:
                                            if ("right" === e) {
                                                var c = parseInt(
                                                    s.baseCell.colSpan,
                                                    10
                                                );
                                                c++,
                                                    s.baseCell.setAttribute(
                                                        "colSpan",
                                                        c
                                                    );
                                            } else
                                                i()(s.baseCell).before(
                                                    "<td" +
                                                        l +
                                                        ">" +
                                                        pt.blank +
                                                        "</td>"
                                                );
                                    }
                                }
                            },
                        },
                        {
                            key: "recoverAttributes",
                            value: function (t) {
                                var e = "";
                                if (!t) return e;
                                for (
                                    var n = t.attributes || [], o = 0;
                                    o < n.length;
                                    o++
                                )
                                    "id" !== n[o].name.toLowerCase() &&
                                        n[o].specified &&
                                        (e +=
                                            " " +
                                            n[o].name +
                                            "='" +
                                            n[o].value +
                                            "'");
                                return e;
                            },
                        },
                        {
                            key: "deleteRow",
                            value: function (t) {
                                for (
                                    var e = pt.ancestor(
                                            t.commonAncestor(),
                                            pt.isCell
                                        ),
                                        n = i()(e).closest("tr"),
                                        o = n.children("td, th").index(i()(e)),
                                        r = n[0].rowIndex,
                                        a = new At(
                                            e,
                                            At.where.Row,
                                            At.requestAction.Delete,
                                            i()(n).closest("table")[0]
                                        ).getActionList(),
                                        s = 0;
                                    s < a.length;
                                    s++
                                )
                                    if (a[s]) {
                                        var l = a[s].baseCell,
                                            c = a[s].virtualTable,
                                            u = l.rowSpan && l.rowSpan > 1,
                                            d = u ? parseInt(l.rowSpan, 10) : 0;
                                        switch (a[s].action) {
                                            case At.resultAction.Ignore:
                                                continue;
                                            case At.resultAction.AddCell:
                                                var h = n.next("tr")[0];
                                                if (!h) continue;
                                                var f = n[0].cells[o];
                                                u &&
                                                    (d > 2
                                                        ? (d--,
                                                          h.insertBefore(
                                                              f,
                                                              h.cells[o]
                                                          ),
                                                          h.cells[
                                                              o
                                                          ].setAttribute(
                                                              "rowSpan",
                                                              d
                                                          ),
                                                          (h.cells[
                                                              o
                                                          ].innerHTML = ""))
                                                        : 2 === d &&
                                                          (h.insertBefore(
                                                              f,
                                                              h.cells[o]
                                                          ),
                                                          h.cells[
                                                              o
                                                          ].removeAttribute(
                                                              "rowSpan"
                                                          ),
                                                          (h.cells[
                                                              o
                                                          ].innerHTML = "")));
                                                continue;
                                            case At.resultAction
                                                .SubtractSpanCount:
                                                u &&
                                                    (d > 2
                                                        ? (d--,
                                                          l.setAttribute(
                                                              "rowSpan",
                                                              d
                                                          ),
                                                          c.rowIndex !== r &&
                                                              l.cellIndex ===
                                                                  o &&
                                                              (l.innerHTML =
                                                                  ""))
                                                        : 2 === d &&
                                                          (l.removeAttribute(
                                                              "rowSpan"
                                                          ),
                                                          c.rowIndex !== r &&
                                                              l.cellIndex ===
                                                                  o &&
                                                              (l.innerHTML =
                                                                  "")));
                                                continue;
                                            case At.resultAction.RemoveCell:
                                                continue;
                                        }
                                    }
                                n.remove();
                            },
                        },
                        {
                            key: "deleteCol",
                            value: function (t) {
                                for (
                                    var e = pt.ancestor(
                                            t.commonAncestor(),
                                            pt.isCell
                                        ),
                                        n = i()(e).closest("tr"),
                                        o = n.children("td, th").index(i()(e)),
                                        r = new At(
                                            e,
                                            At.where.Column,
                                            At.requestAction.Delete,
                                            i()(n).closest("table")[0]
                                        ).getActionList(),
                                        a = 0;
                                    a < r.length;
                                    a++
                                )
                                    if (r[a])
                                        switch (r[a].action) {
                                            case At.resultAction.Ignore:
                                                continue;
                                            case At.resultAction
                                                .SubtractSpanCount:
                                                var s = r[a].baseCell;
                                                if (
                                                    s.colSpan &&
                                                    s.colSpan > 1
                                                ) {
                                                    var l = s.colSpan
                                                        ? parseInt(
                                                              s.colSpan,
                                                              10
                                                          )
                                                        : 0;
                                                    l > 2
                                                        ? (l--,
                                                          s.setAttribute(
                                                              "colSpan",
                                                              l
                                                          ),
                                                          s.cellIndex === o &&
                                                              (s.innerHTML =
                                                                  ""))
                                                        : 2 === l &&
                                                          (s.removeAttribute(
                                                              "colSpan"
                                                          ),
                                                          s.cellIndex === o &&
                                                              (s.innerHTML =
                                                                  ""));
                                                }
                                                continue;
                                            case At.resultAction.RemoveCell:
                                                pt.remove(r[a].baseCell, !0);
                                                continue;
                                        }
                            },
                        },
                        {
                            key: "createTable",
                            value: function (t, e, n) {
                                for (var o, r = [], a = 0; a < t; a++)
                                    r.push("<td>" + pt.blank + "</td>");
                                o = r.join("");
                                for (var s, l = [], c = 0; c < e; c++)
                                    l.push("<tr>" + o + "</tr>");
                                s = l.join("");
                                var u = i()("<table>" + s + "</table>");
                                return (
                                    n &&
                                        n.tableClassName &&
                                        u.addClass(n.tableClassName),
                                    u[0]
                                );
                            },
                        },
                        {
                            key: "deleteTable",
                            value: function (t) {
                                var e = pt.ancestor(
                                    t.commonAncestor(),
                                    pt.isCell
                                );
                                i()(e).closest("table").remove();
                            },
                        },
                    ]) && Lt(e.prototype, n),
                    o && Lt(e, o),
                    t
                );
            })();

            function Dt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Ht = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$note = e.layoutInfo.note),
                        (this.$editor = e.layoutInfo.editor),
                        (this.$editable = e.layoutInfo.editable),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo),
                        (this.editable = this.$editable[0]),
                        (this.lastRange = null),
                        (this.snapshot = null),
                        (this.style = new It()),
                        (this.table = new Ft()),
                        (this.typing = new Rt(e)),
                        (this.bullet = new Nt()),
                        (this.history = new Tt(e)),
                        this.context.memo("help.escape", this.lang.help.escape),
                        this.context.memo("help.undo", this.lang.help.undo),
                        this.context.memo("help.redo", this.lang.help.redo),
                        this.context.memo("help.tab", this.lang.help.tab),
                        this.context.memo("help.untab", this.lang.help.untab),
                        this.context.memo(
                            "help.insertParagraph",
                            this.lang.help.insertParagraph
                        ),
                        this.context.memo(
                            "help.insertOrderedList",
                            this.lang.help.insertOrderedList
                        ),
                        this.context.memo(
                            "help.insertUnorderedList",
                            this.lang.help.insertUnorderedList
                        ),
                        this.context.memo("help.indent", this.lang.help.indent),
                        this.context.memo(
                            "help.outdent",
                            this.lang.help.outdent
                        ),
                        this.context.memo(
                            "help.formatPara",
                            this.lang.help.formatPara
                        ),
                        this.context.memo(
                            "help.insertHorizontalRule",
                            this.lang.help.insertHorizontalRule
                        ),
                        this.context.memo(
                            "help.fontName",
                            this.lang.help.fontName
                        );
                    for (
                        var o = [
                                "bold",
                                "italic",
                                "underline",
                                "strikethrough",
                                "superscript",
                                "subscript",
                                "justifyLeft",
                                "justifyCenter",
                                "justifyRight",
                                "justifyFull",
                                "formatBlock",
                                "removeFormat",
                                "backColor",
                            ],
                            r = 0,
                            a = o.length;
                        r < a;
                        r++
                    )
                        (this[o[r]] = (function (t) {
                            return function (e) {
                                n.beforeCommand(),
                                    document.execCommand(t, !1, e),
                                    n.afterCommand(!0);
                            };
                        })(o[r])),
                            this.context.memo(
                                "help." + o[r],
                                this.lang.help[o[r]]
                            );
                    (this.fontName = this.wrapCommand(function (t) {
                        return n.fontStyling("font-family", m.validFontName(t));
                    })),
                        (this.fontSize = this.wrapCommand(function (t) {
                            var e = n.currentStyle()["font-size-unit"];
                            return n.fontStyling("font-size", t + e);
                        })),
                        (this.fontSizeUnit = this.wrapCommand(function (t) {
                            var e = n.currentStyle()["font-size"];
                            return n.fontStyling("font-size", e + t);
                        }));
                    for (var s = 1; s <= 6; s++)
                        (this["formatH" + s] = (function (t) {
                            return function () {
                                n.formatBlock("H" + t);
                            };
                        })(s)),
                            this.context.memo(
                                "help.formatH" + s,
                                this.lang.help["formatH" + s]
                            );
                    (this.insertParagraph = this.wrapCommand(function () {
                        n.typing.insertParagraph(n.editable);
                    })),
                        (this.insertOrderedList = this.wrapCommand(function () {
                            n.bullet.insertOrderedList(n.editable);
                        })),
                        (this.insertUnorderedList = this.wrapCommand(
                            function () {
                                n.bullet.insertUnorderedList(n.editable);
                            }
                        )),
                        (this.indent = this.wrapCommand(function () {
                            n.bullet.indent(n.editable);
                        })),
                        (this.outdent = this.wrapCommand(function () {
                            n.bullet.outdent(n.editable);
                        })),
                        (this.insertNode = this.wrapCommand(function (t) {
                            n.isLimited(i()(t).text().length) ||
                                (n.getLastRange().insertNode(t),
                                n.setLastRange(
                                    wt.createFromNodeAfter(t).select()
                                ));
                        })),
                        (this.insertText = this.wrapCommand(function (t) {
                            if (!n.isLimited(t.length)) {
                                var e = n
                                    .getLastRange()
                                    .insertNode(pt.createText(t));
                                n.setLastRange(
                                    wt.create(e, pt.nodeLength(e)).select()
                                );
                            }
                        })),
                        (this.pasteHTML = this.wrapCommand(function (t) {
                            if (!n.isLimited(t.length)) {
                                t = n.context.invoke("codeview.purify", t);
                                var e = n.getLastRange().pasteHTML(t);
                                n.setLastRange(
                                    wt.createFromNodeAfter(C.last(e)).select()
                                );
                            }
                        })),
                        (this.formatBlock = this.wrapCommand(function (t, e) {
                            var o = n.options.callbacks.onApplyCustomStyle;
                            o
                                ? o.call(n, e, n.context, n.onFormatBlock)
                                : n.onFormatBlock(t, e);
                        })),
                        (this.insertHorizontalRule = this.wrapCommand(
                            function () {
                                var t = n
                                    .getLastRange()
                                    .insertNode(pt.create("HR"));
                                t.nextSibling &&
                                    n.setLastRange(
                                        wt
                                            .create(t.nextSibling, 0)
                                            .normalize()
                                            .select()
                                    );
                            }
                        )),
                        (this.lineHeight = this.wrapCommand(function (t) {
                            n.style.stylePara(n.getLastRange(), {
                                lineHeight: t,
                            });
                        })),
                        (this.createLink = this.wrapCommand(function (t) {
                            var e = t.url,
                                o = t.text,
                                r = t.isNewWindow,
                                a = t.checkProtocol,
                                s = t.range || n.getLastRange(),
                                l = o.length - s.toString().length;
                            if (!(l > 0 && n.isLimited(l))) {
                                var c = s.toString() !== o;
                                "string" == typeof e && (e = e.trim()),
                                    n.options.onCreateLink
                                        ? (e = n.options.onCreateLink(e))
                                        : a &&
                                          (e =
                                              /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/.test(
                                                  e
                                              )
                                                  ? e
                                                  : n.options.defaultProtocol +
                                                    e);
                                var u = [];
                                if (c) {
                                    var d = (s = s.deleteContents()).insertNode(
                                        i()("<A>" + o + "</A>")[0]
                                    );
                                    u.push(d);
                                } else
                                    u = n.style.styleNodes(s, {
                                        nodeName: "A",
                                        expandClosestSibling: !0,
                                        onlyPartialContains: !0,
                                    });
                                i.a.each(u, function (t, n) {
                                    i()(n).attr("href", e),
                                        r
                                            ? i()(n).attr("target", "_blank")
                                            : i()(n).removeAttr("target");
                                }),
                                    n.setLastRange(
                                        n.createRangeFromList(u).select()
                                    );
                            }
                        })),
                        (this.color = this.wrapCommand(function (t) {
                            var e = t.foreColor,
                                n = t.backColor;
                            e && document.execCommand("foreColor", !1, e),
                                n && document.execCommand("backColor", !1, n);
                        })),
                        (this.foreColor = this.wrapCommand(function (t) {
                            document.execCommand("foreColor", !1, t);
                        })),
                        (this.insertTable = this.wrapCommand(function (t) {
                            var e = t.split("x");
                            n.getLastRange()
                                .deleteContents()
                                .insertNode(
                                    n.table.createTable(e[0], e[1], n.options)
                                );
                        })),
                        (this.removeMedia = this.wrapCommand(function () {
                            var t = i()(n.restoreTarget()).parent();
                            t.closest("figure").length
                                ? t.closest("figure").remove()
                                : (t = i()(n.restoreTarget()).detach()),
                                n.context.triggerEvent(
                                    "media.delete",
                                    t,
                                    n.$editable
                                );
                        })),
                        (this.floatMe = this.wrapCommand(function (t) {
                            var e = i()(n.restoreTarget());
                            e.toggleClass("note-float-left", "left" === t),
                                e.toggleClass(
                                    "note-float-right",
                                    "right" === t
                                ),
                                e.css("float", "none" === t ? "" : t);
                        })),
                        (this.resize = this.wrapCommand(function (t) {
                            var e = i()(n.restoreTarget());
                            0 === (t = parseFloat(t))
                                ? e.css("width", "")
                                : e.css({ width: 100 * t + "%", height: "" });
                        }));
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                this.$editable
                                    .on("keydown", function (e) {
                                        if (
                                            (e.keyCode === xt.code.ENTER &&
                                                t.context.triggerEvent(
                                                    "enter",
                                                    e
                                                ),
                                            t.context.triggerEvent(
                                                "keydown",
                                                e
                                            ),
                                            (t.snapshot =
                                                t.history.makeSnapshot()),
                                            (t.hasKeyShortCut = !1),
                                            e.isDefaultPrevented() ||
                                                (t.options.shortcuts
                                                    ? (t.hasKeyShortCut =
                                                          t.handleKeyMap(e))
                                                    : t.preventDefaultEditableShortCuts(
                                                          e
                                                      )),
                                            t.isLimited(1, e))
                                        ) {
                                            var n = t.getLastRange();
                                            if (n.eo - n.so == 0) return !1;
                                        }
                                        t.setLastRange(),
                                            t.options.recordEveryKeystroke &&
                                                !1 === t.hasKeyShortCut &&
                                                t.history.recordUndo();
                                    })
                                    .on("keyup", function (e) {
                                        t.setLastRange(),
                                            t.context.triggerEvent("keyup", e);
                                    })
                                    .on("focus", function (e) {
                                        t.setLastRange(),
                                            t.context.triggerEvent("focus", e);
                                    })
                                    .on("blur", function (e) {
                                        t.context.triggerEvent("blur", e);
                                    })
                                    .on("mousedown", function (e) {
                                        t.context.triggerEvent("mousedown", e);
                                    })
                                    .on("mouseup", function (e) {
                                        t.setLastRange(),
                                            t.history.recordUndo(),
                                            t.context.triggerEvent(
                                                "mouseup",
                                                e
                                            );
                                    })
                                    .on("scroll", function (e) {
                                        t.context.triggerEvent("scroll", e);
                                    })
                                    .on("paste", function (e) {
                                        t.setLastRange(),
                                            t.context.triggerEvent("paste", e);
                                    })
                                    .on("input", function () {
                                        t.isLimited(0) &&
                                            t.snapshot &&
                                            t.history.applySnapshot(t.snapshot);
                                    }),
                                    this.$editable.attr(
                                        "spellcheck",
                                        this.options.spellCheck
                                    ),
                                    this.$editable.attr(
                                        "autocorrect",
                                        this.options.spellCheck
                                    ),
                                    this.options.disableGrammar &&
                                        this.$editable.attr("data-gramm", !1),
                                    this.$editable.html(
                                        pt.html(this.$note) || pt.emptyPara
                                    ),
                                    this.$editable.on(
                                        m.inputEventName,
                                        g.debounce(function () {
                                            t.context.triggerEvent(
                                                "change",
                                                t.$editable.html(),
                                                t.$editable
                                            );
                                        }, 10)
                                    ),
                                    this.$editable
                                        .on("focusin", function (e) {
                                            t.context.triggerEvent(
                                                "focusin",
                                                e
                                            );
                                        })
                                        .on("focusout", function (e) {
                                            t.context.triggerEvent(
                                                "focusout",
                                                e
                                            );
                                        }),
                                    this.options.airMode
                                        ? this.options.overrideContextMenu &&
                                          this.$editor.on(
                                              "contextmenu",
                                              function (e) {
                                                  return (
                                                      t.context.triggerEvent(
                                                          "contextmenu",
                                                          e
                                                      ),
                                                      !1
                                                  );
                                              }
                                          )
                                        : (this.options.width &&
                                              this.$editor.outerWidth(
                                                  this.options.width
                                              ),
                                          this.options.height &&
                                              this.$editable.outerHeight(
                                                  this.options.height
                                              ),
                                          this.options.maxHeight &&
                                              this.$editable.css(
                                                  "max-height",
                                                  this.options.maxHeight
                                              ),
                                          this.options.minHeight &&
                                              this.$editable.css(
                                                  "min-height",
                                                  this.options.minHeight
                                              )),
                                    this.history.recordUndo(),
                                    this.setLastRange();
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$editable.off();
                            },
                        },
                        {
                            key: "handleKeyMap",
                            value: function (t) {
                                var e =
                                        this.options.keyMap[
                                            m.isMac ? "mac" : "pc"
                                        ],
                                    n = [];
                                t.metaKey && n.push("CMD"),
                                    t.ctrlKey && !t.altKey && n.push("CTRL"),
                                    t.shiftKey && n.push("SHIFT");
                                var o = xt.nameFromCode[t.keyCode];
                                o && n.push(o);
                                var i = e[n.join("+")];
                                if ("TAB" !== o || this.options.tabDisable)
                                    if (i) {
                                        if (!1 !== this.context.invoke(i))
                                            return t.preventDefault(), !0;
                                    } else
                                        xt.isEdit(t.keyCode) &&
                                            this.afterCommand();
                                else this.afterCommand();
                                return !1;
                            },
                        },
                        {
                            key: "preventDefaultEditableShortCuts",
                            value: function (t) {
                                (t.ctrlKey || t.metaKey) &&
                                    C.contains([66, 73, 85], t.keyCode) &&
                                    t.preventDefault();
                            },
                        },
                        {
                            key: "isLimited",
                            value: function (t, e) {
                                return (
                                    (t = t || 0),
                                    (void 0 === e ||
                                        !(
                                            xt.isMove(e.keyCode) ||
                                            xt.isNavigation(e.keyCode) ||
                                            e.ctrlKey ||
                                            e.metaKey ||
                                            C.contains(
                                                [
                                                    xt.code.BACKSPACE,
                                                    xt.code.DELETE,
                                                ],
                                                e.keyCode
                                            )
                                        )) &&
                                        this.options.maxTextLength > 0 &&
                                        this.$editable.text().length + t >
                                            this.options.maxTextLength
                                );
                            },
                        },
                        {
                            key: "createRange",
                            value: function () {
                                return (
                                    this.focus(),
                                    this.setLastRange(),
                                    this.getLastRange()
                                );
                            },
                        },
                        {
                            key: "createRangeFromList",
                            value: function (t) {
                                var e = wt
                                        .createFromNodeBefore(C.head(t))
                                        .getStartPoint(),
                                    n = wt
                                        .createFromNodeAfter(C.last(t))
                                        .getEndPoint();
                                return wt.create(
                                    e.node,
                                    e.offset,
                                    n.node,
                                    n.offset
                                );
                            },
                        },
                        {
                            key: "setLastRange",
                            value: function (t) {
                                t
                                    ? (this.lastRange = t)
                                    : ((this.lastRange = wt.create(
                                          this.editable
                                      )),
                                      0 ===
                                          i()(this.lastRange.sc).closest(
                                              ".note-editable"
                                          ).length &&
                                          (this.lastRange =
                                              wt.createFromBodyElement(
                                                  this.editable
                                              )));
                            },
                        },
                        {
                            key: "getLastRange",
                            value: function () {
                                return (
                                    this.lastRange || this.setLastRange(),
                                    this.lastRange
                                );
                            },
                        },
                        {
                            key: "saveRange",
                            value: function (t) {
                                t && this.getLastRange().collapse().select();
                            },
                        },
                        {
                            key: "restoreRange",
                            value: function () {
                                this.lastRange &&
                                    (this.lastRange.select(), this.focus());
                            },
                        },
                        {
                            key: "saveTarget",
                            value: function (t) {
                                this.$editable.data("target", t);
                            },
                        },
                        {
                            key: "clearTarget",
                            value: function () {
                                this.$editable.removeData("target");
                            },
                        },
                        {
                            key: "restoreTarget",
                            value: function () {
                                return this.$editable.data("target");
                            },
                        },
                        {
                            key: "currentStyle",
                            value: function () {
                                var t = wt.create();
                                return (
                                    t && (t = t.normalize()),
                                    t
                                        ? this.style.current(t)
                                        : this.style.fromNode(this.$editable)
                                );
                            },
                        },
                        {
                            key: "styleFromNode",
                            value: function (t) {
                                return this.style.fromNode(t);
                            },
                        },
                        {
                            key: "undo",
                            value: function () {
                                this.context.triggerEvent(
                                    "before.command",
                                    this.$editable.html()
                                ),
                                    this.history.undo(),
                                    this.context.triggerEvent(
                                        "change",
                                        this.$editable.html(),
                                        this.$editable
                                    );
                            },
                        },
                        {
                            key: "commit",
                            value: function () {
                                this.context.triggerEvent(
                                    "before.command",
                                    this.$editable.html()
                                ),
                                    this.history.commit(),
                                    this.context.triggerEvent(
                                        "change",
                                        this.$editable.html(),
                                        this.$editable
                                    );
                            },
                        },
                        {
                            key: "redo",
                            value: function () {
                                this.context.triggerEvent(
                                    "before.command",
                                    this.$editable.html()
                                ),
                                    this.history.redo(),
                                    this.context.triggerEvent(
                                        "change",
                                        this.$editable.html(),
                                        this.$editable
                                    );
                            },
                        },
                        {
                            key: "beforeCommand",
                            value: function () {
                                this.context.triggerEvent(
                                    "before.command",
                                    this.$editable.html()
                                ),
                                    document.execCommand(
                                        "styleWithCSS",
                                        !1,
                                        this.options.styleWithCSS
                                    ),
                                    this.focus();
                            },
                        },
                        {
                            key: "afterCommand",
                            value: function (t) {
                                this.normalizeContent(),
                                    this.history.recordUndo(),
                                    t ||
                                        this.context.triggerEvent(
                                            "change",
                                            this.$editable.html(),
                                            this.$editable
                                        );
                            },
                        },
                        {
                            key: "tab",
                            value: function () {
                                var t = this.getLastRange();
                                if (t.isCollapsed() && t.isOnCell())
                                    this.table.tab(t);
                                else {
                                    if (0 === this.options.tabSize) return !1;
                                    this.isLimited(this.options.tabSize) ||
                                        (this.beforeCommand(),
                                        this.typing.insertTab(
                                            t,
                                            this.options.tabSize
                                        ),
                                        this.afterCommand());
                                }
                            },
                        },
                        {
                            key: "untab",
                            value: function () {
                                var t = this.getLastRange();
                                if (t.isCollapsed() && t.isOnCell())
                                    this.table.tab(t, !0);
                                else if (0 === this.options.tabSize) return !1;
                            },
                        },
                        {
                            key: "wrapCommand",
                            value: function (t) {
                                return function () {
                                    this.beforeCommand(),
                                        t.apply(this, arguments),
                                        this.afterCommand();
                                };
                            },
                        },
                        {
                            key: "insertImage",
                            value: function (t, e) {
                                var n,
                                    o = this;
                                return ((n = t),
                                i.a
                                    .Deferred(function (t) {
                                        var e = i()("<img>");
                                        e.one("load", function () {
                                            e.off("error abort"), t.resolve(e);
                                        })
                                            .one("error abort", function () {
                                                e.off("load").detach(),
                                                    t.reject(e);
                                            })
                                            .css({ display: "none" })
                                            .appendTo(document.body)
                                            .attr("src", n);
                                    })
                                    .promise())
                                    .then(function (t) {
                                        o.beforeCommand(),
                                            "function" == typeof e
                                                ? e(t)
                                                : ("string" == typeof e &&
                                                      t.attr(
                                                          "data-filename",
                                                          e
                                                      ),
                                                  t.css(
                                                      "width",
                                                      Math.min(
                                                          o.$editable.width(),
                                                          t.width()
                                                      )
                                                  )),
                                            t.show(),
                                            o.getLastRange().insertNode(t[0]),
                                            o.setLastRange(
                                                wt
                                                    .createFromNodeAfter(t[0])
                                                    .select()
                                            ),
                                            o.afterCommand();
                                    })
                                    .fail(function (t) {
                                        o.context.triggerEvent(
                                            "image.upload.error",
                                            t
                                        );
                                    });
                            },
                        },
                        {
                            key: "insertImagesAsDataURL",
                            value: function (t) {
                                var e = this;
                                i.a.each(t, function (t, n) {
                                    var o = n.name;
                                    e.options.maximumImageFileSize &&
                                    e.options.maximumImageFileSize < n.size
                                        ? e.context.triggerEvent(
                                              "image.upload.error",
                                              e.lang.image.maximumFileSizeError
                                          )
                                        : (function (t) {
                                              return i.a
                                                  .Deferred(function (e) {
                                                      i.a
                                                          .extend(
                                                              new FileReader(),
                                                              {
                                                                  onload: function (
                                                                      t
                                                                  ) {
                                                                      var n =
                                                                          t
                                                                              .target
                                                                              .result;
                                                                      e.resolve(
                                                                          n
                                                                      );
                                                                  },
                                                                  onerror:
                                                                      function (
                                                                          t
                                                                      ) {
                                                                          e.reject(
                                                                              t
                                                                          );
                                                                      },
                                                              }
                                                          )
                                                          .readAsDataURL(t);
                                                  })
                                                  .promise();
                                          })(n)
                                              .then(function (t) {
                                                  return e.insertImage(t, o);
                                              })
                                              .fail(function () {
                                                  e.context.triggerEvent(
                                                      "image.upload.error"
                                                  );
                                              });
                                });
                            },
                        },
                        {
                            key: "insertImagesOrCallback",
                            value: function (t) {
                                this.options.callbacks.onImageUpload
                                    ? this.context.triggerEvent(
                                          "image.upload",
                                          t
                                      )
                                    : this.insertImagesAsDataURL(t);
                            },
                        },
                        {
                            key: "getSelectedText",
                            value: function () {
                                var t = this.getLastRange();
                                return (
                                    t.isOnAnchor() &&
                                        (t = wt.createFromNode(
                                            pt.ancestor(t.sc, pt.isAnchor)
                                        )),
                                    t.toString()
                                );
                            },
                        },
                        {
                            key: "onFormatBlock",
                            value: function (t, e) {
                                if (
                                    (document.execCommand(
                                        "FormatBlock",
                                        !1,
                                        m.isMSIE ? "<" + t + ">" : t
                                    ),
                                    e &&
                                        e.length &&
                                        (e[0].tagName.toUpperCase() !==
                                            t.toUpperCase() && (e = e.find(t)),
                                        e && e.length))
                                ) {
                                    var n = e[0].className || "";
                                    if (n) {
                                        var o = this.createRange();
                                        i()([o.sc, o.ec])
                                            .closest(t)
                                            .addClass(n);
                                    }
                                }
                            },
                        },
                        {
                            key: "formatPara",
                            value: function () {
                                this.formatBlock("P");
                            },
                        },
                        {
                            key: "fontStyling",
                            value: function (t, e) {
                                var n = this.getLastRange();
                                if ("" !== n) {
                                    var o = this.style.styleNodes(n);
                                    if (
                                        (this.$editor
                                            .find(".note-status-output")
                                            .html(""),
                                        i()(o).css(t, e),
                                        n.isCollapsed())
                                    ) {
                                        var r = C.head(o);
                                        r &&
                                            !pt.nodeLength(r) &&
                                            ((r.innerHTML =
                                                pt.ZERO_WIDTH_NBSP_CHAR),
                                            wt
                                                .createFromNode(r.firstChild)
                                                .select(),
                                            this.setLastRange(),
                                            this.$editable.data("bogus", r));
                                    } else
                                        this.setLastRange(
                                            this.createRangeFromList(o).select()
                                        );
                                } else {
                                    var a = i.a.now();
                                    this.$editor
                                        .find(".note-status-output")
                                        .html(
                                            '<div id="note-status-output-' +
                                                a +
                                                '" class="alert alert-info">' +
                                                this.lang.output.noSelection +
                                                "</div>"
                                        ),
                                        setTimeout(function () {
                                            i()(
                                                "#note-status-output-" + a
                                            ).remove();
                                        }, 5e3);
                                }
                            },
                        },
                        {
                            key: "unlink",
                            value: function () {
                                var t = this.getLastRange();
                                if (t.isOnAnchor()) {
                                    var e = pt.ancestor(t.sc, pt.isAnchor);
                                    (t = wt.createFromNode(e)).select(),
                                        this.setLastRange(),
                                        this.beforeCommand(),
                                        document.execCommand("unlink"),
                                        this.afterCommand();
                                }
                            },
                        },
                        {
                            key: "getLinkInfo",
                            value: function () {
                                var t = this.getLastRange().expand(pt.isAnchor),
                                    e = i()(C.head(t.nodes(pt.isAnchor))),
                                    n = {
                                        range: t,
                                        text: t.toString(),
                                        url: e.length ? e.attr("href") : "",
                                    };
                                return (
                                    e.length &&
                                        (n.isNewWindow =
                                            "_blank" === e.attr("target")),
                                    n
                                );
                            },
                        },
                        {
                            key: "addRow",
                            value: function (t) {
                                var e = this.getLastRange(this.$editable);
                                e.isCollapsed() &&
                                    e.isOnCell() &&
                                    (this.beforeCommand(),
                                    this.table.addRow(e, t),
                                    this.afterCommand());
                            },
                        },
                        {
                            key: "addCol",
                            value: function (t) {
                                var e = this.getLastRange(this.$editable);
                                e.isCollapsed() &&
                                    e.isOnCell() &&
                                    (this.beforeCommand(),
                                    this.table.addCol(e, t),
                                    this.afterCommand());
                            },
                        },
                        {
                            key: "deleteRow",
                            value: function () {
                                var t = this.getLastRange(this.$editable);
                                t.isCollapsed() &&
                                    t.isOnCell() &&
                                    (this.beforeCommand(),
                                    this.table.deleteRow(t),
                                    this.afterCommand());
                            },
                        },
                        {
                            key: "deleteCol",
                            value: function () {
                                var t = this.getLastRange(this.$editable);
                                t.isCollapsed() &&
                                    t.isOnCell() &&
                                    (this.beforeCommand(),
                                    this.table.deleteCol(t),
                                    this.afterCommand());
                            },
                        },
                        {
                            key: "deleteTable",
                            value: function () {
                                var t = this.getLastRange(this.$editable);
                                t.isCollapsed() &&
                                    t.isOnCell() &&
                                    (this.beforeCommand(),
                                    this.table.deleteTable(t),
                                    this.afterCommand());
                            },
                        },
                        {
                            key: "resizeTo",
                            value: function (t, e, n) {
                                var o;
                                if (n) {
                                    var i = t.y / t.x,
                                        r = e.data("ratio");
                                    o = {
                                        width: r > i ? t.x : t.y / r,
                                        height: r > i ? t.x * r : t.y,
                                    };
                                } else o = { width: t.x, height: t.y };
                                e.css(o);
                            },
                        },
                        {
                            key: "hasFocus",
                            value: function () {
                                return this.$editable.is(":focus");
                            },
                        },
                        {
                            key: "focus",
                            value: function () {
                                this.hasFocus() || this.$editable.focus();
                            },
                        },
                        {
                            key: "isEmpty",
                            value: function () {
                                return (
                                    pt.isEmpty(this.$editable[0]) ||
                                    pt.emptyPara === this.$editable.html()
                                );
                            },
                        },
                        {
                            key: "empty",
                            value: function () {
                                this.context.invoke("code", pt.emptyPara);
                            },
                        },
                        {
                            key: "normalizeContent",
                            value: function () {
                                this.$editable[0].normalize();
                            },
                        },
                    ]) && Dt(e.prototype, n),
                    o && Dt(e, o),
                    t
                );
            })();

            function zt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Bt = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$editable = e.layoutInfo.editable);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                this.$editable.on(
                                    "paste",
                                    this.pasteByEvent.bind(this)
                                );
                            },
                        },
                        {
                            key: "pasteByEvent",
                            value: function (t) {
                                var e = this,
                                    n = t.originalEvent.clipboardData;
                                if (n && n.items && n.items.length) {
                                    var o =
                                        n.items.length > 1
                                            ? n.items[1]
                                            : C.head(n.items);
                                    "file" === o.kind &&
                                    -1 !== o.type.indexOf("image/")
                                        ? (this.context.invoke(
                                              "editor.insertImagesOrCallback",
                                              [o.getAsFile()]
                                          ),
                                          t.preventDefault())
                                        : "string" === o.kind &&
                                          this.context.invoke(
                                              "editor.isLimited",
                                              n.getData("Text").length
                                          ) &&
                                          t.preventDefault();
                                } else if (window.clipboardData) {
                                    var i =
                                        window.clipboardData.getData("text");
                                    this.context.invoke(
                                        "editor.isLimited",
                                        i.length
                                    ) && t.preventDefault();
                                }
                                setTimeout(function () {
                                    e.context.invoke("editor.afterCommand");
                                }, 10);
                            },
                        },
                    ]) && zt(e.prototype, n),
                    o && zt(e, o),
                    t
                );
            })();

            function Mt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Ot = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$eventListener = i()(document)),
                        (this.$editor = e.layoutInfo.editor),
                        (this.$editable = e.layoutInfo.editable),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo),
                        (this.documentEventHandlers = {}),
                        (this.$dropzone = i()(
                            [
                                '<div class="note-dropzone">',
                                '<div class="note-dropzone-message"></div>',
                                "</div>",
                            ].join("")
                        ).prependTo(this.$editor));
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                this.options.disableDragAndDrop
                                    ? ((this.documentEventHandlers.onDrop =
                                          function (t) {
                                              t.preventDefault();
                                          }),
                                      (this.$eventListener = this.$dropzone),
                                      this.$eventListener.on(
                                          "drop",
                                          this.documentEventHandlers.onDrop
                                      ))
                                    : this.attachDragAndDropEvent();
                            },
                        },
                        {
                            key: "attachDragAndDropEvent",
                            value: function () {
                                var t = this,
                                    e = i()(),
                                    n = this.$dropzone.find(
                                        ".note-dropzone-message"
                                    );
                                (this.documentEventHandlers.onDragenter =
                                    function (o) {
                                        var i = t.context.invoke(
                                                "codeview.isActivated"
                                            ),
                                            r =
                                                t.$editor.width() > 0 &&
                                                t.$editor.height() > 0;
                                        i ||
                                            e.length ||
                                            !r ||
                                            (t.$editor.addClass("dragover"),
                                            t.$dropzone.width(
                                                t.$editor.width()
                                            ),
                                            t.$dropzone.height(
                                                t.$editor.height()
                                            ),
                                            n.text(t.lang.image.dragImageHere)),
                                            (e = e.add(o.target));
                                    }),
                                    (this.documentEventHandlers.onDragleave =
                                        function (n) {
                                            ((e = e.not(n.target)).length &&
                                                "BODY" !== n.target.nodeName) ||
                                                ((e = i()()),
                                                t.$editor.removeClass(
                                                    "dragover"
                                                ));
                                        }),
                                    (this.documentEventHandlers.onDrop =
                                        function () {
                                            (e = i()()),
                                                t.$editor.removeClass(
                                                    "dragover"
                                                );
                                        }),
                                    this.$eventListener
                                        .on(
                                            "dragenter",
                                            this.documentEventHandlers
                                                .onDragenter
                                        )
                                        .on(
                                            "dragleave",
                                            this.documentEventHandlers
                                                .onDragleave
                                        )
                                        .on(
                                            "drop",
                                            this.documentEventHandlers.onDrop
                                        ),
                                    this.$dropzone
                                        .on("dragenter", function () {
                                            t.$dropzone.addClass("hover"),
                                                n.text(t.lang.image.dropImage);
                                        })
                                        .on("dragleave", function () {
                                            t.$dropzone.removeClass("hover"),
                                                n.text(
                                                    t.lang.image.dragImageHere
                                                );
                                        }),
                                    this.$dropzone
                                        .on("drop", function (e) {
                                            var n =
                                                e.originalEvent.dataTransfer;
                                            e.preventDefault(),
                                                n && n.files && n.files.length
                                                    ? (t.$editable.focus(),
                                                      t.context.invoke(
                                                          "editor.insertImagesOrCallback",
                                                          n.files
                                                      ))
                                                    : i.a.each(
                                                          n.types,
                                                          function (e, o) {
                                                              if (
                                                                  !(
                                                                      o
                                                                          .toLowerCase()
                                                                          .indexOf(
                                                                              "_moz_"
                                                                          ) > -1
                                                                  )
                                                              ) {
                                                                  var r =
                                                                      n.getData(
                                                                          o
                                                                      );
                                                                  o
                                                                      .toLowerCase()
                                                                      .indexOf(
                                                                          "text"
                                                                      ) > -1
                                                                      ? t.context.invoke(
                                                                            "editor.pasteHTML",
                                                                            r
                                                                        )
                                                                      : i()(
                                                                            r
                                                                        ).each(
                                                                            function (
                                                                                e,
                                                                                n
                                                                            ) {
                                                                                t.context.invoke(
                                                                                    "editor.insertNode",
                                                                                    n
                                                                                );
                                                                            }
                                                                        );
                                                              }
                                                          }
                                                      );
                                        })
                                        .on("dragover", !1);
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                var t = this;
                                Object.keys(this.documentEventHandlers).forEach(
                                    function (e) {
                                        t.$eventListener.off(
                                            e.substr(2).toLowerCase(),
                                            t.documentEventHandlers[e]
                                        );
                                    }
                                ),
                                    (this.documentEventHandlers = {});
                            },
                        },
                    ]) && Mt(e.prototype, n),
                    o && Mt(e, o),
                    t
                );
            })();

            function jt(t) {
                if (
                    "undefined" == typeof Symbol ||
                    null == t[Symbol.iterator]
                ) {
                    if (
                        Array.isArray(t) ||
                        (t = (function (t, e) {
                            if (!t) return;
                            if ("string" == typeof t) return Ut(t, e);
                            var n = Object.prototype.toString
                                .call(t)
                                .slice(8, -1);
                            "Object" === n &&
                                t.constructor &&
                                (n = t.constructor.name);
                            if ("Map" === n || "Set" === n)
                                return Array.from(n);
                            if (
                                "Arguments" === n ||
                                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(
                                    n
                                )
                            )
                                return Ut(t, e);
                        })(t))
                    ) {
                        var e = 0,
                            n = function () {};
                        return {
                            s: n,
                            n: function () {
                                return e >= t.length
                                    ? { done: !0 }
                                    : { done: !1, value: t[e++] };
                            },
                            e: function (t) {
                                throw t;
                            },
                            f: n,
                        };
                    }
                    throw new TypeError(
                        "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                    );
                }
                var o,
                    i,
                    r = !0,
                    a = !1;
                return {
                    s: function () {
                        o = t[Symbol.iterator]();
                    },
                    n: function () {
                        var t = o.next();
                        return (r = t.done), t;
                    },
                    e: function (t) {
                        (a = !0), (i = t);
                    },
                    f: function () {
                        try {
                            r || null == o.return || o.return();
                        } finally {
                            if (a) throw i;
                        }
                    },
                };
            }

            function Ut(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
                return o;
            }

            function Wt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Kt = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$editor = e.layoutInfo.editor),
                        (this.$editable = e.layoutInfo.editable),
                        (this.$codable = e.layoutInfo.codable),
                        (this.options = e.options),
                        (this.CodeMirrorConstructor = window.CodeMirror),
                        this.options.codemirror.CodeMirrorConstructor &&
                            (this.CodeMirrorConstructor =
                                this.options.codemirror.CodeMirrorConstructor);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "sync",
                            value: function (t) {
                                var e = this.isActivated(),
                                    n = this.CodeMirrorConstructor;
                                e &&
                                    (t
                                        ? n
                                            ? this.$codable
                                                  .data("cmEditor")
                                                  .getDoc()
                                                  .setValue(t)
                                            : this.$codable.val(t)
                                        : n &&
                                          this.$codable
                                              .data("cmEditor")
                                              .save());
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                this.$codable.on("keyup", function (e) {
                                    e.keyCode === xt.code.ESCAPE &&
                                        t.deactivate();
                                });
                            },
                        },
                        {
                            key: "isActivated",
                            value: function () {
                                return this.$editor.hasClass("codeview");
                            },
                        },
                        {
                            key: "toggle",
                            value: function () {
                                this.isActivated()
                                    ? this.deactivate()
                                    : this.activate(),
                                    this.context.triggerEvent(
                                        "codeview.toggled"
                                    );
                            },
                        },
                        {
                            key: "purify",
                            value: function (t) {
                                if (
                                    this.options.codeviewFilter &&
                                    ((t = t.replace(
                                        this.options.codeviewFilterRegex,
                                        ""
                                    )),
                                    this.options.codeviewIframeFilter)
                                ) {
                                    var e =
                                        this.options.codeviewIframeWhitelistSrc.concat(
                                            this.options
                                                .codeviewIframeWhitelistSrcBase
                                        );
                                    t = t.replace(
                                        /(<iframe.*?>.*?(?:<\/iframe>)?)/gi,
                                        function (t) {
                                            if (
                                                /<.+src(?==?('|"|\s)?)[\s\S]+src(?=('|"|\s)?)[^>]*?>/i.test(
                                                    t
                                                )
                                            )
                                                return "";
                                            var n,
                                                o = jt(e);
                                            try {
                                                for (
                                                    o.s();
                                                    !(n = o.n()).done;

                                                ) {
                                                    var i = n.value;
                                                    if (
                                                        new RegExp(
                                                            'src="(https?:)?//' +
                                                                i.replace(
                                                                    /[-\/\\^$*+?.()|[\]{}]/g,
                                                                    "\\$&"
                                                                ) +
                                                                '/(.+)"'
                                                        ).test(t)
                                                    )
                                                        return t;
                                                }
                                            } catch (t) {
                                                o.e(t);
                                            } finally {
                                                o.f();
                                            }
                                            return "";
                                        }
                                    );
                                }
                                return t;
                            },
                        },
                        {
                            key: "activate",
                            value: function () {
                                var t = this,
                                    e = this.CodeMirrorConstructor;
                                if (
                                    (this.$codable.val(
                                        pt.html(
                                            this.$editable,
                                            this.options.prettifyHtml
                                        )
                                    ),
                                    this.$codable.height(
                                        this.$editable.height()
                                    ),
                                    this.context.invoke(
                                        "toolbar.updateCodeview",
                                        !0
                                    ),
                                    this.context.invoke(
                                        "airPopover.updateCodeview",
                                        !0
                                    ),
                                    this.$editor.addClass("codeview"),
                                    this.$codable.focus(),
                                    e)
                                ) {
                                    var n = e.fromTextArea(
                                        this.$codable[0],
                                        this.options.codemirror
                                    );
                                    if (this.options.codemirror.tern) {
                                        var o = new e.TernServer(
                                            this.options.codemirror.tern
                                        );
                                        (n.ternServer = o),
                                            n.on(
                                                "cursorActivity",
                                                function (t) {
                                                    o.updateArgHints(t);
                                                }
                                            );
                                    }
                                    n.on("blur", function (e) {
                                        t.context.triggerEvent(
                                            "blur.codeview",
                                            n.getValue(),
                                            e
                                        );
                                    }),
                                        n.on("change", function () {
                                            t.context.triggerEvent(
                                                "change.codeview",
                                                n.getValue(),
                                                n
                                            );
                                        }),
                                        n.setSize(
                                            null,
                                            this.$editable.outerHeight()
                                        ),
                                        this.$codable.data("cmEditor", n);
                                } else
                                    this.$codable.on("blur", function (e) {
                                        t.context.triggerEvent(
                                            "blur.codeview",
                                            t.$codable.val(),
                                            e
                                        );
                                    }),
                                        this.$codable.on("input", function () {
                                            t.context.triggerEvent(
                                                "change.codeview",
                                                t.$codable.val(),
                                                t.$codable
                                            );
                                        });
                            },
                        },
                        {
                            key: "deactivate",
                            value: function () {
                                if (this.CodeMirrorConstructor) {
                                    var t = this.$codable.data("cmEditor");
                                    this.$codable.val(t.getValue()),
                                        t.toTextArea();
                                }
                                var e = this.purify(
                                        pt.value(
                                            this.$codable,
                                            this.options.prettifyHtml
                                        ) || pt.emptyPara
                                    ),
                                    n = this.$editable.html() !== e;
                                this.$editable.html(e),
                                    this.$editable.height(
                                        this.options.height
                                            ? this.$codable.height()
                                            : "auto"
                                    ),
                                    this.$editor.removeClass("codeview"),
                                    n &&
                                        this.context.triggerEvent(
                                            "change",
                                            this.$editable.html(),
                                            this.$editable
                                        ),
                                    this.$editable.focus(),
                                    this.context.invoke(
                                        "toolbar.updateCodeview",
                                        !1
                                    ),
                                    this.context.invoke(
                                        "airPopover.updateCodeview",
                                        !1
                                    );
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.isActivated() && this.deactivate();
                            },
                        },
                    ]) && Wt(e.prototype, n),
                    o && Wt(e, o),
                    t
                );
            })();

            function qt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Vt = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.$document = i()(document)),
                        (this.$statusbar = e.layoutInfo.statusbar),
                        (this.$editable = e.layoutInfo.editable),
                        (this.options = e.options);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                this.options.airMode ||
                                this.options.disableResizeEditor
                                    ? this.destroy()
                                    : this.$statusbar.on(
                                          "mousedown",
                                          function (e) {
                                              e.preventDefault(),
                                                  e.stopPropagation();
                                              var n =
                                                      t.$editable.offset().top -
                                                      t.$document.scrollTop(),
                                                  o = function (e) {
                                                      var o =
                                                          e.clientY - (n + 24);
                                                      (o =
                                                          t.options.minheight >
                                                          0
                                                              ? Math.max(
                                                                    o,
                                                                    t.options
                                                                        .minheight
                                                                )
                                                              : o),
                                                          (o =
                                                              t.options
                                                                  .maxHeight > 0
                                                                  ? Math.min(
                                                                        o,
                                                                        t
                                                                            .options
                                                                            .maxHeight
                                                                    )
                                                                  : o),
                                                          t.$editable.height(o);
                                                  };
                                              t.$document
                                                  .on("mousemove", o)
                                                  .one("mouseup", function () {
                                                      t.$document.off(
                                                          "mousemove",
                                                          o
                                                      );
                                                  });
                                          }
                                      );
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$statusbar.off(),
                                    this.$statusbar.addClass("locked");
                            },
                        },
                    ]) && qt(e.prototype, n),
                    o && qt(e, o),
                    t
                );
            })();

            function _t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Gt = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$editor = e.layoutInfo.editor),
                        (this.$toolbar = e.layoutInfo.toolbar),
                        (this.$editable = e.layoutInfo.editable),
                        (this.$codable = e.layoutInfo.codable),
                        (this.$window = i()(window)),
                        (this.$scrollbar = i()("html, body")),
                        (this.onResize = function () {
                            n.resizeTo({
                                h:
                                    n.$window.height() -
                                    n.$toolbar.outerHeight(),
                            });
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "resizeTo",
                            value: function (t) {
                                this.$editable.css("height", t.h),
                                    this.$codable.css("height", t.h),
                                    this.$codable.data("cmeditor") &&
                                        this.$codable
                                            .data("cmeditor")
                                            .setsize(null, t.h);
                            },
                        },
                        {
                            key: "toggle",
                            value: function () {
                                this.$editor.toggleClass("fullscreen"),
                                    this.isFullscreen()
                                        ? (this.$editable.data(
                                              "orgHeight",
                                              this.$editable.css("height")
                                          ),
                                          this.$editable.data(
                                              "orgMaxHeight",
                                              this.$editable.css("maxHeight")
                                          ),
                                          this.$editable.css("maxHeight", ""),
                                          this.$window
                                              .on("resize", this.onResize)
                                              .trigger("resize"),
                                          this.$scrollbar.css(
                                              "overflow",
                                              "hidden"
                                          ))
                                        : (this.$window.off(
                                              "resize",
                                              this.onResize
                                          ),
                                          this.resizeTo({
                                              h: this.$editable.data(
                                                  "orgHeight"
                                              ),
                                          }),
                                          this.$editable.css(
                                              "maxHeight",
                                              this.$editable.css("orgMaxHeight")
                                          ),
                                          this.$scrollbar.css(
                                              "overflow",
                                              "visible"
                                          )),
                                    this.context.invoke(
                                        "toolbar.updateFullscreen",
                                        this.isFullscreen()
                                    );
                            },
                        },
                        {
                            key: "isFullscreen",
                            value: function () {
                                return this.$editor.hasClass("fullscreen");
                            },
                        },
                    ]) && _t(e.prototype, n),
                    o && _t(e, o),
                    t
                );
            })();

            function Yt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Zt = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$document = i()(document)),
                        (this.$editingArea = e.layoutInfo.editingArea),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo),
                        (this.events = {
                            "summernote.mousedown": function (t, e) {
                                n.update(e.target, e) && e.preventDefault();
                            },
                            "summernote.keyup summernote.scroll summernote.change summernote.dialog.shown":
                                function () {
                                    n.update();
                                },
                            "summernote.disable summernote.blur": function () {
                                n.hide();
                            },
                            "summernote.codeview.toggled": function () {
                                n.update();
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                (this.$handle = i()(
                                    [
                                        '<div class="note-handle">',
                                        '<div class="note-control-selection">',
                                        '<div class="note-control-selection-bg"></div>',
                                        '<div class="note-control-holder note-control-nw"></div>',
                                        '<div class="note-control-holder note-control-ne"></div>',
                                        '<div class="note-control-holder note-control-sw"></div>',
                                        '<div class="',
                                        this.options.disableResizeImage
                                            ? "note-control-holder"
                                            : "note-control-sizing",
                                        ' note-control-se"></div>',
                                        this.options.disableResizeImage
                                            ? ""
                                            : '<div class="note-control-selection-info"></div>',
                                        "</div>",
                                        "</div>",
                                    ].join("")
                                ).prependTo(this.$editingArea)),
                                    this.$handle.on("mousedown", function (e) {
                                        if (pt.isControlSizing(e.target)) {
                                            e.preventDefault(),
                                                e.stopPropagation();
                                            var n = t.$handle
                                                    .find(
                                                        ".note-control-selection"
                                                    )
                                                    .data("target"),
                                                o = n.offset(),
                                                i = t.$document.scrollTop(),
                                                r = function (e) {
                                                    t.context.invoke(
                                                        "editor.resizeTo",
                                                        {
                                                            x:
                                                                e.clientX -
                                                                o.left,
                                                            y:
                                                                e.clientY -
                                                                (o.top - i),
                                                        },
                                                        n,
                                                        !e.shiftKey
                                                    ),
                                                        t.update(n[0], e);
                                                };
                                            t.$document
                                                .on("mousemove", r)
                                                .one("mouseup", function (e) {
                                                    e.preventDefault(),
                                                        t.$document.off(
                                                            "mousemove",
                                                            r
                                                        ),
                                                        t.context.invoke(
                                                            "editor.afterCommand"
                                                        );
                                                }),
                                                n.data("ratio") ||
                                                    n.data(
                                                        "ratio",
                                                        n.height() / n.width()
                                                    );
                                        }
                                    }),
                                    this.$handle.on("wheel", function (e) {
                                        e.preventDefault(), t.update();
                                    });
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$handle.remove();
                            },
                        },
                        {
                            key: "update",
                            value: function (t, e) {
                                if (this.context.isDisabled()) return !1;
                                var n = pt.isImg(t),
                                    o = this.$handle.find(
                                        ".note-control-selection"
                                    );
                                if (
                                    (this.context.invoke(
                                        "imagePopover.update",
                                        t,
                                        e
                                    ),
                                    n)
                                ) {
                                    var r = i()(t),
                                        a = r.position(),
                                        s = {
                                            left:
                                                a.left +
                                                parseInt(
                                                    r.css("marginLeft"),
                                                    10
                                                ),
                                            top:
                                                a.top +
                                                parseInt(
                                                    r.css("marginTop"),
                                                    10
                                                ),
                                        },
                                        l = {
                                            w: r.outerWidth(!1),
                                            h: r.outerHeight(!1),
                                        };
                                    o.css({
                                        display: "block",
                                        left: s.left,
                                        top: s.top,
                                        width: l.w,
                                        height: l.h,
                                    }).data("target", r);
                                    var c = new Image();
                                    c.src = r.attr("src");
                                    var u =
                                        l.w +
                                        "x" +
                                        l.h +
                                        " (" +
                                        this.lang.image.original +
                                        ": " +
                                        c.width +
                                        "x" +
                                        c.height +
                                        ")";
                                    o
                                        .find(".note-control-selection-info")
                                        .text(u),
                                        this.context.invoke(
                                            "editor.saveTarget",
                                            t
                                        );
                                } else this.hide();
                                return n;
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                this.context.invoke("editor.clearTarget"),
                                    this.$handle.children().hide();
                            },
                        },
                    ]) && Yt(e.prototype, n),
                    o && Yt(e, o),
                    t
                );
            })();

            function Xt(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Qt =
                    /^([A-Za-z][A-Za-z0-9+-.]*\:[\/]{2}|tel:|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i,
                Jt = (function () {
                    function t(e) {
                        var n = this;
                        !(function (t, e) {
                            if (!(t instanceof e))
                                throw new TypeError(
                                    "Cannot call a class as a function"
                                );
                        })(this, t),
                            (this.context = e),
                            (this.options = e.options),
                            (this.events = {
                                "summernote.keyup": function (t, e) {
                                    e.isDefaultPrevented() || n.handleKeyup(e);
                                },
                                "summernote.keydown": function (t, e) {
                                    n.handleKeydown(e);
                                },
                            });
                    }

                    var e, n, o;
                    return (
                        (e = t),
                        (n = [
                            {
                                key: "initialize",
                                value: function () {
                                    this.lastWordRange = null;
                                },
                            },
                            {
                                key: "destroy",
                                value: function () {
                                    this.lastWordRange = null;
                                },
                            },
                            {
                                key: "replace",
                                value: function () {
                                    if (this.lastWordRange) {
                                        var t = this.lastWordRange.toString(),
                                            e = t.match(Qt);
                                        if (e && (e[1] || e[2])) {
                                            var n = e[1] ? t : "http://" + t,
                                                o = this.options
                                                    .showDomainOnlyForAutolink
                                                    ? t
                                                          .replace(
                                                              /^(?:https?:\/\/)?(?:tel?:?)?(?:mailto?:?)?(?:www\.)?/i,
                                                              ""
                                                          )
                                                          .split("/")[0]
                                                    : t,
                                                r = i()("<a />")
                                                    .html(o)
                                                    .attr("href", n)[0];
                                            this.context.options
                                                .linkTargetBlank &&
                                                i()(r).attr("target", "_blank"),
                                                this.lastWordRange.insertNode(
                                                    r
                                                ),
                                                (this.lastWordRange = null),
                                                this.context.invoke(
                                                    "editor.focus"
                                                );
                                        }
                                    }
                                },
                            },
                            {
                                key: "handleKeydown",
                                value: function (t) {
                                    if (
                                        C.contains(
                                            [xt.code.ENTER, xt.code.SPACE],
                                            t.keyCode
                                        )
                                    ) {
                                        var e = this.context
                                            .invoke("editor.createRange")
                                            .getWordRange();
                                        this.lastWordRange = e;
                                    }
                                },
                            },
                            {
                                key: "handleKeyup",
                                value: function (t) {
                                    C.contains(
                                        [xt.code.ENTER, xt.code.SPACE],
                                        t.keyCode
                                    ) && this.replace();
                                },
                            },
                        ]) && Xt(e.prototype, n),
                        o && Xt(e, o),
                        t
                    );
                })();

            function te(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var ee = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.$note = e.layoutInfo.note),
                        (this.events = {
                            "summernote.change": function () {
                                n.$note.val(e.invoke("code"));
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return pt.isTextarea(this.$note[0]);
                            },
                        },
                    ]) && te(e.prototype, n),
                    o && te(e, o),
                    t
                );
            })();

            function ne(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var oe = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.options = e.options.replace || {}),
                        (this.keys = [
                            xt.code.ENTER,
                            xt.code.SPACE,
                            xt.code.PERIOD,
                            xt.code.COMMA,
                            xt.code.SEMICOLON,
                            xt.code.SLASH,
                        ]),
                        (this.previousKeydownCode = null),
                        (this.events = {
                            "summernote.keyup": function (t, e) {
                                e.isDefaultPrevented() || n.handleKeyup(e);
                            },
                            "summernote.keydown": function (t, e) {
                                n.handleKeydown(e);
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return !!this.options.match;
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                this.lastWord = null;
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.lastWord = null;
                            },
                        },
                        {
                            key: "replace",
                            value: function () {
                                if (this.lastWord) {
                                    var t = this,
                                        e = this.lastWord.toString();
                                    this.options.match(e, function (e) {
                                        if (e) {
                                            var n = "";
                                            if (
                                                ("string" == typeof e
                                                    ? (n = pt.createText(e))
                                                    : e instanceof jQuery
                                                    ? (n = e[0])
                                                    : e instanceof Node &&
                                                      (n = e),
                                                !n)
                                            )
                                                return;
                                            t.lastWord.insertNode(n),
                                                (t.lastWord = null),
                                                t.context.invoke(
                                                    "editor.focus"
                                                );
                                        }
                                    });
                                }
                            },
                        },
                        {
                            key: "handleKeydown",
                            value: function (t) {
                                if (
                                    this.previousKeydownCode &&
                                    C.contains(
                                        this.keys,
                                        this.previousKeydownCode
                                    )
                                )
                                    this.previousKeydownCode = t.keyCode;
                                else {
                                    if (C.contains(this.keys, t.keyCode)) {
                                        var e = this.context
                                            .invoke("editor.createRange")
                                            .getWordRange();
                                        this.lastWord = e;
                                    }
                                    this.previousKeydownCode = t.keyCode;
                                }
                            },
                        },
                        {
                            key: "handleKeyup",
                            value: function (t) {
                                C.contains(this.keys, t.keyCode) &&
                                    this.replace();
                            },
                        },
                    ]) && ne(e.prototype, n),
                    o && ne(e, o),
                    t
                );
            })();

            function ie(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var re = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$editingArea = e.layoutInfo.editingArea),
                        (this.options = e.options),
                        !0 === this.options.inheritPlaceholder &&
                            (this.options.placeholder =
                                this.context.$note.attr("placeholder") ||
                                this.options.placeholder),
                        (this.events = {
                            "summernote.init summernote.change": function () {
                                n.update();
                            },
                            "summernote.codeview.toggled": function () {
                                n.update();
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return !!this.options.placeholder;
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                (this.$placeholder = i()(
                                    '<div class="note-placeholder">'
                                )),
                                    this.$placeholder
                                        .on("click", function () {
                                            t.context.invoke("focus");
                                        })
                                        .html(this.options.placeholder)
                                        .prependTo(this.$editingArea),
                                    this.update();
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$placeholder.remove();
                            },
                        },
                        {
                            key: "update",
                            value: function () {
                                var t =
                                    !this.context.invoke(
                                        "codeview.isActivated"
                                    ) && this.context.invoke("editor.isEmpty");
                                this.$placeholder.toggle(t);
                            },
                        },
                    ]) && ie(e.prototype, n),
                    o && ie(e, o),
                    t
                );
            })();

            function ae(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var se = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.ui = i.a.summernote.ui),
                        (this.context = e),
                        (this.$toolbar = e.layoutInfo.toolbar),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo),
                        (this.invertedKeyMap = g.invertObject(
                            this.options.keyMap[m.isMac ? "mac" : "pc"]
                        ));
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "representShortcut",
                            value: function (t) {
                                var e = this.invertedKeyMap[t];
                                return this.options.shortcuts && e
                                    ? (m.isMac &&
                                          (e = e
                                              .replace("CMD", "⌘")
                                              .replace("SHIFT", "⇧")),
                                      " (" +
                                          (e = e
                                              .replace("BACKSLASH", "\\")
                                              .replace("SLASH", "/")
                                              .replace("LEFTBRACKET", "[")
                                              .replace("RIGHTBRACKET", "]")) +
                                          ")")
                                    : "";
                            },
                        },
                        {
                            key: "button",
                            value: function (t) {
                                return (
                                    !this.options.tooltip &&
                                        t.tooltip &&
                                        delete t.tooltip,
                                    (t.container = this.options.container),
                                    this.ui.button(t)
                                );
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                this.addToolbarButtons(),
                                    this.addImagePopoverButtons(),
                                    this.addLinkPopoverButtons(),
                                    this.addTablePopoverButtons(),
                                    (this.fontInstalledMap = {});
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                delete this.fontInstalledMap;
                            },
                        },
                        {
                            key: "isFontInstalled",
                            value: function (t) {
                                return (
                                    Object.prototype.hasOwnProperty.call(
                                        this.fontInstalledMap,
                                        t
                                    ) ||
                                        (this.fontInstalledMap[t] =
                                            m.isFontInstalled(t) ||
                                            C.contains(
                                                this.options
                                                    .fontNamesIgnoreCheck,
                                                t
                                            )),
                                    this.fontInstalledMap[t]
                                );
                            },
                        },
                        {
                            key: "isFontDeservedToAdd",
                            value: function (t) {
                                return (
                                    "" !== (t = t.toLowerCase()) &&
                                    this.isFontInstalled(t) &&
                                    -1 === m.genericFontFamilies.indexOf(t)
                                );
                            },
                        },
                        {
                            key: "colorPalette",
                            value: function (t, e, n, o) {
                                var r = this;
                                return this.ui
                                    .buttonGroup({
                                        className: "note-color " + t,
                                        children: [
                                            this.button({
                                                className:
                                                    "note-current-color-button",
                                                contents: this.ui.icon(
                                                    this.options.icons.font +
                                                        " note-recent-color"
                                                ),
                                                tooltip: e,
                                                click: function (t) {
                                                    var e = i()(
                                                        t.currentTarget
                                                    );
                                                    n && o
                                                        ? r.context.invoke(
                                                              "editor.color",
                                                              {
                                                                  backColor:
                                                                      e.attr(
                                                                          "data-backColor"
                                                                      ),
                                                                  foreColor:
                                                                      e.attr(
                                                                          "data-foreColor"
                                                                      ),
                                                              }
                                                          )
                                                        : n
                                                        ? r.context.invoke(
                                                              "editor.color",
                                                              {
                                                                  backColor:
                                                                      e.attr(
                                                                          "data-backColor"
                                                                      ),
                                                              }
                                                          )
                                                        : o &&
                                                          r.context.invoke(
                                                              "editor.color",
                                                              {
                                                                  foreColor:
                                                                      e.attr(
                                                                          "data-foreColor"
                                                                      ),
                                                              }
                                                          );
                                                },
                                                callback: function (t) {
                                                    var e =
                                                        t.find(
                                                            ".note-recent-color"
                                                        );
                                                    n &&
                                                        (e.css(
                                                            "background-color",
                                                            r.options
                                                                .colorButton
                                                                .backColor
                                                        ),
                                                        t.attr(
                                                            "data-backColor",
                                                            r.options
                                                                .colorButton
                                                                .backColor
                                                        )),
                                                        o
                                                            ? (e.css(
                                                                  "color",
                                                                  r.options
                                                                      .colorButton
                                                                      .foreColor
                                                              ),
                                                              t.attr(
                                                                  "data-foreColor",
                                                                  r.options
                                                                      .colorButton
                                                                      .foreColor
                                                              ))
                                                            : e.css(
                                                                  "color",
                                                                  "transparent"
                                                              );
                                                },
                                            }),
                                            this.button({
                                                className: "dropdown-toggle",
                                                contents:
                                                    this.ui.dropdownButtonContents(
                                                        "",
                                                        this.options
                                                    ),
                                                tooltip: this.lang.color.more,
                                                data: { toggle: "dropdown" },
                                            }),
                                            this.ui.dropdown({
                                                items:
                                                    (n
                                                        ? [
                                                              '<div class="note-palette">',
                                                              '<div class="note-palette-title">' +
                                                                  this.lang
                                                                      .color
                                                                      .background +
                                                                  "</div>",
                                                              "<div>",
                                                              '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="backColor" data-value="transparent">',
                                                              this.lang.color
                                                                  .transparent,
                                                              "</button>",
                                                              "</div>",
                                                              '<div class="note-holder" data-event="backColor">\x3c!-- back colors --\x3e</div>',
                                                              "<div>",
                                                              '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="backColorPicker">',
                                                              this.lang.color
                                                                  .cpSelect,
                                                              "</button>",
                                                              '<input type="color" id="backColorPicker" class="note-btn note-color-select-btn" value="' +
                                                                  this.options
                                                                      .colorButton
                                                                      .backColor +
                                                                  '" data-event="backColorPalette">',
                                                              "</div>",
                                                              '<div class="note-holder-custom" id="backColorPalette" data-event="backColor"></div>',
                                                              "</div>",
                                                          ].join("")
                                                        : "") +
                                                    (o
                                                        ? [
                                                              '<div class="note-palette">',
                                                              '<div class="note-palette-title">' +
                                                                  this.lang
                                                                      .color
                                                                      .foreground +
                                                                  "</div>",
                                                              "<div>",
                                                              '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="removeFormat" data-value="foreColor">',
                                                              this.lang.color
                                                                  .resetToDefault,
                                                              "</button>",
                                                              "</div>",
                                                              '<div class="note-holder" data-event="foreColor">\x3c!-- fore colors --\x3e</div>',
                                                              "<div>",
                                                              '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="foreColorPicker">',
                                                              this.lang.color
                                                                  .cpSelect,
                                                              "</button>",
                                                              '<input type="color" id="foreColorPicker" class="note-btn note-color-select-btn" value="' +
                                                                  this.options
                                                                      .colorButton
                                                                      .foreColor +
                                                                  '" data-event="foreColorPalette">',
                                                              "</div>",
                                                              '<div class="note-holder-custom" id="foreColorPalette" data-event="foreColor"></div>',
                                                              "</div>",
                                                          ].join("")
                                                        : ""),
                                                callback: function (t) {
                                                    t.find(".note-holder").each(
                                                        function (t, e) {
                                                            var n = i()(e);
                                                            n.append(
                                                                r.ui
                                                                    .palette({
                                                                        colors: r
                                                                            .options
                                                                            .colors,
                                                                        colorsName:
                                                                            r
                                                                                .options
                                                                                .colorsName,
                                                                        eventName:
                                                                            n.data(
                                                                                "event"
                                                                            ),
                                                                        container:
                                                                            r
                                                                                .options
                                                                                .container,
                                                                        tooltip:
                                                                            r
                                                                                .options
                                                                                .tooltip,
                                                                    })
                                                                    .render()
                                                            );
                                                        }
                                                    );
                                                    var e = [
                                                        [
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                            "#FFFFFF",
                                                        ],
                                                    ];
                                                    t
                                                        .find(
                                                            ".note-holder-custom"
                                                        )
                                                        .each(function (t, n) {
                                                            var o = i()(n);
                                                            o.append(
                                                                r.ui
                                                                    .palette({
                                                                        colors: e,
                                                                        colorsName:
                                                                            e,
                                                                        eventName:
                                                                            o.data(
                                                                                "event"
                                                                            ),
                                                                        container:
                                                                            r
                                                                                .options
                                                                                .container,
                                                                        tooltip:
                                                                            r
                                                                                .options
                                                                                .tooltip,
                                                                    })
                                                                    .render()
                                                            );
                                                        }),
                                                        t
                                                            .find(
                                                                "input[type=color]"
                                                            )
                                                            .each(function (
                                                                e,
                                                                n
                                                            ) {
                                                                i()(n).change(
                                                                    function () {
                                                                        var e =
                                                                                t
                                                                                    .find(
                                                                                        "#" +
                                                                                            i()(
                                                                                                this
                                                                                            ).data(
                                                                                                "event"
                                                                                            )
                                                                                    )
                                                                                    .find(
                                                                                        ".note-color-btn"
                                                                                    )
                                                                                    .first(),
                                                                            n =
                                                                                this.value.toUpperCase();
                                                                        e
                                                                            .css(
                                                                                "background-color",
                                                                                n
                                                                            )
                                                                            .attr(
                                                                                "aria-label",
                                                                                n
                                                                            )
                                                                            .attr(
                                                                                "data-value",
                                                                                n
                                                                            )
                                                                            .attr(
                                                                                "data-original-title",
                                                                                n
                                                                            ),
                                                                            e.click();
                                                                    }
                                                                );
                                                            });
                                                },
                                                click: function (e) {
                                                    e.stopPropagation();
                                                    var n = i()("." + t).find(
                                                            ".note-dropdown-menu"
                                                        ),
                                                        o = i()(e.target),
                                                        a = o.data("event"),
                                                        s =
                                                            o.attr(
                                                                "data-value"
                                                            );
                                                    if ("openPalette" === a) {
                                                        var l = n.find("#" + s),
                                                            c = i()(
                                                                n
                                                                    .find(
                                                                        "#" +
                                                                            l.data(
                                                                                "event"
                                                                            )
                                                                    )
                                                                    .find(
                                                                        ".note-color-row"
                                                                    )[0]
                                                            ),
                                                            u = c
                                                                .find(
                                                                    ".note-color-btn"
                                                                )
                                                                .last()
                                                                .detach(),
                                                            d = l.val();
                                                        u
                                                            .css(
                                                                "background-color",
                                                                d
                                                            )
                                                            .attr(
                                                                "aria-label",
                                                                d
                                                            )
                                                            .attr(
                                                                "data-value",
                                                                d
                                                            )
                                                            .attr(
                                                                "data-original-title",
                                                                d
                                                            ),
                                                            c.prepend(u),
                                                            l.click();
                                                    } else {
                                                        if (
                                                            C.contains(
                                                                [
                                                                    "backColor",
                                                                    "foreColor",
                                                                ],
                                                                a
                                                            )
                                                        ) {
                                                            var h =
                                                                    "backColor" ===
                                                                    a
                                                                        ? "background-color"
                                                                        : "color",
                                                                f = o
                                                                    .closest(
                                                                        ".note-color"
                                                                    )
                                                                    .find(
                                                                        ".note-recent-color"
                                                                    ),
                                                                p = o
                                                                    .closest(
                                                                        ".note-color"
                                                                    )
                                                                    .find(
                                                                        ".note-current-color-button"
                                                                    );
                                                            f.css(h, s),
                                                                p.attr(
                                                                    "data-" + a,
                                                                    s
                                                                );
                                                        }
                                                        r.context.invoke(
                                                            "editor." + a,
                                                            s
                                                        );
                                                    }
                                                },
                                            }),
                                        ],
                                    })
                                    .render();
                            },
                        },
                        {
                            key: "addToolbarButtons",
                            value: function () {
                                var t = this;
                                this.context.memo("button.style", function () {
                                    return t.ui
                                        .buttonGroup([
                                            t.button({
                                                className: "dropdown-toggle",
                                                contents:
                                                    t.ui.dropdownButtonContents(
                                                        t.ui.icon(
                                                            t.options.icons
                                                                .magic
                                                        ),
                                                        t.options
                                                    ),
                                                tooltip: t.lang.style.style,
                                                data: { toggle: "dropdown" },
                                            }),
                                            t.ui.dropdown({
                                                className: "dropdown-style",
                                                items: t.options.styleTags,
                                                title: t.lang.style.style,
                                                template: function (e) {
                                                    "string" == typeof e &&
                                                        (e = {
                                                            tag: e,
                                                            title: Object.prototype.hasOwnProperty.call(
                                                                t.lang.style,
                                                                e
                                                            )
                                                                ? t.lang.style[
                                                                      e
                                                                  ]
                                                                : e,
                                                        });
                                                    var n = e.tag,
                                                        o = e.title;
                                                    return (
                                                        "<" +
                                                        n +
                                                        (e.style
                                                            ? ' style="' +
                                                              e.style +
                                                              '" '
                                                            : "") +
                                                        (e.className
                                                            ? ' class="' +
                                                              e.className +
                                                              '"'
                                                            : "") +
                                                        ">" +
                                                        o +
                                                        "</" +
                                                        n +
                                                        ">"
                                                    );
                                                },
                                                click: t.context.createInvokeHandler(
                                                    "editor.formatBlock"
                                                ),
                                            }),
                                        ])
                                        .render();
                                });
                                for (
                                    var e = function (e, n) {
                                            var o = t.options.styleTags[e];
                                            t.context.memo(
                                                "button.style." + o,
                                                function () {
                                                    return t
                                                        .button({
                                                            className:
                                                                "note-btn-style-" +
                                                                o,
                                                            contents:
                                                                '<div data-value="' +
                                                                o +
                                                                '">' +
                                                                o.toUpperCase() +
                                                                "</div>",
                                                            tooltip:
                                                                t.lang.style[o],
                                                            click: t.context.createInvokeHandler(
                                                                "editor.formatBlock"
                                                            ),
                                                        })
                                                        .render();
                                                }
                                            );
                                        },
                                        n = 0,
                                        o = this.options.styleTags.length;
                                    n < o;
                                    n++
                                )
                                    e(n);
                                this.context.memo("button.bold", function () {
                                    return t
                                        .button({
                                            className: "note-btn-bold",
                                            contents: t.ui.icon(
                                                t.options.icons.bold
                                            ),
                                            tooltip:
                                                t.lang.font.bold +
                                                t.representShortcut("bold"),
                                            click: t.context.createInvokeHandlerAndUpdateState(
                                                "editor.bold"
                                            ),
                                        })
                                        .render();
                                }),
                                    this.context.memo(
                                        "button.italic",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "note-btn-italic",
                                                    contents: t.ui.icon(
                                                        t.options.icons.italic
                                                    ),
                                                    tooltip:
                                                        t.lang.font.italic +
                                                        t.representShortcut(
                                                            "italic"
                                                        ),
                                                    click: t.context.createInvokeHandlerAndUpdateState(
                                                        "editor.italic"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.underline",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "note-btn-underline",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .underline
                                                    ),
                                                    tooltip:
                                                        t.lang.font.underline +
                                                        t.representShortcut(
                                                            "underline"
                                                        ),
                                                    click: t.context.createInvokeHandlerAndUpdateState(
                                                        "editor.underline"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.clear",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.eraser
                                                    ),
                                                    tooltip:
                                                        t.lang.font.clear +
                                                        t.representShortcut(
                                                            "removeFormat"
                                                        ),
                                                    click: t.context.createInvokeHandler(
                                                        "editor.removeFormat"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.strikethrough",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "note-btn-strikethrough",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .strikethrough
                                                    ),
                                                    tooltip:
                                                        t.lang.font
                                                            .strikethrough +
                                                        t.representShortcut(
                                                            "strikethrough"
                                                        ),
                                                    click: t.context.createInvokeHandlerAndUpdateState(
                                                        "editor.strikethrough"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.superscript",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "note-btn-superscript",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .superscript
                                                    ),
                                                    tooltip:
                                                        t.lang.font.superscript,
                                                    click: t.context.createInvokeHandlerAndUpdateState(
                                                        "editor.superscript"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.subscript",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "note-btn-subscript",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .subscript
                                                    ),
                                                    tooltip:
                                                        t.lang.font.subscript,
                                                    click: t.context.createInvokeHandlerAndUpdateState(
                                                        "editor.subscript"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.fontname",
                                        function () {
                                            var e = t.context.invoke(
                                                "editor.currentStyle"
                                            );
                                            return (
                                                t.options.addDefaultFonts &&
                                                    i.a.each(
                                                        e["font-family"].split(
                                                            ","
                                                        ),
                                                        function (e, n) {
                                                            (n = n
                                                                .trim()
                                                                .replace(
                                                                    /['"]+/g,
                                                                    ""
                                                                )),
                                                                t.isFontDeservedToAdd(
                                                                    n
                                                                ) &&
                                                                    -1 ===
                                                                        t.options.fontNames.indexOf(
                                                                            n
                                                                        ) &&
                                                                    t.options.fontNames.push(
                                                                        n
                                                                    );
                                                        }
                                                    ),
                                                t.ui
                                                    .buttonGroup([
                                                        t.button({
                                                            className:
                                                                "dropdown-toggle",
                                                            contents:
                                                                t.ui.dropdownButtonContents(
                                                                    '<span class="note-current-fontname"></span>',
                                                                    t.options
                                                                ),
                                                            tooltip:
                                                                t.lang.font
                                                                    .name,
                                                            data: {
                                                                toggle: "dropdown",
                                                            },
                                                        }),
                                                        t.ui.dropdownCheck({
                                                            className:
                                                                "dropdown-fontname",
                                                            checkClassName:
                                                                t.options.icons
                                                                    .menuCheck,
                                                            items: t.options.fontNames.filter(
                                                                t.isFontInstalled.bind(
                                                                    t
                                                                )
                                                            ),
                                                            title: t.lang.font
                                                                .name,
                                                            template: function (
                                                                t
                                                            ) {
                                                                return (
                                                                    '<span style="font-family: ' +
                                                                    m.validFontName(
                                                                        t
                                                                    ) +
                                                                    '">' +
                                                                    t +
                                                                    "</span>"
                                                                );
                                                            },
                                                            click: t.context.createInvokeHandlerAndUpdateState(
                                                                "editor.fontName"
                                                            ),
                                                        }),
                                                    ])
                                                    .render()
                                            );
                                        }
                                    ),
                                    this.context.memo(
                                        "button.fontsize",
                                        function () {
                                            return t.ui
                                                .buttonGroup([
                                                    t.button({
                                                        className:
                                                            "dropdown-toggle",
                                                        contents:
                                                            t.ui.dropdownButtonContents(
                                                                '<span class="note-current-fontsize"></span>',
                                                                t.options
                                                            ),
                                                        tooltip:
                                                            t.lang.font.size,
                                                        data: {
                                                            toggle: "dropdown",
                                                        },
                                                    }),
                                                    t.ui.dropdownCheck({
                                                        className:
                                                            "dropdown-fontsize",
                                                        checkClassName:
                                                            t.options.icons
                                                                .menuCheck,
                                                        items: t.options
                                                            .fontSizes,
                                                        title: t.lang.font.size,
                                                        click: t.context.createInvokeHandlerAndUpdateState(
                                                            "editor.fontSize"
                                                        ),
                                                    }),
                                                ])
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.fontsizeunit",
                                        function () {
                                            return t.ui
                                                .buttonGroup([
                                                    t.button({
                                                        className:
                                                            "dropdown-toggle",
                                                        contents:
                                                            t.ui.dropdownButtonContents(
                                                                '<span class="note-current-fontsizeunit"></span>',
                                                                t.options
                                                            ),
                                                        tooltip:
                                                            t.lang.font
                                                                .sizeunit,
                                                        data: {
                                                            toggle: "dropdown",
                                                        },
                                                    }),
                                                    t.ui.dropdownCheck({
                                                        className:
                                                            "dropdown-fontsizeunit",
                                                        checkClassName:
                                                            t.options.icons
                                                                .menuCheck,
                                                        items: t.options
                                                            .fontSizeUnits,
                                                        title: t.lang.font
                                                            .sizeunit,
                                                        click: t.context.createInvokeHandlerAndUpdateState(
                                                            "editor.fontSizeUnit"
                                                        ),
                                                    }),
                                                ])
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.color",
                                        function () {
                                            return t.colorPalette(
                                                "note-color-all",
                                                t.lang.color.recent,
                                                !0,
                                                !0
                                            );
                                        }
                                    ),
                                    this.context.memo(
                                        "button.forecolor",
                                        function () {
                                            return t.colorPalette(
                                                "note-color-fore",
                                                t.lang.color.foreground,
                                                !1,
                                                !0
                                            );
                                        }
                                    ),
                                    this.context.memo(
                                        "button.backcolor",
                                        function () {
                                            return t.colorPalette(
                                                "note-color-back",
                                                t.lang.color.background,
                                                !0,
                                                !1
                                            );
                                        }
                                    ),
                                    this.context.memo("button.ul", function () {
                                        return t
                                            .button({
                                                contents: t.ui.icon(
                                                    t.options.icons
                                                        .unorderedlist
                                                ),
                                                tooltip:
                                                    t.lang.lists.unordered +
                                                    t.representShortcut(
                                                        "insertUnorderedList"
                                                    ),
                                                click: t.context.createInvokeHandler(
                                                    "editor.insertUnorderedList"
                                                ),
                                            })
                                            .render();
                                    }),
                                    this.context.memo("button.ol", function () {
                                        return t
                                            .button({
                                                contents: t.ui.icon(
                                                    t.options.icons.orderedlist
                                                ),
                                                tooltip:
                                                    t.lang.lists.ordered +
                                                    t.representShortcut(
                                                        "insertOrderedList"
                                                    ),
                                                click: t.context.createInvokeHandler(
                                                    "editor.insertOrderedList"
                                                ),
                                            })
                                            .render();
                                    });
                                var r = this.button({
                                        contents: this.ui.icon(
                                            this.options.icons.alignLeft
                                        ),
                                        tooltip:
                                            this.lang.paragraph.left +
                                            this.representShortcut(
                                                "justifyLeft"
                                            ),
                                        click: this.context.createInvokeHandler(
                                            "editor.justifyLeft"
                                        ),
                                    }),
                                    a = this.button({
                                        contents: this.ui.icon(
                                            this.options.icons.alignCenter
                                        ),
                                        tooltip:
                                            this.lang.paragraph.center +
                                            this.representShortcut(
                                                "justifyCenter"
                                            ),
                                        click: this.context.createInvokeHandler(
                                            "editor.justifyCenter"
                                        ),
                                    }),
                                    s = this.button({
                                        contents: this.ui.icon(
                                            this.options.icons.alignRight
                                        ),
                                        tooltip:
                                            this.lang.paragraph.right +
                                            this.representShortcut(
                                                "justifyRight"
                                            ),
                                        click: this.context.createInvokeHandler(
                                            "editor.justifyRight"
                                        ),
                                    }),
                                    l = this.button({
                                        contents: this.ui.icon(
                                            this.options.icons.alignJustify
                                        ),
                                        tooltip:
                                            this.lang.paragraph.justify +
                                            this.representShortcut(
                                                "justifyFull"
                                            ),
                                        click: this.context.createInvokeHandler(
                                            "editor.justifyFull"
                                        ),
                                    }),
                                    c = this.button({
                                        contents: this.ui.icon(
                                            this.options.icons.outdent
                                        ),
                                        tooltip:
                                            this.lang.paragraph.outdent +
                                            this.representShortcut("outdent"),
                                        click: this.context.createInvokeHandler(
                                            "editor.outdent"
                                        ),
                                    }),
                                    u = this.button({
                                        contents: this.ui.icon(
                                            this.options.icons.indent
                                        ),
                                        tooltip:
                                            this.lang.paragraph.indent +
                                            this.representShortcut("indent"),
                                        click: this.context.createInvokeHandler(
                                            "editor.indent"
                                        ),
                                    });
                                this.context.memo(
                                    "button.justifyLeft",
                                    g.invoke(r, "render")
                                ),
                                    this.context.memo(
                                        "button.justifyCenter",
                                        g.invoke(a, "render")
                                    ),
                                    this.context.memo(
                                        "button.justifyRight",
                                        g.invoke(s, "render")
                                    ),
                                    this.context.memo(
                                        "button.justifyFull",
                                        g.invoke(l, "render")
                                    ),
                                    this.context.memo(
                                        "button.outdent",
                                        g.invoke(c, "render")
                                    ),
                                    this.context.memo(
                                        "button.indent",
                                        g.invoke(u, "render")
                                    ),
                                    this.context.memo(
                                        "button.paragraph",
                                        function () {
                                            return t.ui
                                                .buttonGroup([
                                                    t.button({
                                                        className:
                                                            "dropdown-toggle",
                                                        contents:
                                                            t.ui.dropdownButtonContents(
                                                                t.ui.icon(
                                                                    t.options
                                                                        .icons
                                                                        .alignLeft
                                                                ),
                                                                t.options
                                                            ),
                                                        tooltip:
                                                            t.lang.paragraph
                                                                .paragraph,
                                                        data: {
                                                            toggle: "dropdown",
                                                        },
                                                    }),
                                                    t.ui.dropdown([
                                                        t.ui.buttonGroup({
                                                            className:
                                                                "note-align",
                                                            children: [
                                                                r,
                                                                a,
                                                                s,
                                                                l,
                                                            ],
                                                        }),
                                                        t.ui.buttonGroup({
                                                            className:
                                                                "note-list",
                                                            children: [c, u],
                                                        }),
                                                    ]),
                                                ])
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.height",
                                        function () {
                                            return t.ui
                                                .buttonGroup([
                                                    t.button({
                                                        className:
                                                            "dropdown-toggle",
                                                        contents:
                                                            t.ui.dropdownButtonContents(
                                                                t.ui.icon(
                                                                    t.options
                                                                        .icons
                                                                        .textHeight
                                                                ),
                                                                t.options
                                                            ),
                                                        tooltip:
                                                            t.lang.font.height,
                                                        data: {
                                                            toggle: "dropdown",
                                                        },
                                                    }),
                                                    t.ui.dropdownCheck({
                                                        items: t.options
                                                            .lineHeights,
                                                        checkClassName:
                                                            t.options.icons
                                                                .menuCheck,
                                                        className:
                                                            "dropdown-line-height",
                                                        title: t.lang.font
                                                            .height,
                                                        click: t.context.createInvokeHandler(
                                                            "editor.lineHeight"
                                                        ),
                                                    }),
                                                ])
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.table",
                                        function () {
                                            return t.ui
                                                .buttonGroup(
                                                    [
                                                        t.button({
                                                            className:
                                                                "dropdown-toggle",
                                                            contents:
                                                                t.ui.dropdownButtonContents(
                                                                    t.ui.icon(
                                                                        t
                                                                            .options
                                                                            .icons
                                                                            .table
                                                                    ),
                                                                    t.options
                                                                ),
                                                            tooltip:
                                                                t.lang.table
                                                                    .table,
                                                            data: {
                                                                toggle: "dropdown",
                                                            },
                                                        }),
                                                        t.ui.dropdown({
                                                            title: t.lang.table
                                                                .table,
                                                            className:
                                                                "note-table",
                                                            items: [
                                                                '<div class="note-dimension-picker">',
                                                                '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>',
                                                                '<div class="note-dimension-picker-highlighted"></div>',
                                                                '<div class="note-dimension-picker-unhighlighted"></div>',
                                                                "</div>",
                                                                '<div class="note-dimension-display">1 x 1</div>',
                                                            ].join(""),
                                                        }),
                                                    ],
                                                    {
                                                        callback: function (e) {
                                                            e.find(
                                                                ".note-dimension-picker-mousecatcher"
                                                            )
                                                                .css({
                                                                    width:
                                                                        t
                                                                            .options
                                                                            .insertTableMaxSize
                                                                            .col +
                                                                        "em",
                                                                    height:
                                                                        t
                                                                            .options
                                                                            .insertTableMaxSize
                                                                            .row +
                                                                        "em",
                                                                })
                                                                .mousedown(
                                                                    t.context.createInvokeHandler(
                                                                        "editor.insertTable"
                                                                    )
                                                                )
                                                                .on(
                                                                    "mousemove",
                                                                    t.tableMoveHandler.bind(
                                                                        t
                                                                    )
                                                                );
                                                        },
                                                    }
                                                )
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.link",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.link
                                                    ),
                                                    tooltip:
                                                        t.lang.link.link +
                                                        t.representShortcut(
                                                            "linkDialog.show"
                                                        ),
                                                    click: t.context.createInvokeHandler(
                                                        "linkDialog.show"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.picture",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.picture
                                                    ),
                                                    tooltip: t.lang.image.image,
                                                    click: t.context.createInvokeHandler(
                                                        "imageDialog.show"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.video",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.video
                                                    ),
                                                    tooltip: t.lang.video.video,
                                                    click: t.context.createInvokeHandler(
                                                        "videoDialog.show"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo("button.hr", function () {
                                        return t
                                            .button({
                                                contents: t.ui.icon(
                                                    t.options.icons.minus
                                                ),
                                                tooltip:
                                                    t.lang.hr.insert +
                                                    t.representShortcut(
                                                        "insertHorizontalRule"
                                                    ),
                                                click: t.context.createInvokeHandler(
                                                    "editor.insertHorizontalRule"
                                                ),
                                            })
                                            .render();
                                    }),
                                    this.context.memo(
                                        "button.fullscreen",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "btn-fullscreen note-codeview-keep",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .arrowsAlt
                                                    ),
                                                    tooltip:
                                                        t.lang.options
                                                            .fullscreen,
                                                    click: t.context.createInvokeHandler(
                                                        "fullscreen.toggle"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.codeview",
                                        function () {
                                            return t
                                                .button({
                                                    className:
                                                        "btn-codeview note-codeview-keep",
                                                    contents: t.ui.icon(
                                                        t.options.icons.code
                                                    ),
                                                    tooltip:
                                                        t.lang.options.codeview,
                                                    click: t.context.createInvokeHandler(
                                                        "codeview.toggle"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.redo",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.redo
                                                    ),
                                                    tooltip:
                                                        t.lang.history.redo +
                                                        t.representShortcut(
                                                            "redo"
                                                        ),
                                                    click: t.context.createInvokeHandler(
                                                        "editor.redo"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.undo",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.undo
                                                    ),
                                                    tooltip:
                                                        t.lang.history.undo +
                                                        t.representShortcut(
                                                            "undo"
                                                        ),
                                                    click: t.context.createInvokeHandler(
                                                        "editor.undo"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.help",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.question
                                                    ),
                                                    tooltip:
                                                        t.lang.options.help,
                                                    click: t.context.createInvokeHandler(
                                                        "helpDialog.show"
                                                    ),
                                                })
                                                .render();
                                        }
                                    );
                            },
                        },
                        {
                            key: "addImagePopoverButtons",
                            value: function () {
                                var t = this;
                                this.context.memo(
                                    "button.resizeFull",
                                    function () {
                                        return t
                                            .button({
                                                contents:
                                                    '<span class="note-fontsize-10">100%</span>',
                                                tooltip:
                                                    t.lang.image.resizeFull,
                                                click: t.context.createInvokeHandler(
                                                    "editor.resize",
                                                    "1"
                                                ),
                                            })
                                            .render();
                                    }
                                ),
                                    this.context.memo(
                                        "button.resizeHalf",
                                        function () {
                                            return t
                                                .button({
                                                    contents:
                                                        '<span class="note-fontsize-10">50%</span>',
                                                    tooltip:
                                                        t.lang.image.resizeHalf,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.resize",
                                                        "0.5"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.resizeQuarter",
                                        function () {
                                            return t
                                                .button({
                                                    contents:
                                                        '<span class="note-fontsize-10">25%</span>',
                                                    tooltip:
                                                        t.lang.image
                                                            .resizeQuarter,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.resize",
                                                        "0.25"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.resizeNone",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.rollback
                                                    ),
                                                    tooltip:
                                                        t.lang.image.resizeNone,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.resize",
                                                        "0"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.floatLeft",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .floatLeft
                                                    ),
                                                    tooltip:
                                                        t.lang.image.floatLeft,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.floatMe",
                                                        "left"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.floatRight",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .floatRight
                                                    ),
                                                    tooltip:
                                                        t.lang.image.floatRight,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.floatMe",
                                                        "right"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.floatNone",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.rollback
                                                    ),
                                                    tooltip:
                                                        t.lang.image.floatNone,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.floatMe",
                                                        "none"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.removeMedia",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.trash
                                                    ),
                                                    tooltip:
                                                        t.lang.image.remove,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.removeMedia"
                                                    ),
                                                })
                                                .render();
                                        }
                                    );
                            },
                        },
                        {
                            key: "addLinkPopoverButtons",
                            value: function () {
                                var t = this;
                                this.context.memo(
                                    "button.linkDialogShow",
                                    function () {
                                        return t
                                            .button({
                                                contents: t.ui.icon(
                                                    t.options.icons.link
                                                ),
                                                tooltip: t.lang.link.edit,
                                                click: t.context.createInvokeHandler(
                                                    "linkDialog.show"
                                                ),
                                            })
                                            .render();
                                    }
                                ),
                                    this.context.memo(
                                        "button.unlink",
                                        function () {
                                            return t
                                                .button({
                                                    contents: t.ui.icon(
                                                        t.options.icons.unlink
                                                    ),
                                                    tooltip: t.lang.link.unlink,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.unlink"
                                                    ),
                                                })
                                                .render();
                                        }
                                    );
                            },
                        },
                        {
                            key: "addTablePopoverButtons",
                            value: function () {
                                var t = this;
                                this.context.memo(
                                    "button.addRowUp",
                                    function () {
                                        return t
                                            .button({
                                                className: "btn-md",
                                                contents: t.ui.icon(
                                                    t.options.icons.rowAbove
                                                ),
                                                tooltip:
                                                    t.lang.table.addRowAbove,
                                                click: t.context.createInvokeHandler(
                                                    "editor.addRow",
                                                    "top"
                                                ),
                                            })
                                            .render();
                                    }
                                ),
                                    this.context.memo(
                                        "button.addRowDown",
                                        function () {
                                            return t
                                                .button({
                                                    className: "btn-md",
                                                    contents: t.ui.icon(
                                                        t.options.icons.rowBelow
                                                    ),
                                                    tooltip:
                                                        t.lang.table
                                                            .addRowBelow,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.addRow",
                                                        "bottom"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.addColLeft",
                                        function () {
                                            return t
                                                .button({
                                                    className: "btn-md",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .colBefore
                                                    ),
                                                    tooltip:
                                                        t.lang.table.addColLeft,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.addCol",
                                                        "left"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.addColRight",
                                        function () {
                                            return t
                                                .button({
                                                    className: "btn-md",
                                                    contents: t.ui.icon(
                                                        t.options.icons.colAfter
                                                    ),
                                                    tooltip:
                                                        t.lang.table
                                                            .addColRight,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.addCol",
                                                        "right"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.deleteRow",
                                        function () {
                                            return t
                                                .button({
                                                    className: "btn-md",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .rowRemove
                                                    ),
                                                    tooltip:
                                                        t.lang.table.delRow,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.deleteRow"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.deleteCol",
                                        function () {
                                            return t
                                                .button({
                                                    className: "btn-md",
                                                    contents: t.ui.icon(
                                                        t.options.icons
                                                            .colRemove
                                                    ),
                                                    tooltip:
                                                        t.lang.table.delCol,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.deleteCol"
                                                    ),
                                                })
                                                .render();
                                        }
                                    ),
                                    this.context.memo(
                                        "button.deleteTable",
                                        function () {
                                            return t
                                                .button({
                                                    className: "btn-md",
                                                    contents: t.ui.icon(
                                                        t.options.icons.trash
                                                    ),
                                                    tooltip:
                                                        t.lang.table.delTable,
                                                    click: t.context.createInvokeHandler(
                                                        "editor.deleteTable"
                                                    ),
                                                })
                                                .render();
                                        }
                                    );
                            },
                        },
                        {
                            key: "build",
                            value: function (t, e) {
                                for (var n = 0, o = e.length; n < o; n++) {
                                    for (
                                        var i = e[n],
                                            r = Array.isArray(i) ? i[0] : i,
                                            a = Array.isArray(i)
                                                ? 1 === i.length
                                                    ? [i[0]]
                                                    : i[1]
                                                : [i],
                                            s = this.ui
                                                .buttonGroup({
                                                    className: "note-" + r,
                                                })
                                                .render(),
                                            l = 0,
                                            c = a.length;
                                        l < c;
                                        l++
                                    ) {
                                        var u = this.context.memo(
                                            "button." + a[l]
                                        );
                                        u &&
                                            s.append(
                                                "function" == typeof u
                                                    ? u(this.context)
                                                    : u
                                            );
                                    }
                                    s.appendTo(t);
                                }
                            },
                        },
                        {
                            key: "updateCurrentStyle",
                            value: function (t) {
                                var e = this,
                                    n = t || this.$toolbar,
                                    o = this.context.invoke(
                                        "editor.currentStyle"
                                    );
                                if (
                                    (this.updateBtnStates(n, {
                                        ".note-btn-bold": function () {
                                            return "bold" === o["font-bold"];
                                        },
                                        ".note-btn-italic": function () {
                                            return (
                                                "italic" === o["font-italic"]
                                            );
                                        },
                                        ".note-btn-underline": function () {
                                            return (
                                                "underline" ===
                                                o["font-underline"]
                                            );
                                        },
                                        ".note-btn-subscript": function () {
                                            return (
                                                "subscript" ===
                                                o["font-subscript"]
                                            );
                                        },
                                        ".note-btn-superscript": function () {
                                            return (
                                                "superscript" ===
                                                o["font-superscript"]
                                            );
                                        },
                                        ".note-btn-strikethrough": function () {
                                            return (
                                                "strikethrough" ===
                                                o["font-strikethrough"]
                                            );
                                        },
                                    }),
                                    o["font-family"])
                                ) {
                                    var r = o["font-family"]
                                            .split(",")
                                            .map(function (t) {
                                                return t
                                                    .replace(/[\'\"]/g, "")
                                                    .replace(/\s+$/, "")
                                                    .replace(/^\s+/, "");
                                            }),
                                        a = C.find(
                                            r,
                                            this.isFontInstalled.bind(this)
                                        );
                                    n
                                        .find(".dropdown-fontname a")
                                        .each(function (t, e) {
                                            var n = i()(e),
                                                o =
                                                    n.data("value") + "" ==
                                                    a + "";
                                            n.toggleClass("checked", o);
                                        }),
                                        n
                                            .find(".note-current-fontname")
                                            .text(a)
                                            .css("font-family", a);
                                }
                                if (o["font-size"]) {
                                    var s = o["font-size"];
                                    n
                                        .find(".dropdown-fontsize a")
                                        .each(function (t, e) {
                                            var n = i()(e),
                                                o =
                                                    n.data("value") + "" ==
                                                    s + "";
                                            n.toggleClass("checked", o);
                                        }),
                                        n
                                            .find(".note-current-fontsize")
                                            .text(s);
                                    var l = o["font-size-unit"];
                                    n
                                        .find(".dropdown-fontsizeunit a")
                                        .each(function (t, e) {
                                            var n = i()(e),
                                                o =
                                                    n.data("value") + "" ==
                                                    l + "";
                                            n.toggleClass("checked", o);
                                        }),
                                        n
                                            .find(".note-current-fontsizeunit")
                                            .text(l);
                                }
                                if (o["line-height"]) {
                                    var c = o["line-height"];
                                    n.find(".dropdown-line-height li a").each(
                                        function (t, n) {
                                            var o =
                                                i()(n).data("value") + "" ==
                                                c + "";
                                            e.className = o ? "checked" : "";
                                        }
                                    );
                                }
                            },
                        },
                        {
                            key: "updateBtnStates",
                            value: function (t, e) {
                                var n = this;
                                i.a.each(e, function (e, o) {
                                    n.ui.toggleBtnActive(t.find(e), o());
                                });
                            },
                        },
                        {
                            key: "tableMoveHandler",
                            value: function (t) {
                                var e,
                                    n = i()(t.target.parentNode),
                                    o = n.next(),
                                    r = n.find(
                                        ".note-dimension-picker-mousecatcher"
                                    ),
                                    a = n.find(
                                        ".note-dimension-picker-highlighted"
                                    ),
                                    s = n.find(
                                        ".note-dimension-picker-unhighlighted"
                                    );
                                if (void 0 === t.offsetX) {
                                    var l = i()(t.target).offset();
                                    e = {
                                        x: t.pageX - l.left,
                                        y: t.pageY - l.top,
                                    };
                                } else e = { x: t.offsetX, y: t.offsetY };
                                var c = Math.ceil(e.x / 18) || 1,
                                    u = Math.ceil(e.y / 18) || 1;
                                a.css({
                                    width: c + "em",
                                    height: u + "em",
                                }),
                                    r.data("value", c + "x" + u),
                                    c > 3 &&
                                        c <
                                            this.options.insertTableMaxSize
                                                .col &&
                                        s.css({ width: c + 1 + "em" }),
                                    u > 3 &&
                                        u <
                                            this.options.insertTableMaxSize
                                                .row &&
                                        s.css({ height: u + 1 + "em" }),
                                    o.html(c + " x " + u);
                            },
                        },
                    ]) && ae(e.prototype, n),
                    o && ae(e, o),
                    t
                );
            })();

            function le(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var ce = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.$window = i()(window)),
                        (this.$document = i()(document)),
                        (this.ui = i.a.summernote.ui),
                        (this.$note = e.layoutInfo.note),
                        (this.$editor = e.layoutInfo.editor),
                        (this.$toolbar = e.layoutInfo.toolbar),
                        (this.$editable = e.layoutInfo.editable),
                        (this.$statusbar = e.layoutInfo.statusbar),
                        (this.options = e.options),
                        (this.isFollowing = !1),
                        (this.followScroll = this.followScroll.bind(this));
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return !this.options.airMode;
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                (this.options.toolbar =
                                    this.options.toolbar || []),
                                    this.options.toolbar.length
                                        ? this.context.invoke(
                                              "buttons.build",
                                              this.$toolbar,
                                              this.options.toolbar
                                          )
                                        : this.$toolbar.hide(),
                                    this.options.toolbarContainer &&
                                        this.$toolbar.appendTo(
                                            this.options.toolbarContainer
                                        ),
                                    this.changeContainer(!1),
                                    this.$note.on(
                                        "summernote.keyup summernote.mouseup summernote.change",
                                        function () {
                                            t.context.invoke(
                                                "buttons.updateCurrentStyle"
                                            );
                                        }
                                    ),
                                    this.context.invoke(
                                        "buttons.updateCurrentStyle"
                                    ),
                                    this.options.followingToolbar &&
                                        this.$window.on(
                                            "scroll resize",
                                            this.followScroll
                                        );
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$toolbar.children().remove(),
                                    this.options.followingToolbar &&
                                        this.$window.off(
                                            "scroll resize",
                                            this.followScroll
                                        );
                            },
                        },
                        {
                            key: "followScroll",
                            value: function () {
                                if (this.$editor.hasClass("fullscreen"))
                                    return !1;
                                var t = this.$editor.outerHeight(),
                                    e = this.$editor.width(),
                                    n = this.$toolbar.height(),
                                    o = this.$statusbar.height(),
                                    r = 0;
                                this.options.otherStaticBar &&
                                    (r = i()(
                                        this.options.otherStaticBar
                                    ).outerHeight());
                                var a = this.$document.scrollTop(),
                                    s = this.$editor.offset().top,
                                    l = s - r,
                                    c = s + t - r - n - o;
                                !this.isFollowing && a > l && a < c - n
                                    ? ((this.isFollowing = !0),
                                      this.$editable.css({
                                          marginTop:
                                              this.$toolbar.outerHeight(),
                                      }),
                                      this.$toolbar.css({
                                          position: "fixed",
                                          top: r,
                                          width: e,
                                          zIndex: 1e3,
                                      }))
                                    : this.isFollowing &&
                                      (a < l || a > c) &&
                                      ((this.isFollowing = !1),
                                      this.$toolbar.css({
                                          position: "relative",
                                          top: 0,
                                          width: "100%",
                                          zIndex: "auto",
                                      }),
                                      this.$editable.css({ marginTop: "" }));
                            },
                        },
                        {
                            key: "changeContainer",
                            value: function (t) {
                                t
                                    ? this.$toolbar.prependTo(this.$editor)
                                    : this.options.toolbarContainer &&
                                      this.$toolbar.appendTo(
                                          this.options.toolbarContainer
                                      ),
                                    this.options.followingToolbar &&
                                        this.followScroll();
                            },
                        },
                        {
                            key: "updateFullscreen",
                            value: function (t) {
                                this.ui.toggleBtnActive(
                                    this.$toolbar.find(".btn-fullscreen"),
                                    t
                                ),
                                    this.changeContainer(t);
                            },
                        },
                        {
                            key: "updateCodeview",
                            value: function (t) {
                                this.ui.toggleBtnActive(
                                    this.$toolbar.find(".btn-codeview"),
                                    t
                                ),
                                    t ? this.deactivate() : this.activate();
                            },
                        },
                        {
                            key: "activate",
                            value: function (t) {
                                var e = this.$toolbar.find("button");
                                t || (e = e.not(".note-codeview-keep")),
                                    this.ui.toggleBtn(e, !0);
                            },
                        },
                        {
                            key: "deactivate",
                            value: function (t) {
                                var e = this.$toolbar.find("button");
                                t || (e = e.not(".note-codeview-keep")),
                                    this.ui.toggleBtn(e, !1);
                            },
                        },
                    ]) && le(e.prototype, n),
                    o && le(e, o),
                    t
                );
            })();

            function ue(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var de = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.$body = i()(document.body)),
                        (this.$editor = e.layoutInfo.editor),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo),
                        e.memo(
                            "help.linkDialog.show",
                            this.options.langInfo.help["linkDialog.show"]
                        );
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = this.options.dialogsInBody
                                        ? this.$body
                                        : this.options.container,
                                    e = [
                                        '<div class="form-group note-form-group">',
                                        '<label for="note-dialog-link-txt-'
                                            .concat(
                                                this.options.id,
                                                '" class="note-form-label">'
                                            )
                                            .concat(
                                                this.lang.link.textToDisplay,
                                                "</label>"
                                            ),
                                        '<input id="note-dialog-link-txt-'.concat(
                                            this.options.id,
                                            '" class="note-link-text form-control note-form-control note-input" type="text"/>'
                                        ),
                                        "</div>",
                                        '<div class="form-group note-form-group">',
                                        '<label for="note-dialog-link-url-'
                                            .concat(
                                                this.options.id,
                                                '" class="note-form-label">'
                                            )
                                            .concat(
                                                this.lang.link.url,
                                                "</label>"
                                            ),
                                        '<input id="note-dialog-link-url-'.concat(
                                            this.options.id,
                                            '" class="note-link-url form-control note-form-control note-input" type="text" value="http://"/>'
                                        ),
                                        "</div>",
                                        this.options.disableLinkTarget
                                            ? ""
                                            : i()("<div/>")
                                                  .append(
                                                      this.ui
                                                          .checkbox({
                                                              className:
                                                                  "sn-checkbox-open-in-new-window",
                                                              text: this.lang
                                                                  .link
                                                                  .openInNewWindow,
                                                              checked: !0,
                                                          })
                                                          .render()
                                                  )
                                                  .html(),
                                        i()("<div/>")
                                            .append(
                                                this.ui
                                                    .checkbox({
                                                        className:
                                                            "sn-checkbox-use-protocol",
                                                        text: this.lang.link
                                                            .useProtocol,
                                                        checked: !0,
                                                    })
                                                    .render()
                                            )
                                            .html(),
                                    ].join(""),
                                    n = '<input type="button" href="#" class="'
                                        .concat(
                                            "btn btn-primary note-btn note-btn-primary note-link-btn",
                                            '" value="'
                                        )
                                        .concat(
                                            this.lang.link.insert,
                                            '" disabled>'
                                        );
                                this.$dialog = this.ui
                                    .dialog({
                                        className: "link-dialog",
                                        title: this.lang.link.insert,
                                        fade: this.options.dialogsFade,
                                        body: e,
                                        footer: n,
                                    })
                                    .render()
                                    .appendTo(t);
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.ui.hideDialog(this.$dialog),
                                    this.$dialog.remove();
                            },
                        },
                        {
                            key: "bindEnterKey",
                            value: function (t, e) {
                                t.on("keypress", function (t) {
                                    t.keyCode === xt.code.ENTER &&
                                        (t.preventDefault(),
                                        e.trigger("click"));
                                });
                            },
                        },
                        {
                            key: "toggleLinkBtn",
                            value: function (t, e, n) {
                                this.ui.toggleBtn(t, e.val() && n.val());
                            },
                        },
                        {
                            key: "showLinkDialog",
                            value: function (t) {
                                var e = this;
                                return i.a
                                    .Deferred(function (n) {
                                        var o =
                                                e.$dialog.find(
                                                    ".note-link-text"
                                                ),
                                            i =
                                                e.$dialog.find(
                                                    ".note-link-url"
                                                ),
                                            r =
                                                e.$dialog.find(
                                                    ".note-link-btn"
                                                ),
                                            a = e.$dialog.find(
                                                ".sn-checkbox-open-in-new-window input[type=checkbox]"
                                            ),
                                            s = e.$dialog.find(
                                                ".sn-checkbox-use-protocol input[type=checkbox]"
                                            );
                                        e.ui.onDialogShown(
                                            e.$dialog,
                                            function () {
                                                e.context.triggerEvent(
                                                    "dialog.shown"
                                                ),
                                                    !t.url &&
                                                        g.isValidUrl(t.text) &&
                                                        (t.url = t.text),
                                                    o
                                                        .on(
                                                            "input paste propertychange",
                                                            function () {
                                                                (t.text =
                                                                    o.val()),
                                                                    e.toggleLinkBtn(
                                                                        r,
                                                                        o,
                                                                        i
                                                                    );
                                                            }
                                                        )
                                                        .val(t.text),
                                                    i
                                                        .on(
                                                            "input paste propertychange",
                                                            function () {
                                                                t.text ||
                                                                    o.val(
                                                                        i.val()
                                                                    ),
                                                                    e.toggleLinkBtn(
                                                                        r,
                                                                        o,
                                                                        i
                                                                    );
                                                            }
                                                        )
                                                        .val(t.url),
                                                    m.isSupportTouch ||
                                                        i.trigger("focus"),
                                                    e.toggleLinkBtn(r, o, i),
                                                    e.bindEnterKey(i, r),
                                                    e.bindEnterKey(o, r);
                                                var l =
                                                    void 0 !== t.isNewWindow
                                                        ? t.isNewWindow
                                                        : e.context.options
                                                              .linkTargetBlank;
                                                a.prop("checked", l);
                                                var c =
                                                    !t.url &&
                                                    e.context.options
                                                        .useProtocol;
                                                s.prop("checked", c),
                                                    r.one(
                                                        "click",
                                                        function (r) {
                                                            r.preventDefault(),
                                                                n.resolve({
                                                                    range: t.range,
                                                                    url: i.val(),
                                                                    text: o.val(),
                                                                    isNewWindow:
                                                                        a.is(
                                                                            ":checked"
                                                                        ),
                                                                    checkProtocol:
                                                                        s.is(
                                                                            ":checked"
                                                                        ),
                                                                }),
                                                                e.ui.hideDialog(
                                                                    e.$dialog
                                                                );
                                                        }
                                                    );
                                            }
                                        ),
                                            e.ui.onDialogHidden(
                                                e.$dialog,
                                                function () {
                                                    o.off(),
                                                        i.off(),
                                                        r.off(),
                                                        "pending" ===
                                                            n.state() &&
                                                            n.reject();
                                                }
                                            ),
                                            e.ui.showDialog(e.$dialog);
                                    })
                                    .promise();
                            },
                        },
                        {
                            key: "show",
                            value: function () {
                                var t = this,
                                    e =
                                        this.context.invoke(
                                            "editor.getLinkInfo"
                                        );
                                this.context.invoke("editor.saveRange"),
                                    this.showLinkDialog(e)
                                        .then(function (e) {
                                            t.context.invoke(
                                                "editor.restoreRange"
                                            ),
                                                t.context.invoke(
                                                    "editor.createLink",
                                                    e
                                                );
                                        })
                                        .fail(function () {
                                            t.context.invoke(
                                                "editor.restoreRange"
                                            );
                                        });
                            },
                        },
                    ]) && ue(e.prototype, n),
                    o && ue(e, o),
                    t
                );
            })();

            function he(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var fe = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.options = e.options),
                        (this.events = {
                            "summernote.keyup summernote.mouseup summernote.change summernote.scroll":
                                function () {
                                    n.update();
                                },
                            "summernote.disable summernote.dialog.shown summernote.blur":
                                function () {
                                    n.hide();
                                },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return !C.isEmpty(this.options.popover.link);
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                this.$popover = this.ui
                                    .popover({
                                        className: "note-link-popover",
                                        callback: function (t) {
                                            t.find(
                                                ".popover-content,.note-popover-content"
                                            ).prepend(
                                                '<span><a target="_blank"></a>&nbsp;</span>'
                                            );
                                        },
                                    })
                                    .render()
                                    .appendTo(this.options.container);
                                var t = this.$popover.find(
                                    ".popover-content,.note-popover-content"
                                );
                                this.context.invoke(
                                    "buttons.build",
                                    t,
                                    this.options.popover.link
                                ),
                                    this.$popover.on("mousedown", function (t) {
                                        t.preventDefault();
                                    });
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$popover.remove();
                            },
                        },
                        {
                            key: "update",
                            value: function () {
                                if (this.context.invoke("editor.hasFocus")) {
                                    var t = this.context.invoke(
                                        "editor.getLastRange"
                                    );
                                    if (t.isCollapsed() && t.isOnAnchor()) {
                                        var e = pt.ancestor(t.sc, pt.isAnchor),
                                            n = i()(e).attr("href");
                                        this.$popover
                                            .find("a")
                                            .attr("href", n)
                                            .text(n);
                                        var o = pt.posFromPlaceholder(e),
                                            r = i()(
                                                this.options.container
                                            ).offset();
                                        (o.top -= r.top),
                                            (o.left -= r.left),
                                            this.$popover.css({
                                                display: "block",
                                                left: o.left,
                                                top: o.top,
                                            });
                                    } else this.hide();
                                } else this.hide();
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                this.$popover.hide();
                            },
                        },
                    ]) && he(e.prototype, n),
                    o && he(e, o),
                    t
                );
            })();

            function pe(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var me = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.$body = i()(document.body)),
                        (this.$editor = e.layoutInfo.editor),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = "";
                                if (this.options.maximumImageFileSize) {
                                    var e = Math.floor(
                                            Math.log(
                                                this.options
                                                    .maximumImageFileSize
                                            ) / Math.log(1024)
                                        ),
                                        n =
                                            1 *
                                                (
                                                    this.options
                                                        .maximumImageFileSize /
                                                    Math.pow(1024, e)
                                                ).toFixed(2) +
                                            " " +
                                            " KMGTP"[e] +
                                            "B";
                                    t = "<small>".concat(
                                        this.lang.image.maximumFileSize +
                                            " : " +
                                            n,
                                        "</small>"
                                    );
                                }
                                var o = this.options.dialogsInBody
                                        ? this.$body
                                        : this.options.container,
                                    i = [
                                        '<div class="form-group note-form-group note-group-select-from-files">',
                                        '<label for="note-dialog-image-file-' +
                                            this.options.id +
                                            '" class="note-form-label">' +
                                            this.lang.image.selectFromFiles +
                                            "</label>",
                                        '<input id="note-dialog-image-file-' +
                                            this.options.id +
                                            '" class="note-image-input form-control-file note-form-control note-input" ',
                                        ' type="file" name="files" accept="image/*" multiple="multiple"/>',
                                        t,
                                        "</div>",
                                        '<div class="form-group note-group-image-url">',
                                        '<label for="note-dialog-image-url-' +
                                            this.options.id +
                                            '" class="note-form-label">' +
                                            this.lang.image.url +
                                            "</label>",
                                        '<input id="note-dialog-image-url-' +
                                            this.options.id +
                                            '" class="note-image-url form-control note-form-control note-input" type="text"/>',
                                        "</div>",
                                    ].join(""),
                                    r = '<input type="button" href="#" class="'
                                        .concat(
                                            "btn btn-primary note-btn note-btn-primary note-image-btn",
                                            '" value="'
                                        )
                                        .concat(
                                            this.lang.image.insert,
                                            '" disabled>'
                                        );
                                this.$dialog = this.ui
                                    .dialog({
                                        title: this.lang.image.insert,
                                        fade: this.options.dialogsFade,
                                        body: i,
                                        footer: r,
                                    })
                                    .render()
                                    .appendTo(o);
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.ui.hideDialog(this.$dialog),
                                    this.$dialog.remove();
                            },
                        },
                        {
                            key: "bindEnterKey",
                            value: function (t, e) {
                                t.on("keypress", function (t) {
                                    t.keyCode === xt.code.ENTER &&
                                        (t.preventDefault(),
                                        e.trigger("click"));
                                });
                            },
                        },
                        {
                            key: "show",
                            value: function () {
                                var t = this;
                                this.context.invoke("editor.saveRange"),
                                    this.showImageDialog()
                                        .then(function (e) {
                                            t.ui.hideDialog(t.$dialog),
                                                t.context.invoke(
                                                    "editor.restoreRange"
                                                ),
                                                "string" == typeof e
                                                    ? t.options.callbacks
                                                          .onImageLinkInsert
                                                        ? t.context.triggerEvent(
                                                              "image.link.insert",
                                                              e
                                                          )
                                                        : t.context.invoke(
                                                              "editor.insertImage",
                                                              e
                                                          )
                                                    : t.context.invoke(
                                                          "editor.insertImagesOrCallback",
                                                          e
                                                      );
                                        })
                                        .fail(function () {
                                            t.context.invoke(
                                                "editor.restoreRange"
                                            );
                                        });
                            },
                        },
                        {
                            key: "showImageDialog",
                            value: function () {
                                var t = this;
                                return i.a.Deferred(function (e) {
                                    var n = t.$dialog.find(".note-image-input"),
                                        o = t.$dialog.find(".note-image-url"),
                                        i = t.$dialog.find(".note-image-btn");
                                    t.ui.onDialogShown(t.$dialog, function () {
                                        t.context.triggerEvent("dialog.shown"),
                                            n.replaceWith(
                                                n
                                                    .clone()
                                                    .on("change", function (t) {
                                                        e.resolve(
                                                            t.target.files ||
                                                                t.target.value
                                                        );
                                                    })
                                                    .val("")
                                            ),
                                            o
                                                .on(
                                                    "input paste propertychange",
                                                    function () {
                                                        t.ui.toggleBtn(
                                                            i,
                                                            o.val()
                                                        );
                                                    }
                                                )
                                                .val(""),
                                            m.isSupportTouch ||
                                                o.trigger("focus"),
                                            i.click(function (t) {
                                                t.preventDefault(),
                                                    e.resolve(o.val());
                                            }),
                                            t.bindEnterKey(o, i);
                                    }),
                                        t.ui.onDialogHidden(
                                            t.$dialog,
                                            function () {
                                                n.off(),
                                                    o.off(),
                                                    i.off(),
                                                    "pending" === e.state() &&
                                                        e.reject();
                                            }
                                        ),
                                        t.ui.showDialog(t.$dialog);
                                });
                            },
                        },
                    ]) && pe(e.prototype, n),
                    o && pe(e, o),
                    t
                );
            })();

            function ve(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var ge = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.editable = e.layoutInfo.editable[0]),
                        (this.options = e.options),
                        (this.events = {
                            "summernote.disable summernote.blur": function () {
                                n.hide();
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return !C.isEmpty(this.options.popover.image);
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                this.$popover = this.ui
                                    .popover({
                                        className: "note-image-popover",
                                    })
                                    .render()
                                    .appendTo(this.options.container);
                                var t = this.$popover.find(
                                    ".popover-content,.note-popover-content"
                                );
                                this.context.invoke(
                                    "buttons.build",
                                    t,
                                    this.options.popover.image
                                ),
                                    this.$popover.on("mousedown", function (t) {
                                        t.preventDefault();
                                    });
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$popover.remove();
                            },
                        },
                        {
                            key: "update",
                            value: function (t, e) {
                                if (pt.isImg(t)) {
                                    var n = i()(t).offset(),
                                        o = i()(
                                            this.options.container
                                        ).offset(),
                                        r = {};
                                    this.options.popatmouse
                                        ? ((r.left = e.pageX - 20),
                                          (r.top = e.pageY))
                                        : (r = n),
                                        (r.top -= o.top),
                                        (r.left -= o.left),
                                        this.$popover.css({
                                            display: "block",
                                            left: r.left,
                                            top: r.top,
                                        });
                                } else this.hide();
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                this.$popover.hide();
                            },
                        },
                    ]) && ve(e.prototype, n),
                    o && ve(e, o),
                    t
                );
            })();

            function be(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var ye = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.options = e.options),
                        (this.events = {
                            "summernote.mousedown": function (t, e) {
                                n.update(e.target);
                            },
                            "summernote.keyup summernote.scroll summernote.change":
                                function () {
                                    n.update();
                                },
                            "summernote.disable summernote.blur": function () {
                                n.hide();
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return !C.isEmpty(this.options.popover.table);
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                this.$popover = this.ui
                                    .popover({
                                        className: "note-table-popover",
                                    })
                                    .render()
                                    .appendTo(this.options.container);
                                var t = this.$popover.find(
                                    ".popover-content,.note-popover-content"
                                );
                                this.context.invoke(
                                    "buttons.build",
                                    t,
                                    this.options.popover.table
                                ),
                                    m.isFF &&
                                        document.execCommand(
                                            "enableInlineTableEditing",
                                            !1,
                                            !1
                                        ),
                                    this.$popover.on("mousedown", function (t) {
                                        t.preventDefault();
                                    });
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$popover.remove();
                            },
                        },
                        {
                            key: "update",
                            value: function (t) {
                                if (this.context.isDisabled()) return !1;
                                var e = pt.isCell(t);
                                if (e) {
                                    var n = pt.posFromPlaceholder(t),
                                        o = i()(
                                            this.options.container
                                        ).offset();
                                    (n.top -= o.top),
                                        (n.left -= o.left),
                                        this.$popover.css({
                                            display: "block",
                                            left: n.left,
                                            top: n.top,
                                        });
                                } else this.hide();
                                return e;
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                this.$popover.hide();
                            },
                        },
                    ]) && be(e.prototype, n),
                    o && be(e, o),
                    t
                );
            })();

            function ke(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var we = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.$body = i()(document.body)),
                        (this.$editor = e.layoutInfo.editor),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = this.options.dialogsInBody
                                        ? this.$body
                                        : this.options.container,
                                    e = [
                                        '<div class="form-group note-form-group row-fluid">',
                                        '<label for="note-dialog-video-url-'
                                            .concat(
                                                this.options.id,
                                                '" class="note-form-label">'
                                            )
                                            .concat(
                                                this.lang.video.url,
                                                ' <small class="text-muted">'
                                            )
                                            .concat(
                                                this.lang.video.providers,
                                                "</small></label>"
                                            ),
                                        '<input id="note-dialog-video-url-'.concat(
                                            this.options.id,
                                            '" class="note-video-url form-control note-form-control note-input" type="text"/>'
                                        ),
                                        "</div>",
                                    ].join(""),
                                    n = '<input type="button" href="#" class="'
                                        .concat(
                                            "btn btn-primary note-btn note-btn-primary note-video-btn",
                                            '" value="'
                                        )
                                        .concat(
                                            this.lang.video.insert,
                                            '" disabled>'
                                        );
                                this.$dialog = this.ui
                                    .dialog({
                                        title: this.lang.video.insert,
                                        fade: this.options.dialogsFade,
                                        body: e,
                                        footer: n,
                                    })
                                    .render()
                                    .appendTo(t);
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.ui.hideDialog(this.$dialog),
                                    this.$dialog.remove();
                            },
                        },
                        {
                            key: "bindEnterKey",
                            value: function (t, e) {
                                t.on("keypress", function (t) {
                                    t.keyCode === xt.code.ENTER &&
                                        (t.preventDefault(),
                                        e.trigger("click"));
                                });
                            },
                        },
                        {
                            key: "createVideoNode",
                            value: function (t) {
                                var e,
                                    n = t.match(
                                        /\/\/(?:(?:www|m)\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([\w|-]{11})(?:(?:[\?&]t=)(\S+))?$/
                                    ),
                                    o = t.match(
                                        /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/
                                    ),
                                    r = t.match(
                                        /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/
                                    ),
                                    a = t.match(
                                        /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/
                                    ),
                                    s = t.match(
                                        /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/
                                    ),
                                    l = t.match(
                                        /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/
                                    ),
                                    c = t.match(/\/\/v\.qq\.com.*?vid=(.+)/),
                                    u = t.match(
                                        /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/
                                    ),
                                    d = t.match(/^.+.(mp4|m4v)$/),
                                    h = t.match(/^.+.(ogg|ogv)$/),
                                    f = t.match(/^.+.(webm)$/),
                                    p = t.match(
                                        /(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/
                                    );
                                if (n && 11 === n[1].length) {
                                    var m = n[1],
                                        v = 0;
                                    if (void 0 !== n[2]) {
                                        var g = n[2].match(
                                            /^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/
                                        );
                                        if (g)
                                            for (
                                                var b = [3600, 60, 1],
                                                    y = 0,
                                                    k = b.length;
                                                y < k;
                                                y++
                                            )
                                                v +=
                                                    void 0 !== g[y + 1]
                                                        ? b[y] *
                                                          parseInt(g[y + 1], 10)
                                                        : 0;
                                    }
                                    e = i()("<iframe>")
                                        .attr("frameborder", 0)
                                        .attr(
                                            "src",
                                            "//www.youtube.com/embed/" +
                                                m +
                                                (v > 0 ? "?start=" + v : "")
                                        )
                                        .attr("width", "640")
                                        .attr("height", "360");
                                } else if (o && o[0].length)
                                    e = i()("<iframe>")
                                        .attr("frameborder", 0)
                                        .attr(
                                            "src",
                                            "https://instagram.com/p/" +
                                                o[1] +
                                                "/embed/"
                                        )
                                        .attr("width", "612")
                                        .attr("height", "710")
                                        .attr("scrolling", "no")
                                        .attr("allowtransparency", "true");
                                else if (r && r[0].length)
                                    e = i()("<iframe>")
                                        .attr("frameborder", 0)
                                        .attr("src", r[0] + "/embed/simple")
                                        .attr("width", "600")
                                        .attr("height", "600")
                                        .attr("class", "vine-embed");
                                else if (a && a[3].length)
                                    e = i()(
                                        "<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>"
                                    )
                                        .attr("frameborder", 0)
                                        .attr(
                                            "src",
                                            "//player.vimeo.com/video/" + a[3]
                                        )
                                        .attr("width", "640")
                                        .attr("height", "360");
                                else if (s && s[2].length)
                                    e = i()("<iframe>")
                                        .attr("frameborder", 0)
                                        .attr(
                                            "src",
                                            "//www.dailymotion.com/embed/video/" +
                                                s[2]
                                        )
                                        .attr("width", "640")
                                        .attr("height", "360");
                                else if (l && l[1].length)
                                    e = i()(
                                        "<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>"
                                    )
                                        .attr("frameborder", 0)
                                        .attr("height", "498")
                                        .attr("width", "510")
                                        .attr(
                                            "src",
                                            "//player.youku.com/embed/" + l[1]
                                        );
                                else if (
                                    (c && c[1].length) ||
                                    (u && u[2].length)
                                ) {
                                    var w = c && c[1].length ? c[1] : u[2];
                                    e = i()(
                                        "<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>"
                                    )
                                        .attr("frameborder", 0)
                                        .attr("height", "310")
                                        .attr("width", "500")
                                        .attr(
                                            "src",
                                            "https://v.qq.com/txp/iframe/player.html?vid=" +
                                                w +
                                                "&amp;auto=0"
                                        );
                                } else if (d || h || f)
                                    e = i()("<video controls>")
                                        .attr("src", t)
                                        .attr("width", "640")
                                        .attr("height", "360");
                                else {
                                    if (!p || !p[0].length) return !1;
                                    e = i()("<iframe>")
                                        .attr("frameborder", 0)
                                        .attr(
                                            "src",
                                            "https://www.facebook.com/plugins/video.php?href=" +
                                                encodeURIComponent(p[0]) +
                                                "&show_text=0&width=560"
                                        )
                                        .attr("width", "560")
                                        .attr("height", "301")
                                        .attr("scrolling", "no")
                                        .attr("allowtransparency", "true");
                                }
                                return e.addClass("note-video-clip"), e[0];
                            },
                        },
                        {
                            key: "show",
                            value: function () {
                                var t = this,
                                    e = this.context.invoke(
                                        "editor.getSelectedText"
                                    );
                                this.context.invoke("editor.saveRange"),
                                    this.showVideoDialog(e)
                                        .then(function (e) {
                                            t.ui.hideDialog(t.$dialog),
                                                t.context.invoke(
                                                    "editor.restoreRange"
                                                );
                                            var n = t.createVideoNode(e);
                                            n &&
                                                t.context.invoke(
                                                    "editor.insertNode",
                                                    n
                                                );
                                        })
                                        .fail(function () {
                                            t.context.invoke(
                                                "editor.restoreRange"
                                            );
                                        });
                            },
                        },
                        {
                            key: "showVideoDialog",
                            value: function () {
                                var t = this;
                                return i.a.Deferred(function (e) {
                                    var n = t.$dialog.find(".note-video-url"),
                                        o = t.$dialog.find(".note-video-btn");
                                    t.ui.onDialogShown(t.$dialog, function () {
                                        t.context.triggerEvent("dialog.shown"),
                                            n.on(
                                                "input paste propertychange",
                                                function () {
                                                    t.ui.toggleBtn(o, n.val());
                                                }
                                            ),
                                            m.isSupportTouch ||
                                                n.trigger("focus"),
                                            o.click(function (t) {
                                                t.preventDefault(),
                                                    e.resolve(n.val());
                                            }),
                                            t.bindEnterKey(n, o);
                                    }),
                                        t.ui.onDialogHidden(
                                            t.$dialog,
                                            function () {
                                                n.off(),
                                                    o.off(),
                                                    "pending" === e.state() &&
                                                        e.reject();
                                            }
                                        ),
                                        t.ui.showDialog(t.$dialog);
                                });
                            },
                        },
                    ]) && ke(e.prototype, n),
                    o && ke(e, o),
                    t
                );
            })();

            function Ce(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var xe = (function () {
                function t(e) {
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.$body = i()(document.body)),
                        (this.$editor = e.layoutInfo.editor),
                        (this.options = e.options),
                        (this.lang = this.options.langInfo);
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "initialize",
                            value: function () {
                                var t = this.options.dialogsInBody
                                        ? this.$body
                                        : this.options.container,
                                    e = [
                                        '<p class="text-center">',
                                        '<a href="http://summernote.org/" target="_blank">Summernote 0.8.18</a> · ',
                                        '<a href="https://github.com/summernote/summernote" target="_blank">Project</a> · ',
                                        '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>',
                                        "</p>",
                                    ].join("");
                                this.$dialog = this.ui
                                    .dialog({
                                        title: this.lang.options.help,
                                        fade: this.options.dialogsFade,
                                        body: this.createShortcutList(),
                                        footer: e,
                                        callback: function (t) {
                                            t.find(
                                                ".modal-body,.note-modal-body"
                                            ).css({
                                                "max-height": 300,
                                                overflow: "scroll",
                                            });
                                        },
                                    })
                                    .render()
                                    .appendTo(t);
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.ui.hideDialog(this.$dialog),
                                    this.$dialog.remove();
                            },
                        },
                        {
                            key: "createShortcutList",
                            value: function () {
                                var t = this,
                                    e =
                                        this.options.keyMap[
                                            m.isMac ? "mac" : "pc"
                                        ];
                                return Object.keys(e)
                                    .map(function (n) {
                                        var o = e[n],
                                            r = i()(
                                                '<div><div class="help-list-item"></div></div>'
                                            );
                                        return (
                                            r
                                                .append(
                                                    i()(
                                                        "<label><kbd>" +
                                                            n +
                                                            "</kdb></label>"
                                                    ).css({
                                                        width: 180,
                                                        "margin-right": 10,
                                                    })
                                                )
                                                .append(
                                                    i()("<span/>").html(
                                                        t.context.memo(
                                                            "help." + o
                                                        ) || o
                                                    )
                                                ),
                                            r.html()
                                        );
                                    })
                                    .join("");
                            },
                        },
                        {
                            key: "showHelpDialog",
                            value: function () {
                                var t = this;
                                return i.a
                                    .Deferred(function (e) {
                                        t.ui.onDialogShown(
                                            t.$dialog,
                                            function () {
                                                t.context.triggerEvent(
                                                    "dialog.shown"
                                                ),
                                                    e.resolve();
                                            }
                                        ),
                                            t.ui.showDialog(t.$dialog);
                                    })
                                    .promise();
                            },
                        },
                        {
                            key: "show",
                            value: function () {
                                var t = this;
                                this.context.invoke("editor.saveRange"),
                                    this.showHelpDialog().then(function () {
                                        t.context.invoke("editor.restoreRange");
                                    });
                            },
                        },
                    ]) && Ce(e.prototype, n),
                    o && Ce(e, o),
                    t
                );
            })();

            function Se(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Te = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.options = e.options),
                        (this.hidable = !0),
                        (this.onContextmenu = !1),
                        (this.pageX = null),
                        (this.pageY = null),
                        (this.events = {
                            "summernote.contextmenu": function (t) {
                                n.options.editing &&
                                    (t.preventDefault(),
                                    t.stopPropagation(),
                                    (n.onContextmenu = !0),
                                    n.update(!0));
                            },
                            "summernote.mousedown": function (t, e) {
                                (n.pageX = e.pageX), (n.pageY = e.pageY);
                            },
                            "summernote.keyup summernote.mouseup summernote.scroll":
                                function (t, e) {
                                    n.options.editing &&
                                        !n.onContextmenu &&
                                        ((n.pageX = e.pageX),
                                        (n.pageY = e.pageY),
                                        n.update()),
                                        (n.onContextmenu = !1);
                                },
                            "summernote.disable summernote.change summernote.dialog.shown summernote.blur":
                                function () {
                                    n.hide();
                                },
                            "summernote.focusout": function () {
                                n.$popover.is(":active,:focus") || n.hide();
                            },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return (
                                    this.options.airMode &&
                                    !C.isEmpty(this.options.popover.air)
                                );
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                this.$popover = this.ui
                                    .popover({ className: "note-air-popover" })
                                    .render()
                                    .appendTo(this.options.container);
                                var e = this.$popover.find(".popover-content");
                                this.context.invoke(
                                    "buttons.build",
                                    e,
                                    this.options.popover.air
                                ),
                                    this.$popover.on("mousedown", function () {
                                        t.hidable = !1;
                                    }),
                                    this.$popover.on("mouseup", function () {
                                        t.hidable = !0;
                                    });
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$popover.remove();
                            },
                        },
                        {
                            key: "update",
                            value: function (t) {
                                var e = this.context.invoke(
                                    "editor.currentStyle"
                                );
                                if (!e.range || (e.range.isCollapsed() && !t))
                                    this.hide();
                                else {
                                    var n = {
                                            left: this.pageX,
                                            top: this.pageY,
                                        },
                                        o = i()(
                                            this.options.container
                                        ).offset();
                                    (n.top -= o.top),
                                        (n.left -= o.left),
                                        this.$popover.css({
                                            display: "block",
                                            left: Math.max(n.left, 0) + -5,
                                            top: n.top + 5,
                                        }),
                                        this.context.invoke(
                                            "buttons.updateCurrentStyle",
                                            this.$popover
                                        );
                                }
                            },
                        },
                        {
                            key: "updateCodeview",
                            value: function (t) {
                                this.ui.toggleBtnActive(
                                    this.$popover.find(".btn-codeview"),
                                    t
                                ),
                                    t && this.hide();
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                this.hidable && this.$popover.hide();
                            },
                        },
                    ]) && Se(e.prototype, n),
                    o && Se(e, o),
                    t
                );
            })();

            function Ee(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    (o.enumerable = o.enumerable || !1),
                        (o.configurable = !0),
                        "value" in o && (o.writable = !0),
                        Object.defineProperty(t, o.key, o);
                }
            }

            var Ie = (function () {
                function t(e) {
                    var n = this;
                    !(function (t, e) {
                        if (!(t instanceof e))
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                    })(this, t),
                        (this.context = e),
                        (this.ui = i.a.summernote.ui),
                        (this.$editable = e.layoutInfo.editable),
                        (this.options = e.options),
                        (this.hint = this.options.hint || []),
                        (this.direction =
                            this.options.hintDirection || "bottom"),
                        (this.hints = Array.isArray(this.hint)
                            ? this.hint
                            : [this.hint]),
                        (this.events = {
                            "summernote.keyup": function (t, e) {
                                e.isDefaultPrevented() || n.handleKeyup(e);
                            },
                            "summernote.keydown": function (t, e) {
                                n.handleKeydown(e);
                            },
                            "summernote.disable summernote.dialog.shown summernote.blur":
                                function () {
                                    n.hide();
                                },
                        });
                }

                var e, n, o;
                return (
                    (e = t),
                    (n = [
                        {
                            key: "shouldInitialize",
                            value: function () {
                                return this.hints.length > 0;
                            },
                        },
                        {
                            key: "initialize",
                            value: function () {
                                var t = this;
                                (this.lastWordRange = null),
                                    (this.matchingWord = null),
                                    (this.$popover = this.ui
                                        .popover({
                                            className: "note-hint-popover",
                                            hideArrow: !0,
                                            direction: "",
                                        })
                                        .render()
                                        .appendTo(this.options.container)),
                                    this.$popover.hide(),
                                    (this.$content = this.$popover.find(
                                        ".popover-content,.note-popover-content"
                                    )),
                                    this.$content.on(
                                        "click",
                                        ".note-hint-item",
                                        function (e) {
                                            t.$content
                                                .find(".active")
                                                .removeClass("active"),
                                                i()(e.currentTarget).addClass(
                                                    "active"
                                                ),
                                                t.replace();
                                        }
                                    ),
                                    this.$popover.on("mousedown", function (t) {
                                        t.preventDefault();
                                    });
                            },
                        },
                        {
                            key: "destroy",
                            value: function () {
                                this.$popover.remove();
                            },
                        },
                        {
                            key: "selectItem",
                            value: function (t) {
                                this.$content
                                    .find(".active")
                                    .removeClass("active"),
                                    t.addClass("active"),
                                    (this.$content[0].scrollTop =
                                        t[0].offsetTop -
                                        this.$content.innerHeight() / 2);
                            },
                        },
                        {
                            key: "moveDown",
                            value: function () {
                                var t = this.$content.find(
                                        ".note-hint-item.active"
                                    ),
                                    e = t.next();
                                if (e.length) this.selectItem(e);
                                else {
                                    var n = t.parent().next();
                                    n.length ||
                                        (n = this.$content
                                            .find(".note-hint-group")
                                            .first()),
                                        this.selectItem(
                                            n.find(".note-hint-item").first()
                                        );
                                }
                            },
                        },
                        {
                            key: "moveUp",
                            value: function () {
                                var t = this.$content.find(
                                        ".note-hint-item.active"
                                    ),
                                    e = t.prev();
                                if (e.length) this.selectItem(e);
                                else {
                                    var n = t.parent().prev();
                                    n.length ||
                                        (n = this.$content
                                            .find(".note-hint-group")
                                            .last()),
                                        this.selectItem(
                                            n.find(".note-hint-item").last()
                                        );
                                }
                            },
                        },
                        {
                            key: "replace",
                            value: function () {
                                var t = this.$content.find(
                                    ".note-hint-item.active"
                                );
                                if (t.length) {
                                    var e = this.nodeFromItem(t);
                                    if (
                                        null !== this.matchingWord &&
                                        0 === this.matchingWord.length
                                    )
                                        this.lastWordRange.so =
                                            this.lastWordRange.eo;
                                    else if (
                                        null !== this.matchingWord &&
                                        this.matchingWord.length > 0 &&
                                        !this.lastWordRange.isCollapsed()
                                    ) {
                                        var n =
                                            this.lastWordRange.eo -
                                            this.lastWordRange.so -
                                            this.matchingWord.length;
                                        n > 0 && (this.lastWordRange.so += n);
                                    }
                                    if (
                                        (this.lastWordRange.insertNode(e),
                                        "next" === this.options.hintSelect)
                                    ) {
                                        var o = document.createTextNode("");
                                        i()(e).after(o),
                                            wt.createFromNodeBefore(o).select();
                                    } else wt.createFromNodeAfter(e).select();
                                    (this.lastWordRange = null),
                                        this.hide(),
                                        this.context.invoke("editor.focus");
                                }
                            },
                        },
                        {
                            key: "nodeFromItem",
                            value: function (t) {
                                var e = this.hints[t.data("index")],
                                    n = t.data("item"),
                                    o = e.content ? e.content(n) : n;
                                return (
                                    "string" == typeof o &&
                                        (o = pt.createText(o)),
                                    o
                                );
                            },
                        },
                        {
                            key: "createItemTemplates",
                            value: function (t, e) {
                                var n = this.hints[t];
                                return e.map(function (e) {
                                    var o = i()(
                                        '<div class="note-hint-item"/>'
                                    );
                                    return (
                                        o.append(
                                            n.template ? n.template(e) : e + ""
                                        ),
                                        o.data({ index: t, item: e }),
                                        o
                                    );
                                });
                            },
                        },
                        {
                            key: "handleKeydown",
                            value: function (t) {
                                this.$popover.is(":visible") &&
                                    (t.keyCode === xt.code.ENTER
                                        ? (t.preventDefault(), this.replace())
                                        : t.keyCode === xt.code.UP
                                        ? (t.preventDefault(), this.moveUp())
                                        : t.keyCode === xt.code.DOWN &&
                                          (t.preventDefault(),
                                          this.moveDown()));
                            },
                        },
                        {
                            key: "searchKeyword",
                            value: function (t, e, n) {
                                var o = this.hints[t];
                                if (o && o.match.test(e) && o.search) {
                                    var i = o.match.exec(e);
                                    (this.matchingWord = i[0]),
                                        o.search(i[1], n);
                                } else n();
                            },
                        },
                        {
                            key: "createGroup",
                            value: function (t, e) {
                                var n = this,
                                    o = i()(
                                        '<div class="note-hint-group note-hint-group-' +
                                            t +
                                            '"></div>'
                                    );
                                return (
                                    this.searchKeyword(t, e, function (e) {
                                        (e = e || []).length &&
                                            (o.html(
                                                n.createItemTemplates(t, e)
                                            ),
                                            n.show());
                                    }),
                                    o
                                );
                            },
                        },
                        {
                            key: "handleKeyup",
                            value: function (t) {
                                var e = this;
                                if (
                                    !C.contains(
                                        [
                                            xt.code.ENTER,
                                            xt.code.UP,
                                            xt.code.DOWN,
                                        ],
                                        t.keyCode
                                    )
                                ) {
                                    var n,
                                        o,
                                        r = this.context.invoke(
                                            "editor.getLastRange"
                                        );
                                    if ("words" === this.options.hintMode) {
                                        if (
                                            ((n = r.getWordsRange(r)),
                                            (o = n.toString()),
                                            this.hints.forEach(function (t) {
                                                if (t.match.test(o))
                                                    return (
                                                        (n =
                                                            r.getWordsMatchRange(
                                                                t.match
                                                            )),
                                                        !1
                                                    );
                                            }),
                                            !n)
                                        )
                                            return void this.hide();
                                        o = n.toString();
                                    } else
                                        (n = r.getWordRange()),
                                            (o = n.toString());
                                    if (this.hints.length && o) {
                                        this.$content.empty();
                                        var a = g.rect2bnd(
                                                C.last(n.getClientRects())
                                            ),
                                            s = i()(
                                                this.options.container
                                            ).offset();
                                        a &&
                                            ((a.top -= s.top),
                                            (a.left -= s.left),
                                            this.$popover.hide(),
                                            (this.lastWordRange = n),
                                            this.hints.forEach(function (t, n) {
                                                t.match.test(o) &&
                                                    e
                                                        .createGroup(n, o)
                                                        .appendTo(e.$content);
                                            }),
                                            this.$content
                                                .find(".note-hint-item:first")
                                                .addClass("active"),
                                            "top" === this.direction
                                                ? this.$popover.css({
                                                      left: a.left,
                                                      top:
                                                          a.top -
                                                          this.$popover.outerHeight() -
                                                          5,
                                                  })
                                                : this.$popover.css({
                                                      left: a.left,
                                                      top: a.top + a.height + 5,
                                                  }));
                                    } else this.hide();
                                }
                            },
                        },
                        {
                            key: "show",
                            value: function () {
                                this.$popover.show();
                            },
                        },
                        {
                            key: "hide",
                            value: function () {
                                this.$popover.hide();
                            },
                        },
                    ]) && Ee(e.prototype, n),
                    o && Ee(e, o),
                    t
                );
            })();
            i.a.summernote = i.a.extend(i.a.summernote, {
                version: "0.8.18",
                plugins: {},
                dom: pt,
                range: wt,
                lists: C,
                options: {
                    langInfo: i.a.summernote.lang["en-US"],
                    editing: !0,
                    modules: {
                        editor: Ht,
                        clipboard: Bt,
                        dropzone: Ot,
                        codeview: Kt,
                        statusbar: Vt,
                        fullscreen: Gt,
                        handle: Zt,
                        hintPopover: Ie,
                        autoLink: Jt,
                        autoSync: ee,
                        autoReplace: oe,
                        placeholder: re,
                        buttons: se,
                        toolbar: ce,
                        linkDialog: de,
                        linkPopover: fe,
                        imageDialog: me,
                        imagePopover: ge,
                        tablePopover: ye,
                        videoDialog: we,
                        helpDialog: xe,
                        airPopover: Te,
                    },
                    buttons: {},
                    lang: "en-US",
                    followingToolbar: !1,
                    toolbarPosition: "top",
                    otherStaticBar: "",
                    codeviewKeepButton: !1,
                    toolbar: [
                        ["style", ["style"]],
                        ["font", ["bold", "underline", "clear"]],
                        ["fontname", ["fontname"]],
                        ["color", ["color"]],
                        ["para", ["ul", "ol", "paragraph"]],
                        ["table", ["table"]],
                        ["insert", ["link", "picture", "video"]],
                        ["view", ["fullscreen", "codeview", "help"]],
                    ],
                    popatmouse: !0,
                    popover: {
                        image: [
                            [
                                "resize",
                                [
                                    "resizeFull",
                                    "resizeHalf",
                                    "resizeQuarter",
                                    "resizeNone",
                                ],
                            ],
                            ["float", ["floatLeft", "floatRight", "floatNone"]],
                            ["remove", ["removeMedia"]],
                        ],
                        link: [["link", ["linkDialogShow", "unlink"]]],
                        table: [
                            [
                                "add",
                                [
                                    "addRowDown",
                                    "addRowUp",
                                    "addColLeft",
                                    "addColRight",
                                ],
                            ],
                            [
                                "delete",
                                ["deleteRow", "deleteCol", "deleteTable"],
                            ],
                        ],
                        air: [
                            ["color", ["color"]],
                            ["font", ["bold", "underline", "clear"]],
                            ["para", ["ul", "paragraph"]],
                            ["table", ["table"]],
                            ["insert", ["link", "picture"]],
                            ["view", ["fullscreen", "codeview"]],
                        ],
                    },
                    airMode: !1,
                    overrideContextMenu: !1,
                    width: null,
                    height: null,
                    linkTargetBlank: !0,
                    useProtocol: !0,
                    defaultProtocol: "http://",
                    focus: !1,
                    tabDisabled: !1,
                    tabSize: 4,
                    styleWithCSS: !1,
                    shortcuts: !0,
                    textareaAutoSync: !0,
                    tooltip: "auto",
                    container: null,
                    maxTextLength: 0,
                    blockquoteBreakingLevel: 2,
                    spellCheck: !0,
                    disableGrammar: !1,
                    placeholder: null,
                    inheritPlaceholder: !1,
                    recordEveryKeystroke: !1,
                    historyLimit: 200,
                    showDomainOnlyForAutolink: !1,
                    hintMode: "word",
                    hintSelect: "after",
                    hintDirection: "bottom",
                    styleTags: [
                        "p",
                        "blockquote",
                        "pre",
                        "h1",
                        "h2",
                        "h3",
                        "h4",
                        "h5",
                        "h6",
                    ],
                    fontNames: [
                        "Arial",
                        "Arial Black",
                        "Comic Sans MS",
                        "Courier New",
                        "Helvetica Neue",
                        "Helvetica",
                        "Impact",
                        "Lucida Grande",
                        "Tahoma",
                        "Times New Roman",
                        "Verdana",
                    ],
                    fontNamesIgnoreCheck: [],
                    addDefaultFonts: !0,
                    fontSizes: [
                        "8",
                        "9",
                        "10",
                        "11",
                        "12",
                        "14",
                        "18",
                        "24",
                        "36",
                    ],
                    fontSizeUnits: ["px", "pt"],
                    colors: [
                        [
                            "#000000",
                            "#424242",
                            "#636363",
                            "#9C9C94",
                            "#CEC6CE",
                            "#EFEFEF",
                            "#F7F7F7",
                            "#FFFFFF",
                        ],
                        [
                            "#FF0000",
                            "#FF9C00",
                            "#FFFF00",
                            "#00FF00",
                            "#00FFFF",
                            "#0000FF",
                            "#9C00FF",
                            "#FF00FF",
                        ],
                        [
                            "#F7C6CE",
                            "#FFE7CE",
                            "#FFEFC6",
                            "#D6EFD6",
                            "#CEDEE7",
                            "#CEE7F7",
                            "#D6D6E7",
                            "#E7D6DE",
                        ],
                        [
                            "#E79C9C",
                            "#FFC69C",
                            "#FFE79C",
                            "#B5D6A5",
                            "#A5C6CE",
                            "#9CC6EF",
                            "#B5A5D6",
                            "#D6A5BD",
                        ],
                        [
                            "#E76363",
                            "#F7AD6B",
                            "#FFD663",
                            "#94BD7B",
                            "#73A5AD",
                            "#6BADDE",
                            "#8C7BC6",
                            "#C67BA5",
                        ],
                        [
                            "#CE0000",
                            "#E79439",
                            "#EFC631",
                            "#6BA54A",
                            "#4A7B8C",
                            "#3984C6",
                            "#634AA5",
                            "#A54A7B",
                        ],
                        [
                            "#9C0000",
                            "#B56308",
                            "#BD9400",
                            "#397B21",
                            "#104A5A",
                            "#085294",
                            "#311873",
                            "#731842",
                        ],
                        [
                            "#630000",
                            "#7B3900",
                            "#846300",
                            "#295218",
                            "#083139",
                            "#003163",
                            "#21104A",
                            "#4A1031",
                        ],
                    ],
                    colorsName: [
                        [
                            "Black",
                            "Tundora",
                            "Dove Gray",
                            "Star Dust",
                            "Pale Slate",
                            "Gallery",
                            "Alabaster",
                            "White",
                        ],
                        [
                            "Red",
                            "Orange Peel",
                            "Yellow",
                            "Green",
                            "Cyan",
                            "Blue",
                            "Electric Violet",
                            "Magenta",
                        ],
                        [
                            "Azalea",
                            "Karry",
                            "Egg White",
                            "Zanah",
                            "Botticelli",
                            "Tropical Blue",
                            "Mischka",
                            "Twilight",
                        ],
                        [
                            "Tonys Pink",
                            "Peach Orange",
                            "Cream Brulee",
                            "Sprout",
                            "Casper",
                            "Perano",
                            "Cold Purple",
                            "Careys Pink",
                        ],
                        [
                            "Mandy",
                            "Rajah",
                            "Dandelion",
                            "Olivine",
                            "Gulf Stream",
                            "Viking",
                            "Blue Marguerite",
                            "Puce",
                        ],
                        [
                            "Guardsman Red",
                            "Fire Bush",
                            "Golden Dream",
                            "Chelsea Cucumber",
                            "Smalt Blue",
                            "Boston Blue",
                            "Butterfly Bush",
                            "Cadillac",
                        ],
                        [
                            "Sangria",
                            "Mai Tai",
                            "Buddha Gold",
                            "Forest Green",
                            "Eden",
                            "Venice Blue",
                            "Meteorite",
                            "Claret",
                        ],
                        [
                            "Rosewood",
                            "Cinnamon",
                            "Olive",
                            "Parsley",
                            "Tiber",
                            "Midnight Blue",
                            "Valentino",
                            "Loulou",
                        ],
                    ],
                    colorButton: { foreColor: "#000000", backColor: "#FFFF00" },
                    lineHeights: [
                        "1.0",
                        "1.2",
                        "1.4",
                        "1.5",
                        "1.6",
                        "1.8",
                        "2.0",
                        "3.0",
                    ],
                    tableClassName: "table table-bordered",
                    insertTableMaxSize: { col: 10, row: 10 },
                    dialogsInBody: !1,
                    dialogsFade: !1,
                    maximumImageFileSize: null,
                    callbacks: {
                        onBeforeCommand: null,
                        onBlur: null,
                        onBlurCodeview: null,
                        onChange: null,
                        onChangeCodeview: null,
                        onDialogShown: null,
                        onEnter: null,
                        onFocus: null,
                        onImageLinkInsert: null,
                        onImageUpload: null,
                        onImageUploadError: null,
                        onInit: null,
                        onKeydown: null,
                        onKeyup: null,
                        onMousedown: null,
                        onMouseup: null,
                        onPaste: null,
                        onScroll: null,
                    },
                    codemirror: {
                        mode: "text/html",
                        htmlMode: !0,
                        lineNumbers: !0,
                    },
                    codeviewFilter: !1,
                    codeviewFilterRegex:
                        /<\/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|ilayer|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|t(?:itle|extarea)|xml)[^>]*?>/gi,
                    codeviewIframeFilter: !0,
                    codeviewIframeWhitelistSrc: [],
                    codeviewIframeWhitelistSrcBase: [
                        "www.youtube.com",
                        "www.youtube-nocookie.com",
                        "www.facebook.com",
                        "vine.co",
                        "instagram.com",
                        "player.vimeo.com",
                        "www.dailymotion.com",
                        "player.youku.com",
                        "v.qq.com",
                    ],
                    keyMap: {
                        pc: {
                            ESC: "escape",
                            ENTER: "insertParagraph",
                            "CTRL+Z": "undo",
                            "CTRL+Y": "redo",
                            TAB: "tab",
                            "SHIFT+TAB": "untab",
                            "CTRL+B": "bold",
                            "CTRL+I": "italic",
                            "CTRL+U": "underline",
                            "CTRL+SHIFT+S": "strikethrough",
                            "CTRL+BACKSLASH": "removeFormat",
                            "CTRL+SHIFT+L": "justifyLeft",
                            "CTRL+SHIFT+E": "justifyCenter",
                            "CTRL+SHIFT+R": "justifyRight",
                            "CTRL+SHIFT+J": "justifyFull",
                            "CTRL+SHIFT+NUM7": "insertUnorderedList",
                            "CTRL+SHIFT+NUM8": "insertOrderedList",
                            "CTRL+LEFTBRACKET": "outdent",
                            "CTRL+RIGHTBRACKET": "indent",
                            "CTRL+NUM0": "formatPara",
                            "CTRL+NUM1": "formatH1",
                            "CTRL+NUM2": "formatH2",
                            "CTRL+NUM3": "formatH3",
                            "CTRL+NUM4": "formatH4",
                            "CTRL+NUM5": "formatH5",
                            "CTRL+NUM6": "formatH6",
                            "CTRL+ENTER": "insertHorizontalRule",
                            "CTRL+K": "linkDialog.show",
                        },
                        mac: {
                            ESC: "escape",
                            ENTER: "insertParagraph",
                            "CMD+Z": "undo",
                            "CMD+SHIFT+Z": "redo",
                            TAB: "tab",
                            "SHIFT+TAB": "untab",
                            "CMD+B": "bold",
                            "CMD+I": "italic",
                            "CMD+U": "underline",
                            "CMD+SHIFT+S": "strikethrough",
                            "CMD+BACKSLASH": "removeFormat",
                            "CMD+SHIFT+L": "justifyLeft",
                            "CMD+SHIFT+E": "justifyCenter",
                            "CMD+SHIFT+R": "justifyRight",
                            "CMD+SHIFT+J": "justifyFull",
                            "CMD+SHIFT+NUM7": "insertUnorderedList",
                            "CMD+SHIFT+NUM8": "insertOrderedList",
                            "CMD+LEFTBRACKET": "outdent",
                            "CMD+RIGHTBRACKET": "indent",
                            "CMD+NUM0": "formatPara",
                            "CMD+NUM1": "formatH1",
                            "CMD+NUM2": "formatH2",
                            "CMD+NUM3": "formatH3",
                            "CMD+NUM4": "formatH4",
                            "CMD+NUM5": "formatH5",
                            "CMD+NUM6": "formatH6",
                            "CMD+ENTER": "insertHorizontalRule",
                            "CMD+K": "linkDialog.show",
                        },
                    },
                    icons: {
                        align: "note-icon-align",
                        alignCenter: "note-icon-align-center",
                        alignJustify: "note-icon-align-justify",
                        alignLeft: "note-icon-align-left",
                        alignRight: "note-icon-align-right",
                        rowBelow: "note-icon-row-below",
                        colBefore: "note-icon-col-before",
                        colAfter: "note-icon-col-after",
                        rowAbove: "note-icon-row-above",
                        rowRemove: "note-icon-row-remove",
                        colRemove: "note-icon-col-remove",
                        indent: "note-icon-align-indent",
                        outdent: "note-icon-align-outdent",
                        arrowsAlt: "note-icon-arrows-alt",
                        bold: "note-icon-bold",
                        caret: "note-icon-caret",
                        circle: "note-icon-circle",
                        close: "note-icon-close",
                        code: "note-icon-code",
                        eraser: "note-icon-eraser",
                        floatLeft: "note-icon-float-left",
                        floatRight: "note-icon-float-right",
                        font: "note-icon-font",
                        frame: "note-icon-frame",
                        italic: "note-icon-italic",
                        link: "note-icon-link",
                        unlink: "note-icon-chain-broken",
                        magic: "note-icon-magic",
                        menuCheck: "note-icon-menu-check",
                        minus: "note-icon-minus",
                        orderedlist: "note-icon-orderedlist",
                        pencil: "note-icon-pencil",
                        picture: "note-icon-picture",
                        question: "note-icon-question",
                        redo: "note-icon-redo",
                        rollback: "note-icon-rollback",
                        square: "note-icon-square",
                        strikethrough: "note-icon-strikethrough",
                        subscript: "note-icon-subscript",
                        superscript: "note-icon-superscript",
                        table: "note-icon-table",
                        textHeight: "note-icon-text-height",
                        trash: "note-icon-trash",
                        underline: "note-icon-underline",
                        undo: "note-icon-undo",
                        unorderedlist: "note-icon-unorderedlist",
                        video: "note-icon-video",
                    },
                },
            });
        },
        5: function (t, e, n) {},
        53: function (t, e, n) {
            "use strict";
            n.r(e);
            var o = n(0),
                i = n.n(o),
                r = n(1);

            function a(t) {
                return (a =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                        ? function (t) {
                              return typeof t;
                          }
                        : function (t) {
                              return t &&
                                  "function" == typeof Symbol &&
                                  t.constructor === Symbol &&
                                  t !== Symbol.prototype
                                  ? "symbol"
                                  : typeof t;
                          })(t);
            }

            var s = r.a.create('<div class="note-editor note-frame card"/>'),
                l = r.a.create(
                    '<div class="note-toolbar card-header" role="toolbar"/>'
                ),
                c = r.a.create('<div class="note-editing-area"/>'),
                u = r.a.create(
                    '<textarea class="note-codable" aria-multiline="true"/>'
                ),
                d = r.a.create(
                    '<div class="note-editable card-block" contentEditable="true" role="textbox" aria-multiline="true"/>'
                ),
                h = r.a.create(
                    [
                        '<output class="note-status-output" role="status" aria-live="polite"></output>',
                        '<div class="note-statusbar" role="status">',
                        '<div class="note-resizebar" aria-label="Resize">',
                        '<div class="note-icon-bar"></div>',
                        '<div class="note-icon-bar"></div>',
                        '<div class="note-icon-bar"></div>',
                        "</div>",
                        "</div>",
                    ].join("")
                ),
                f = r.a.create('<div class="note-editor note-airframe"/>'),
                p = r.a.create(
                    [
                        '<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>',
                        '<output class="note-status-output" role="status" aria-live="polite"></output>',
                    ].join("")
                ),
                m = r.a.create('<div class="note-btn-group btn-group">'),
                v = r.a.create(
                    '<div class="note-dropdown-menu dropdown-menu" role="list">',
                    function (t, e) {
                        var n = Array.isArray(e.items)
                            ? e.items
                                  .map(function (t) {
                                      var n =
                                              "string" == typeof t
                                                  ? t
                                                  : t.value || "",
                                          o = e.template ? e.template(t) : t,
                                          i =
                                              "object" === a(t)
                                                  ? t.option
                                                  : void 0;
                                      return (
                                          '<a class="dropdown-item" href="#" ' +
                                          ('data-value="' +
                                              n +
                                              '"' +
                                              (void 0 !== i
                                                  ? ' data-option="' + i + '"'
                                                  : "")) +
                                          ' role="listitem" aria-label="' +
                                          n +
                                          '">' +
                                          o +
                                          "</a>"
                                      );
                                  })
                                  .join("")
                            : e.items;
                        t.html(n).attr({ "aria-label": e.title }),
                            e &&
                                e.codeviewKeepButton &&
                                t.addClass("note-codeview-keep");
                    }
                ),
                g = function (t) {
                    return t;
                },
                b = r.a.create(
                    '<div class="note-dropdown-menu dropdown-menu note-check" role="list">',
                    function (t, e) {
                        var n = Array.isArray(e.items)
                            ? e.items
                                  .map(function (t) {
                                      var n =
                                              "string" == typeof t
                                                  ? t
                                                  : t.value || "",
                                          o = e.template ? e.template(t) : t;
                                      return (
                                          '<a class="dropdown-item" href="#" data-value="' +
                                          n +
                                          '" role="listitem" aria-label="' +
                                          t +
                                          '">' +
                                          C(e.checkClassName) +
                                          " " +
                                          o +
                                          "</a>"
                                      );
                                  })
                                  .join("")
                            : e.items;
                        t.html(n).attr({ "aria-label": e.title }),
                            e &&
                                e.codeviewKeepButton &&
                                t.addClass("note-codeview-keep");
                    }
                ),
                y = r.a.create(
                    '<div class="modal note-modal" aria-hidden="false" tabindex="-1" role="dialog"/>',
                    function (t, e) {
                        e.fade && t.addClass("fade"),
                            t.attr({ "aria-label": e.title }),
                            t.html(
                                [
                                    '<div class="modal-dialog">',
                                    '<div class="modal-content">',
                                    e.title
                                        ? '<div class="modal-header"><h4 class="modal-title">' +
                                          e.title +
                                          '</h4><button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button></div>'
                                        : "",
                                    '<div class="modal-body">' +
                                        e.body +
                                        "</div>",
                                    e.footer
                                        ? '<div class="modal-footer">' +
                                          e.footer +
                                          "</div>"
                                        : "",
                                    "</div>",
                                    "</div>",
                                ].join("")
                            );
                    }
                ),
                k = r.a.create(
                    [
                        '<div class="note-popover popover in">',
                        '<div class="arrow"></div>',
                        '<div class="popover-content note-children-container"></div>',
                        "</div>",
                    ].join(""),
                    function (t, e) {
                        var n = void 0 !== e.direction ? e.direction : "bottom";
                        t.addClass(n), e.hideArrow && t.find(".arrow").hide();
                    }
                ),
                w = r.a.create(
                    '<div class="form-check"></div>',
                    function (t, e) {
                        t.html(
                            [
                                '<label class="form-check-label"' +
                                    (e.id ? ' for="note-' + e.id + '"' : "") +
                                    ">",
                                '<input type="checkbox" class="form-check-input"' +
                                    (e.id ? ' id="note-' + e.id + '"' : ""),
                                e.checked ? " checked" : "",
                                ' aria-label="' + (e.text ? e.text : "") + '"',
                                ' aria-checked="' +
                                    (e.checked ? "true" : "false") +
                                    '"/>',
                                " " + (e.text ? e.text : "") + "</label>",
                            ].join("")
                        );
                    }
                ),
                C = function (t, e) {
                    return (
                        "<" + (e = e || "i") + ' class="' + t + '"></' + e + ">"
                    );
                },
                x = function (t) {
                    return {
                        editor: s,
                        toolbar: l,
                        editingArea: c,
                        codable: u,
                        editable: d,
                        statusbar: h,
                        airEditor: f,
                        airEditable: p,
                        buttonGroup: m,
                        dropdown: v,
                        dropdownButtonContents: g,
                        dropdownCheck: b,
                        dialog: y,
                        popover: k,
                        icon: C,
                        checkbox: w,
                        options: t,
                        palette: function (e, n) {
                            return r.a.create(
                                '<div class="note-color-palette"/>',
                                function (e, n) {
                                    for (
                                        var o = [], i = 0, r = n.colors.length;
                                        i < r;
                                        i++
                                    ) {
                                        for (
                                            var a = n.eventName,
                                                s = n.colors[i],
                                                l = n.colorsName[i],
                                                c = [],
                                                u = 0,
                                                d = s.length;
                                            u < d;
                                            u++
                                        ) {
                                            var h = s[u],
                                                f = l[u];
                                            c.push(
                                                [
                                                    '<button type="button" class="note-color-btn"',
                                                    'style="background-color:',
                                                    h,
                                                    '" ',
                                                    'data-event="',
                                                    a,
                                                    '" ',
                                                    'data-value="',
                                                    h,
                                                    '" ',
                                                    'title="',
                                                    f,
                                                    '" ',
                                                    'aria-label="',
                                                    f,
                                                    '" ',
                                                    'data-toggle="button" tabindex="-1"></button>',
                                                ].join("")
                                            );
                                        }
                                        o.push(
                                            '<div class="note-color-row">' +
                                                c.join("") +
                                                "</div>"
                                        );
                                    }
                                    e.html(o.join("")),
                                        n.tooltip &&
                                            e.find(".note-color-btn").tooltip({
                                                container:
                                                    n.container || t.container,
                                                trigger: "hover",
                                                placement: "bottom",
                                            });
                                }
                            )(e, n);
                        },
                        button: function (e, n) {
                            return r.a.create(
                                '<button type="button" class="note-btn btn btn-light btn-sm" tabindex="-1">',
                                function (e, n) {
                                    n &&
                                        n.tooltip &&
                                        e
                                            .attr({
                                                title: n.tooltip,
                                                "aria-label": n.tooltip,
                                            })
                                            .tooltip({
                                                container:
                                                    n.container || t.container,
                                                trigger: "hover",
                                                placement: "bottom",
                                            })
                                            .on("click", function (t) {
                                                i()(t.currentTarget).tooltip(
                                                    "hide"
                                                );
                                            }),
                                        n &&
                                            n.codeviewButton &&
                                            e.addClass("note-codeview-keep");
                                }
                            )(e, n);
                        },
                        toggleBtn: function (t, e) {
                            t.toggleClass("disabled", !e),
                                t.attr("disabled", !e);
                        },
                        toggleBtnActive: function (t, e) {
                            t.toggleClass("active", e);
                        },
                        onDialogShown: function (t, e) {
                            t.one("shown.bs.modal", e);
                        },
                        onDialogHidden: function (t, e) {
                            t.one("hidden.bs.modal", e);
                        },
                        showDialog: function (t) {
                            t.modal("show");
                        },
                        hideDialog: function (t) {
                            t.modal("hide");
                        },
                        createLayout: function (e) {
                            var n = (
                                t.airMode
                                    ? f([c([u(), p()])])
                                    : "bottom" === t.toolbarPosition
                                    ? s([c([u(), d()]), l(), h()])
                                    : s([l(), c([u(), d()]), h()])
                            ).render();
                            return (
                                n.insertAfter(e),
                                {
                                    note: e,
                                    editor: n,
                                    toolbar: n.find(".note-toolbar"),
                                    editingArea: n.find(".note-editing-area"),
                                    editable: n.find(".note-editable"),
                                    codable: n.find(".note-codable"),
                                    statusbar: n.find(".note-statusbar"),
                                }
                            );
                        },
                        removeLayout: function (t, e) {
                            t.html(e.editable.html()),
                                e.editor.remove(),
                                t.show();
                        },
                    };
                };
            n(3), n(5);
            (i.a.summernote = i.a.extend(i.a.summernote, {
                ui_template: x,
                interface: "bs4",
            })),
                (i.a.summernote.options.styleTags = [
                    "p",
                    {
                        title: "Blockquote",
                        tag: "blockquote",
                        className: "blockquote",
                        value: "blockquote",
                    },
                    "pre",
                    "h1",
                    "h2",
                    "h3",
                    "h4",
                    "h5",
                    "h6",
                ]);
        },
    });
});
//# sourceMappingURL=summernote-bs4.min.js.map

const CustomerAutoloadDataService = (function () {
    var objSelect2Suggest = {
        subject: {
            url: window.API_URL + "/subject",
            formated: "$(title)",
            id: "_id",
            query: ["intelligence", "language"],
        },
        notification_template: {
            url: window.API_URL + "/notification-template",
            formated: "$(name)",
            id: "_id",
            query: ["type"],
        },
        skill: {
            url: window.API_URL + "/skill",
            formated: "$(title)",
            id: "_id",
            query: ["subject_id", "language"],
        },
        roadmap: {
            // 'url': window.API_URL + '/crm/contacts/find',
            url: window.API_URL + "/roadmap",
            formated: "$(title)",
            id: "_id",
            query: ["language"],
        },
        mc: {
            // 'url': window.API_URL + '/crm/contacts/find',
            url: window.API_URL + "/mc",
            formated: "$(title)",
            id: "_id",
            query: ["type"],
        },
        code_type: {
             
            url: window.API_URL + "/code-type",
            formated: "$(title)",
            id: "_id",
            query: [],
        },
        audio: {
            // 'url': window.API_URL + '/crm/contacts/find',
            url: window.API_URL + "/music",
            formated: "$(title)",
            id: "_id",
            query: ["type"],
        },

        level: {
            // 'url': window.API_URL + '/crm/contacts/find',
            url: window.API_URL + "/level",
            formated: "$(title)",
            id: "_id",
            query: ["language"],
        },
        campaign: {
            // 'url': window.API_URL + '/crm/contacts/find',
            url: window.API_URL + "/campaign",
            formated: "$(title)",
            id: "_id",
            query: [ "status"],
        },
        topic: {
            url: window.API_URL + "/topic",
            formated: "$(title)",
            id: "_id",
            query: ["title", "parent_id", "language"],
        },
        category_articles: {
            url: window.API_URL + "/category-article",
            formated: "$(title)",
            id: "_id",
            query: ["type"],
        },
        category_product: {
            url: window.API_URL + "/category-product",
            formated: "$(title)",
            id: "_id",
            query: ["status", "parent_id"],
        },
        product: {
            url: window.API_URL + "/product",
            formated: "$(title)",
            id: "_id",
            query: ["status"],
        },

        exercise_type: {
            url: window.API_URL + "/exercise-type",
            html: "$(title) - $(code)",
            // search_param: "title",
            formated: "$(title)",
            id: "_id",
            query: [],
        },
    };
    var arrDomAutoFill = [
        {
            url: window.API_URL + "/roadmap",
            dom: ".em-customer-roadmap",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/campaign",
            dom: ".em-customer-campaign",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/subject",
            dom: ".em-customer-subject",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/mc",
            dom: ".em-customer-mc",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/music",
            dom: ".em-customer-audio",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/product",
            dom: ".em-product",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/exercise-type",
            dom: ".em-customer-exercise-type",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/category-article",
            dom: ".em-customer-category-article",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/category-article",
            dom: ".em-customer-category-article",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/exercise",
            dom: ".em-customer-exercise",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/category-product",
            dom: ".em-category-product",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/skill",
            dom: ".em-customer-skill",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/topic",
            dom: ".em-customer-topic",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
        {
            url: window.API_URL + "/level",
            dom: ".em-customer-level",
            attr: "data-id",
            formated: "$(title)",
            fk: "_id",
        },
    ];

    //
    // Setup module components
    //

    // Basic Datatable examples
    var replaceData = function (parentDom) {
        $.each(arrDomAutoFill, function (idx, item) {
            var focusDom = parentDom.find(item.dom);

            if (!focusDom.length) {
                return true;
            }

            /////////// FIX TAM CHO CAC DOM DANG CHAY ///////////

            /////////////  END //////////////////

            //if (item.pquery) {
            var arrId = [];
            focusDom.each(function () {
                var selfDom = $(this);
                if (selfDom.prop("tagName") == "SELECT") {
                    selfDom.find("option").each(function () {
                        var v = $(this).val();
                        if (v && $.inArray(v, arrId) == -1) {
                            arrId.push(v);
                        }
                    });
                } else {
                    var v = selfDom.attr(item.attr);

                    if (v && $.inArray(v, arrId) == -1) {
                        arrId.push(v);
                    }
                }
            });

            if (!arrId.length) {
                return;
            }
            arrId = arrId.map(($item) => parseInt($item));
            arrId = arrId.filter(unique);
            var count = 1;
            if (arrId.length > 200) {
                // lay so lam tron len
                count = Math.ceil(arrId.length / 200);
            }
            for (i = 1; i <= count; i++) {
                var objParams = {};

                var inqId = arrId.slice((i - 1) * 200, 200 * i);

                objParams[item.fk] = inqId;

                objParams[item.fk] = inqId;

                //replace url arg
                var urlQuery = item.url;
                if (item.url_arg) {
                    $.each(item.url_arg, function (k, v) {
                        urlQuery = urlQuery.replace(
                            "{" + k + "}",
                            objParams[v]
                        );
                        delete objParams[v];
                    });
                }

                var dataGet = {};

                if (!$.isEmptyObject(objParams)) {
                    dataGet = {
                        where: objParams,
                        option: { limit: 500 },
                    };
                    // dataGet = {filter: objParams,'limit': 500};
                }

                let token = window.TOKEN_API_CLIENT;

                //console.log(urlQuery,objParams);
                // ktra query bat buoc
                $.ajax({
                    url: urlQuery,
                    type: "GET",
                    dataType: "json",
                    // xhrFields: {
                    //   withCredentials: true
                    // },
                    data: dataGet,
                    contentType:
                        "application/x-www-form-urlencoded; charset=UTF-8",
                    // beforeSend: function(xhr) {
                    //     //console.log('test',xhr);
                    // },
                    headers: {
                        Authorization: "Bearer " + token,
                    },
                    success: function (response) {
                        if (response.error) {
                            ////console.log(data);
                            return false;
                        }
                        var new_str = item.formated;
                        var new_link = item.link;
                        var objData = {};
                        objLink = {};
                        $.each(response, function (key, value) {
                            objData[value[item.fk]] = value;
                        });
                        focusDom.each(function () {
                            if ($(this).prop("tagName") == "SELECT") {
                                var selectData = $(this);
                                var tmp = $(this).attr("data-format")
                                    ? $(this).attr("data-format")
                                    : new_str;
                                selectData
                                    .find("option")
                                    .each(function (element, key) {
                                        var v = $(this).val();
                                        if (objData[v]) {
                                            var replaced = formatReplace(
                                                tmp,
                                                objData[v]
                                            );
                                            $(this).text(replaced);
                                            setTimeout(function () {
                                                selectData.trigger(
                                                    "change_select2"
                                                );
                                            }, 1000);
                                        }
                                    });
                                selectData.trigger("change");
                            } else {
                                var v = $(this).attr(item.attr);
                                var _self = $(this);

                                if (objData[v]) {
                                    var tmp = $(this).attr("data-format")
                                        ? $(this).attr("data-format")
                                        : new_str;
                                    if (new_link) {
                                        $(this).html(
                                            '<a href="' +
                                                formatReplace(
                                                    new_link,
                                                    objData[v]
                                                ) +
                                                '" target="_blank">' +
                                                formatReplace(tmp, objData[v]) +
                                                "</a>"
                                        );
                                    } else {
                                        $(this).text(
                                            formatReplace(tmp, objData[v])
                                        );
                                    }
                                }
                            }
                        });
                    },
                    error: function () {},
                });
            }
        });
    };
    var selectData = function (parentDom) {
        var __cache = [];
        parentDom.find(".select2_customer").each(function () {
            var self = $(this);
            loadSelectData(self);
            $(this).bind("change_select2", function (e) {
                var getID = $(this).select2("data");
                //console.log(getID[0]['_resultId']);
                var resultID = getID[0]["_resultId"];

                var res = resultID.split("-result-");

                //.text("TEST");
                $("#" + res[0] + "-container").text(
                    self.find("option:selected").text()
                );
            });
        });
    };

    var loadSelectData = function (current_dom, option = {}) {
        var dataTable = option.module || current_dom.attr("data-module");
        var showType = option.show || current_dom.attr("data-show");
        if (!dataTable) {
            return false;
        }
        var objData = objSelect2Suggest[dataTable];

        var urlLoad = objData.url || "";
        if (typeof objSelect2Suggest == "undefined" || !objData) {
            console.log("Suggest data" + dataTable + " not found");
            return false;
        }
        if (!urlLoad) {
            console.log("Thieu config cho suggest");
            return false;
        }
        var objParams = {};

        if (typeof option.query != "undefined") {
            $.each(option.query, function (qidx, qkey) {
                if (typeof objData["url_to_" + qidx] != "undefined") {
                    urlLoad = formatReplace(objData["url_to_" + qidx], {
                        [qidx]: qkey,
                    });
                } else {
                    if (typeof qkey == "object") {
                        objParams[qidx] = { inq: qkey };
                    } else {
                        objParams[qidx] = { eq: qkey };
                    }
                }
            });
        } else if (typeof objData.query != "undefined") {
            $.each(objData.query, function (qidx, qkey) {
                var objQuery = current_dom.attr("data-query-" + qkey);
                if (objQuery) {
                    if (typeof objData["url_to_" + qkey] != "undefined") {
                        urlLoad = formatReplace(objData["url_to_" + qkey], {
                            [qkey]: objQuery,
                        });
                    } else {
                        if (objQuery.indexOf(",") > 0) {
                            objQuery = objQuery.split(",");
                            objParams[qkey] = { inq: objQuery };
                        } else {
                            objParams[qkey] = objQuery;
                        }
                    }
                }
            });
        }
        var search_param = objData.search_param || "";
        //console.debug(objParams);
        var minimumInputLength =
            (typeof showType == "undefined" || showType != "all") &&
            search_param
                ? 2
                : 0;
        var limit = search_param ? 50 : 500;
        var __cache = [];
        let token = window.TOKEN_API_CLIENT;

        current_dom.select2({
            minimumInputLength: minimumInputLength,
            allowClear: true,
            cache: true,
            placeholder: current_dom.attr("placeholder") || "Select an option",
            ajax: {
                url: urlLoad,
                dataType: "json",
                delay: 300,
                cache: true,
                data: function (params) {
                    var query = {};
                    if (minimumInputLength > 0) {
                        if (search_param == "keyword") {
                            var moreParams = { keyword: params.term };
                        } else {
                            query = {
                                [search_param]: {
                                    like: params.term,
                                },
                            };
                        }
                    }
                    $.extend(query, objParams);
                    var offset =
                        params.page > 1 ? (params.page - 1) * limit : 0;
                    if (objData.version != 2) {
                        var result = {
                            where: query,
                            option: {
                                limit: limit,
                                offset: offset,
                            },
                        };
                    } else {
                        var result = {
                            filter: JSON.stringify({
                                where: query,
                                limit: limit,
                                offset: offset,
                            }),
                        };
                    }

                    if (typeof moreParams != "undefined") {
                        $.extend(result, moreParams);
                    }
                    return result;
                },
                headers: {
                    Authorization: "Bearer " + token,
                },
                processResults: function (data, params) {
                    if (data.error) {
                        //console.log(data);
                        return false;
                    }
                    var term = stringToSlug($.trim(params.term).toLowerCase());
                    //console.log(params);
                    var new_str = objData.formated;
                    var tmp = current_dom.attr("data-format")
                        ? current_dom.attr("data-format")
                        : new_str;
                    var tmp_val = current_dom.attr("data-format-val")
                        ? current_dom.attr("data-format-val")
                        : "$(" + objData.id + ")";
                    var html = objData.html || "";
                    var dataResult = [];
                    $.each(data, function (item_key, item) {
                        //console.log(tmp,item);
                        if (item) {
                            var replaced = formatReplace(tmp, item);
                            var valReplaced = formatReplace(tmp_val, item);
                            var htmlReplace = !html
                                ? replaced
                                : formatReplace(html, item);
                            if (params.term && !search_param) {
                                if (
                                    stringToSlug(
                                        replaced.toLowerCase()
                                    ).indexOf(term) > -1
                                ) {
                                    dataResult.push({
                                        id: valReplaced,
                                        text: replaced,
                                        html: htmlReplace,
                                    });
                                }
                            } else {
                                dataResult.push({
                                    id: valReplaced,
                                    text: replaced,
                                    html: htmlReplace,
                                });
                            }
                        }
                    });
                    //console.log(dataResult);
                    // Transforms the top-level key of the response object from 'items' to 'results'
                    return {
                        results: dataResult,
                        pagination: {
                            more: dataResult.length == limit ? true : false,
                        },
                    };
                },
                transport: function (params, success, failure) {
                    //retrieve the cached key or default to _ALL_
                    //console.log(params);
                    var __cachekey = params.url + "?" + $.param(params.data);
                    if ("undefined" !== typeof __cache[__cachekey]) {
                        success(__cache[__cachekey]);
                        return;
                    }
                    var $request = $.ajax(params);
                    $request.then(function (data) {
                        //store data in cache
                        __cache[__cachekey] = data;
                        //display the results
                        success(__cache[__cachekey]);
                    });
                    $request.fail(failure);
                    //return $request;
                },
            },
            templateResult: function (data) {
                return $($.parseHTML(data.html));
            },
        });
    };
    $.fn.loadSuggestData = function (params) {
        var o = $(this[0]); // This is the element
        loadSelectData($(this), params);
        return this; // This is needed so other functions can keep chaining off of this
    };

    //
    // Return objects assigned to module
    //
    var dependentDataSelect = function (dom) {
        var select_subject = $(dom).find("select.subject_id");
        var select_skill = $(dom).find("select.skill_id");
        var select_topic_parent = $(dom).find("select.class-topic-parents");
        var select_topic = $(dom).find("select.class-topic-children");
        var select_intelligence = $(dom).find("select.intelligence");

        $(select_intelligence)
            .off("change")
            .on("change", function () {
                $(select_subject).attr(
                    "data-query-intelligence",
                    $(this).val()
                );
                selectData($(select_subject).closest(".form-group"));
            });

        $(select_subject)
            .off("change")
            .on("change", function () {
                $(select_skill).attr("data-query-subject_id", $(this).val());
                selectData($(select_skill).closest(".form-group"));
            });

        $(select_topic_parent)
            .off("change")
            .on("change", function () {
                $(select_topic)
                    .attr("data-query-parent_id", $(this).val())
                    .removeClass("select2_customer")
                    .addClass("select2_customer");
                selectData($(select_topic).closest(".form-group"));
            });
        // $(document).on('change', 'select.subject_id', function () {
        //     console.log("true");
        // })
    };
    return {
        init: async function (parentDom) {
            replaceData(parentDom);
            selectData(parentDom);
            dependentDataSelect(parentDom);
        },
        initReload: function (parentDom) {
            selectData(parentDom);
        },
    };
})();

/// Upload fileManager:
var uploadFileManager = (function () {
    var route_prefix = window.SERVICE_UPLOAD_FILEMANAGER;
    var _uploadImage = (parentDom) => {
        $(parentDom)
            .find(".btn-upload-image")
            .each(function (i, item) {
                let url = $(item)
                    .closest("div")
                    .find('input[type="text"]')
                    .val();
                if (url) {
                    $(item)
                        .closest("div")
                        .find("span.view-image")
                        .css("background-image", "url(" + url + ")");
                }

                $(item)
                    .off("click")
                    .on("click", function (e) {
                        var dom = $(this).closest(".form-group");
                        var type = $(this).attr("data-type");
                        var preview = $(this).data("preview");
                        window.open(
                            route_prefix + "?type=" + type || "file",
                            "FileManager",
                            "width=900,height=600"
                        );
                        window.SetUrl = function (items) {
                            var file_path = items
                                .map(function (item) {
                                    let url = new URL(item.url);
                                    return url.href;
                                })
                                .join(",");

                            $(dom).find("input[type='text']").val(file_path);
                            let imageUrl = file_path;
                            $(dom)
                                .find("span.view-image")
                                .css(
                                    "background-image",
                                    "url(" + imageUrl + ")"
                                );
                        };
                    });
            });
    };

    return {
        init: function (parentDom) {
            _uploadImage(parentDom);
        },
    };
})();

// Initialize module
// ------------------------------
// $(document).on("DOMContentLoaded MainContentReloaded", function (e) {
//     AutoloadDataService.init($(document));
// });

var loadContentTopic = (function () {
    var loadContent = (dom) => {
        $(dom).on("change", "select.class-topic-parents", function (e) {
            let val = $(this).val();
            if (val !== null) {
                $(dom)
                    .find("select.class-topic-children")
                    .val("")
                    .attr("data-query-parent_id", val)
                    .addClass("select2_suggest");
                CustomerAutoloadDataService.initReload($(dom));
            }
        });
    };
    return {
        init: function (domId) {
            loadContent(domId);
        },
    };
})();

// Initialize module
// ------------------------------
// $(document).on("DOMContentLoaded MainContentReloaded", function (e) {
//     AutoloadDataService.init($(document));
// });

var Summernote = (function () {
    //
    // Setup module components
    //
    // Define function to open filemanager window
    var lfm = function (options, cb) {
        var route_prefix =
            window.SERVICE_UPLOAD_FILEMANAGER + "?type=" + options.type ||
            "file";
        window.open(route_prefix, "FileManager", "width=900,height=600");
        window.SetUrl = cb;
    };

    // Define LFM summernote button
    var LFMButtonImg = function (context) {
        var ui = $.summernote.ui;
        var button = ui.button({
            contents: '<i class="note-icon-picture"></i> ',
            tooltip: "Insert image with filemanager",
            click: function () {
                lfm(
                    { type: "image", prefix: "/laravel-filemanager" },
                    function (lfmItems, path) {
                        lfmItems.forEach(function (lfmItem) {
                            context.invoke("insertImage", lfmItem.url);
                        });
                    }
                );
            },
        });
        return button.render();
    };

    // Define LFM summernote button
    var LFMLINK = function (context) {
        var ui = $.summernote.ui;
        var button = ui.button({
            contents: '<i class="note-icon-picture"></i> ',
            tooltip: "Insert file with filemanager",
            click: function () {
                lfm(
                    { type: "file", prefix: "/laravel-filemanager" },
                    function (lfmItems, path) {
                        lfmItems.forEach(function (lfmItem) {
                            context.invoke("insertImage", lfmItem.url);
                        });
                    }
                );
            },
        });
        return button.render();
    };
    // Summernote
    var _componentSummernote = function (domElement) {
        var self = $("." + domElement);
        if (!$().summernote) {
            console.warn("Warning - summernote.min.js is not loaded.");
            return;
        }

        // Basic examples
        // ------------------------------
        // Default initialization
        $(self).summernote({
            toolbar: [
                ["style", ["style"]],
                ["font", ["bold", "italic", "underline", "clear"]],
                ["fontname", ["fontname"]],
                ["color", ["color"]],
                ["view", ["fullscreen", "codeview", "hr"]],
                ["para", ["ul", "ol", "paragraph"]],
                ["height", ["height"]],
                ["table", ["table"]],
                ["insert", ["link", "lfm", "video"]],
                ["help", ["help"]],
            ],
            height: 300,
            buttons: {
                link: LFMLINK,
                lfm: LFMButtonImg,
            },
        });
        // // Save
        // $('#save').on('click', function() {
        //     var aHTML = $('.click2edit').summernote('code');
        //     $('.click2edit').summernote('destroy');
        // });
    };

    var loadContent = (dom) => {
        setTimeout(function () {
            _componentSummernote(dom);
        }, 300);
    };

    //
    // Return objects assigned to module
    //

    return {
        init: function (domID) {
            loadContent(domID);
        },
    };
})();

$(document).on("DOMContentLoaded MainContentReloaded", function (e) {
    $("#btn-filter")
        .off("click")
        .on("click", function (e) {
            //alert("KO")
            e.preventDefault();
            $(".sidebar-secondary").toggleClass("sidebar-collapsed");
        });

    $("#content_input_game").on("change", ".checkbox_ansewer", function (e) {
        if ($(this).prop("checked") == true) {
            $(this).parent().find("input.ansewer").attr("value", 1);
        } else if ($(this).prop("checked") == false) {
            $(this).parent().find("input.ansewer").attr("value", 0);
        }
    });

    CustomerAutoloadDataService.init($(document));
    uploadFileManager.init($(e.target));

    $(".select2-option").select2({
        minimumResultsForSearch: Infinity,
        placeholder: "Select State...",
    });
    $("#content_input_game")
        .find('.form-group.upload-image input[type="text"]')
        .each(function (i, item) {
            let _link = $(item).val();
            if (_link) {
                $(item)
                    .parent()
                    .find(".view-image")
                    .css(
                        "background-image",
                        "url(" + window.APP_URL + _link + ")"
                    );
            }
        });
});

function debounce(callback, wait) {
    let timerId;
    return (...args) => {
        clearTimeout(timerId);
        timerId = setTimeout(() => {
            callback(...args);
        }, wait);
    };
}

function renderRepeater(dom, attr = {}) {
    $(dom).repeater({
        initEmpty: false, 
        defaultValues: attr.defaultValues ?? {},
        show: async function () {
            let length = $(dom).find(".form-group-parent").length;

            if (attr.max && length > attr.max) {
                show_notify_error({
                    message: "Tối đa " + attr.max + " bản ghi",
                });
                $(this)
                    .closest(dom)
                    .find('div.form-group[style="display: none;"]')
                    .remove();
                return;
            }

            if (attr.checkbox) {
                let checkbox = $(dom).find(
                    '.form-group-parent input[type="checkbox"]'
                ).length;
                if (checkbox) {
                    var checked = false;
                    $(dom)
                        .find(".form-group-parent input.checkbox_result")
                        .each(function (i, item) {
                            if ($(item).val() == 1) checked = true;
                        });
                    if (!checked) {
                        show_notify_error({
                            title: "Cảnh báo !!!",
                            type: "warning",
                            message: "Bạn chưa tích chọn đáp án",
                        });
                    }
                }
            } 
            if (attr.title && attr.class_title) {
                $(dom)
                    .find(attr.class_title)
                    .find("label")
                    .each(function (index, item) {
                        $(item).html(`${attr.title} ${index + 1}:`);
                    });
            }

            await $(this).slideDown();
            uploadFileManager.init($(dom)); 
            if (attr.callback && typeof attr.callback == "function") { 
                await attr.callback(attr);
            }
        },
        hide: function (deleteElement) {
            $(this).slideUp(deleteElement);
            $(this).remove();
            $(this)
                .closest(dom)
                .find('div.form-group[style="display: none;"]')
                .remove();
            if (attr.title && attr.class_title) {
                $(dom)
                    .find(attr.class_title)
                    .find("label")
                    .each(function (index, item) {
                        $(item).html(`${attr.title} ${index + 1}:`);
                    });
            }
            if (attr.callback && typeof attr.callback == "function") {
                attr.callback();
            }
        },
        // initEmpty: true,
    });
}
